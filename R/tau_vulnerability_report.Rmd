---
title: "Tau Vulnerability Report"
author:
  - name: "Emir Turkes [et2628@cumc.columbia.edu]"
  - name: "Columbia University"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
bibliography: "../tau-vulnerability.bib"
biblio-style: apalike
link-citations: true
output:
  html_document:
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
knit:
  (function(inputFile, encoding) {
    rmarkdown::render(
      inputFile, encoding = encoding, output_file = "../results/tau-vulnerability-report.html")})
---

```{r, include = FALSE}
#    This file is part of tau-vulnerability.
#    Copyright (C) 2019  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

knitr::opts_chunk$set(fig.width = 8.5, fig.height = 7)
```

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
div.main-container {max-width: none; width: 100%;}
</style>

*This is an in-depth analysis to characterize differential vulnerability to tauopathy.*

The background for this data is as follows:

This analysis was performed in R except where noted.
The source code and instructions for rerunning the analysis can be found at [github.com/eturkes/tau-vulnerability](https://github.com/eturkes/tau-vulnerability).

# Final Results

**Read just this section for the final results of the analysis and a summary of the methods.**

# ~~~ Breakdown of Methods ~~~ {-}

**Sections from here to the end break down the methods used and are optional to read.**

We start by loading in any required packages and setting some global variables.

```{r}
packages <- c(
  "conflicted", "ggplot2", "SingleCellExperiment", "data.table", "DT", "scran", "scater", "ggrepel",
  "BiocSingular", "svd", "Rtsne", "S4Vectors", "SC3", "gprofiler2", "kableExtra", "dplyr")
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))

options(stringsAsFactors = FALSE)

assets_dir <- file.path(getwd(), "..", "assets")
results_dir <- file.path(getwd(), "..", "results")

# Define a custom function for plotting.
dim_red_plot <- function(data, x, y, col, type) {
  gg <- ggplot(data, aes_string(x = x, y = y, color = col)) +
    geom_point(alpha = 0.35, stroke = 0.05, shape = 21, aes_string(fill = col)) +
    theme_classic() +
    theme(
      legend.position = "right", plot.title = element_text(hjust = 0.5),
      legend.title = element_blank()) +
    guides(color = guide_legend(override.aes = list(alpha = 1)))
    if (type == "cat") {
      gg <- gg + geom_label_repel(data = label_df2, aes(label = label), show.legend = FALSE)}
    else if (type == "cont") {
      gg <- ggplot(data, aes_string(x = x, y = y)) +
        geom_point(alpha = 0.35, stroke = 0.05, aes_string(color = col)) +
        theme_classic() +
        theme(
          legend.position = "right", plot.title = element_text(hjust = 0.5),
          legend.title = element_blank()) +
        scale_colour_gradient(low = "blue", high = "red")}
  gg}
```

# Original Data

We start by reading in data from previous broad analyses and displaying their final results.

## Habib 2017 snRNAseq {.tabset}

The cleaned dataset here is derived from the analysis in [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq), which uses data from @habib_massively_2017.
For full details of preprocessing, please see that analysis, but in brief, standard QC for droplet-based UMI protocols was applied with attention to particular thresholds used in @habib_massively_2017.
The main results of the original publication is k-nearest-neighbor clustering visualized by tSNE, which identified 15 cell types within PFC and hippocampal tissues of five healthy human donors.
As cluster labels and tSNE coordinates were released by the authors, the main figure was recreated in the analysis, along with a successful attempt at replicating that data.

```{r}
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))
sce_hvg <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce_hvg.rds"))

tmp_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(tmp_df) <- paste0("hvg_tsne", seq(ncol(tmp_df)))
df_hvg <- data.frame(
  colData(sce_hvg)[ , c(
    "sample", "cell_id_stem", paste0("habib_tsne", 1:2), "log10_total_features_by_counts",
    "habib_cluster", "habib_cluster_name", "km_17_clusters_name")],
  tmp_df)
rownames(df_hvg) <- NULL
df_hvg$habib_cluster_name <- factor(df_hvg$habib_cluster_name)
df_hvg$km_17_clusters_name <- factor(df_hvg$km_17_clusters_name)
```

```{r}
sce
sce_hvg
```

### Habib Clusters Habib tSNE

```{r}
label_df <- data.frame(
  habib_cluster_name = levels(df_hvg$habib_cluster_name), label = levels(df_hvg$habib_cluster_name))
label_df2 <- df_hvg %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)
dim_red_plot(
  data = df_hvg, x = "habib_tsne1", y = "habib_tsne2",col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters Habib tSNE")
```

### New Clusters Habib tSNE

```{r}
label_df <- data.frame(
  km_17_clusters_name = levels(df_hvg$km_17_clusters_name),
  label = levels(df_hvg$km_17_clusters_name))
label_df2 <- df_hvg %>%
  group_by(km_17_clusters_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)
dim_red_plot(
  data = df_hvg, x = "habib_tsne1", y = "habib_tsne2", col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("New Clusters Habib tSNE")
```

### Habib Clusters New tSNE

```{r}
label_df <- data.frame(
  habib_cluster_name = levels(df_hvg$habib_cluster_name), label = levels(df_hvg$habib_cluster_name))
label_df2 <- df_hvg %>%
  group_by(habib_cluster_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)
dim_red_plot(
  data = df_hvg, x = "hvg_tsne1", y = "hvg_tsne2",
  col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters New tSNE")
```

### New Clusters New tSNE

```{r}
label_df <- data.frame(
  km_17_clusters_name = levels(df_hvg$km_17_clusters_name),
  label = levels(df_hvg$km_17_clusters_name))
label_df2 <- df_hvg %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)
dim_red_plot(
  data = df_hvg, x = "hvg_tsne1", y = "hvg_tsne2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("New Clusters New tSNE")
```

# EX/IN Neurons of the PFC

We start by looking in the PFC region and exploring differences in excitatory and inhibitory neurons.
Tabs separate analyses for different datasets.

## Preliminary Cleaning {.tabset}

Subsetting and any other necessary cleaning take place at this stage.

### Habib 2017 snRNAseq

```{r}
# Create a unique cache for each iterated section.
if (!dir.exists(file.path(assets_dir, "cache1"))) {
  dir.create(file.path(assets_dir, "cache1"))}

regions <- "PFC"
c_types_habib <- "exPFC1|exPFC2|GABA1|GABA2"
c_types_km <- "exPFC|GABA1|GABA2"

keep <- grepl(regions, colData(sce)$cell_id_stem)
sce <- sce[ , keep]
keep <- grepl(c_types_habib, colData(sce)$habib_cluster_name)
sce <- sce[ , keep]

keep <- grepl(regions, colData(sce_hvg)$cell_id_stem)
sce_hvg <- sce_hvg[ , keep]
keep <- grepl(c_types_km, colData(sce_hvg)$km_17_clusters_name)
sce_hvg <- sce_hvg[ , keep]

tmp_df <- data.frame(reducedDim(sce, "TSNE"))
names(tmp_df) <- paste0("allgenes_tsne", seq(ncol(tmp_df)))
df_allgenes <- data.frame(
  colData(sce)[ , c(
    "sample", "cell_id_stem", paste0("habib_tsne", 1:2),
    "log10_total_features_by_counts", "habib_cluster", "habib_cluster_name")],
  tmp_df)
rownames(df_allgenes) <- NULL
df_allgenes$habib_cluster_name <- factor(df_allgenes$habib_cluster_name)

tmp_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(tmp_df) <- paste0("hvg_tsne", seq(ncol(tmp_df)))
df_hvg <- data.frame(
  colData(sce_hvg)[ , c(
    "sample", "cell_id_stem", paste0("habib_tsne", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  tmp_df)
rownames(df_hvg) <- NULL
df_hvg$km_17_clusters_name <- factor(df_hvg$km_17_clusters_name)
```

```{r}
dim(sce)
dim(sce_hvg)
```

## Dimensionality Reduction {.tabset}

This section details steps taken to reduce the dimensionality of the dataset.

### Habib 2017 snRNAseq

We start by visualizing the tSNE coordinates provided in @habib_massively_2017 at this subset level.
It should be noted that these coordinates may not optimal as they were generated while analyzing the entire set.
Another thing to note is that they were created using HVGs (highly variable genes) rather than the entire list of genes in the dataset.

```{r}
label_df <- data.frame(
  habib_cluster_name = levels(df_allgenes$habib_cluster_name),
  label = levels(df_allgenes$habib_cluster_name))
label_df2 <- df_allgenes %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)
dim_red_plot(
  data = df_allgenes, x = "habib_tsne1", y = "habib_tsne2",
  col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons Habib Clusters Habib tSNE")
```

Next we take a look at the k-means clusters in the original broad analysis at [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq).
We view them on the HVG tSNEs created in the same previous analysis.

```{r}
label_df <- data.frame(
  km_17_clusters_name = levels(df_hvg$km_17_clusters_name),
  label = levels(df_hvg$km_17_clusters_name))
label_df2 <- df_hvg %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)
dim_red_plot(
  data = df_hvg, x = "hvg_tsne1", y = "hvg_tsne2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons KM 17 Clusters Old HVG tSNE")
```

From here, we apply techniques on the subset data itself, which may be more informative than dimensionality reduction that was performed on the entire dataset.
To simply the analysis, we select one of the two clustering/tSNE schemes, choosing the k-means/HVG tSNE combination as it has been clustered into three rather than four clusters, which will facilitate more straightforward three-way analyses.
This requires moving some data around to consolidate it into one SCE object.

```{r}
# Both SCE objects must be subset the same way for this to work.
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))
sce_hvg <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce_hvg.rds"))
keep <- grepl(regions, colData(sce_hvg)$cell_id_stem)
sce <- sce[ , keep]
sce_hvg <- sce_hvg[ , keep]
keep <- grepl(c_types_km, colData(sce_hvg)$km_17_clusters_name)
sce <- sce[ , keep]
sce_hvg <- sce_hvg[ , keep]

allgenes_pca_orig <- reducedDim(sce, "PCA")
hvg_pca_orig <- reducedDim(sce_hvg, "PCA")

tmp_df <- data.frame(reducedDim(sce, "TSNE"))
names(tmp_df) <- paste0("allgenes_tsne_orig", seq(ncol(tmp_df)))
tmp_df2 <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(tmp_df2) <- paste0("hvg_tsne_orig", seq(ncol(tmp_df)))

colData(sce) <- cbind(
  colData(sce), km_17_clusters = sce_hvg$km_17_clusters,
  km_17_clusters_name = sce_hvg$km_17_clusters_name, allgenes_tsne_orig1 = tmp_df[1],
  allgenes_tsne_orig2 = tmp_df[2], hvg_tsne_orig1 = tmp_df2[1],
  hvg_tsne_orig2 = tmp_df2[2])

rm(tmp_df2)
sce
```

Now that our data is consolidated, we perform PCA using `denoisePCA` from the `scran` package, which automatically selects PCs by modeling technical noise.

```{r}
new_trend <- makeTechTrend(x = sce)
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "pca.rds")
if (file.exists(rds)) {
  pca <- readRDS(rds)
} else {
  pca <- denoisePCA(sce, technical = new_trend, BSPARAM = IrlbaParam())
  saveRDS(pca, rds)}
```

```{r}
sce <- pca
tmp_df <- data.frame(reducedDim(sce, "PCA"))
names(tmp_df) <- paste0("allgenes_pc_new", seq(ncol(tmp_df)))
df_allgenes <- data.frame(
  colData(sce)[ , c(
    "sample", "cell_id_stem", paste0("hvg_tsne_orig", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  tmp_df[1:2])
rownames(df_allgenes) <- NULL
df_allgenes$km_17_clusters_name <- factor(df_allgenes$km_17_clusters_name)
rm(pca)
```

We use the first 50 PCs, with their ability to explain variance shown here.

```{r}
par(mfrow = c(1, 1))
plot(
  log10(attr(reducedDim(sce), "percentVar")), xlab = "PC",
  ylab = "log10(Proportion of Variance Explained)", pch = 20,
  cex = 0.6, col = rgb(0.8, 0.2, 0.2, 0.5))
abline(v = ncol(reducedDim(sce, "PCA")), lty = 2, col = "red")
```

We visualize only the first two components as they may have more descriptive power than usual for this smaller subset. As expected, we see that PCA alone has decent power to separate EX/IN neurons.

```{r}
plotPCA(sce, colour_by = "km_17_clusters_name") +
  ggtitle("PFC EX/IN Neurons KM 17 Clusters PCA") + theme(legend.title = element_blank())
```

Now we create new tSNEs for the subsetted region and samples, first using all genes in the dataset.
Running through perplexity values in the range of 5-100 revealed generally similar results, aside from expected differences in the extremes of the range.
We settle upon a conservative value of 30.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "runTSNE.rds")
if (file.exists(rds)) {
  runTSNE <- readRDS(rds)
} else {
  runTSNE <- runTSNE(sce, use_dimred = "PCA", perplexity = 30, rand_seed = 1)
  saveRDS(runTSNE, rds)}
```

```{r}
sce <- runTSNE
tmp_df <- data.frame(reducedDim(sce, "TSNE"))
names(tmp_df) <- paste0("allgenes_tsne_new", seq(ncol(tmp_df)))
df_allgenes <- data.frame(df_allgenes, tmp_df)
rm(runTSNE)
label_df <- data.frame(
  km_17_clusters_name = levels(df_allgenes$km_17_clusters_name),
  label = levels(df_allgenes$km_17_clusters_name))
label_df2 <- df_allgenes %>%
  group_by(km_17_clusters_name) %>%
  summarize(
    allgenes_tsne_new1 = median(allgenes_tsne_new1),
    allgenes_tsne_new2 = median(allgenes_tsne_new2)) %>%
  left_join(label_df)
dim_red_plot(
  data = df_allgenes, x = "allgenes_tsne_new1", y = "allgenes_tsne_new2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons KM 17 Clusters All Genes tSNE")
```

We now cluster using a new set of top 500 HVGs specific for our subset.

```{r}
fit <- trendVar(sce, use.spikes = FALSE, loess.args = list(span = 0.05))

par(mfrow = c(1, 1), mar = c(5, 4, 2, 1), bty = "n")
plot(
  fit$mean, fit$var, pch = 20,
  col = rgb(0.1, 0.2, 0.7, 0.6), xlab = "log(Mean)", ylab = "Variance")
curve(fit$trend(x), col = "orange", lwd = 2, add = TRUE)
curve(new_trend(x), col = "red", lwd = 2, add = TRUE)
legend(
  "top", legend = c("Poisson Noise", "Observed Trend"), lty = 1,
  lwd = 2, col = c("red", "orange"), bty = "n")
```

We extract the genes with the largest biological components and plot them here.

```{r}
fit$trend <- new_trend
dec <- decomposeVar(fit = fit)
top_dec <- dec[order(dec$bio, decreasing = TRUE), ]
rm(fit)
plotExpression(sce, features = rownames(top_dec)[1:10])
```

For comparison, we also visualize the top 50 genes by total expression, not taking into account the components.

```{r}
plotHighestExprs(sce)
```

Finally, we select the top roughly 500 HVGs using their FDR and biological residual thresholds and visualize them below.

```{r}
dec1 <- dec
dec1$bio[which(dec$bio < 1e-5)] <- 1e-5
dec1$FDR[which(dec$FDR < 1e-100)] <- 1e-100
rm(top_dec)

# For some reason this does not give accurate results, though it did in another analysis.
# kable(table(dec$FDR < 1e-3, dec$bio > 0.0075), row.names = TRUE, padding = 0) %>%
#   kable_styling(bootstrap_options = "striped", font_size = 13, full_width = FALSE, position = "left")
par(mfrow = c(1, 2))
hist(log10(dec1$bio), breaks = 100, main = "")
hist(log10(dec1$FDR), breaks = 100, main = "")
```

And create a new SCE object containing the subsetted data.

```{r}
keep <- which(dec$FDR < 1e-7, dec$bio > 0.02)
length(keep) # Because the table function above is having trouble, we sanity check like this instead.
sce_hvg <- sce[keep, ]
edat <- t(as.matrix(logcounts(sce_hvg)))
edat <- scale(edat)
rm(dec, dec1)
sce_hvg
```

# References

This is the concluding section of the document.
Here we write relevant results to disk, output the `sessionInfo`, and create a bibliography for works cited.

```{r}
sessionInfo()
```
