---
title: "Tau Vulnerability Report"
author:
  - name: "Emir Turkes [et2628@cumc.columbia.edu]"
  - name: "Columbia University"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
bibliography: "../tau-vulnerability.bib"
biblio-style: apalike
link-citations: true
output:
  html_document:
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
knit:
  (function(inputFile, encoding) {
    rmarkdown::render(
      inputFile, encoding = encoding, output_file = "../results/tau-vulnerability-report.html")})
---

```{r, include = FALSE}
#    This file is part of tau-vulnerability.
#    Copyright (C) 2019  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

knitr::opts_chunk$set(fig.width = 8.5, fig.height = 7)
```

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
div.main-container {max-width: none; width: 100%;}
</style>

*This is an in-depth analysis to characterize differential vulnerability to tauopathy.*

The background for this data is as follows:

- snRNAseq data from @habib_massively_2017 cleaned and analyzed in [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq).

This analysis was performed in R except where noted.
The source code and instructions for rerunning the analysis can be found at [github.com/eturkes/tau-vulnerability](https://github.com/eturkes/tau-vulnerability).

# Final Results

**Read just this section for the final results of the analysis and a summary of the methods.**

# ~~~ Breakdown of Methods ~~~ {-}

**Sections from here to the end break down the methods used and are optional to read.**

We start by loading in any required packages and setting some global variables.

```{r}
packages <- c(
  "conflicted", "SingleCellExperiment", "magrittr", "dplyr", "ggplot2", "ggrepel", "S4Vectors",
  "SummarizedExperiment", "DropletUtils", "knitr", "kableExtra", "scran", "BiocSingular", "scater",
  "Rtsne", "svd", "SC3", "DT", "data.table")
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))

options(stringsAsFactors = FALSE)

assets_dir <- file.path(getwd(), "..", "assets")
results_dir <- file.path(getwd(), "..", "results")

# ggplot2 function providing custom aesthetics and automatic placement of categorical labels.
# For continuous data, a colorbar is implemented.
dim_red_plot <- function(data, x, y, col, type) {
  gg <- ggplot(data, aes_string(x = x, y = y, color = col)) +
    geom_point(alpha = 0.35, stroke = 0.05, shape = 21, aes_string(fill = col)) +
    theme_classic() +
    theme(
      legend.position = "right", plot.title = element_text(hjust = 0.5),
      legend.title = element_blank()) +
    guides(color = guide_legend(override.aes = list(alpha = 1)))
    if (type == "cat") {
      gg <- gg + geom_label_repel(data = label_df2, aes(label = label), show.legend = FALSE)
    } else if (type == "cont") {
      gg <- ggplot(data, aes_string(x = x, y = y)) +
        geom_point(alpha = 0.35, stroke = 0.05, aes_string(color = col)) +
        theme_classic() +
        theme(
          legend.position = "right", plot.title = element_text(hjust = 0.5),
          legend.title = element_blank()) +
        scale_colour_gradient(low = "blue", high = "red")}
  gg}

# From SC3 source, needed to look at more marker genes than the top 10.
organise_marker_genes <- function(object, k, p_val, auroc) {
  dat <- rowData(object)[ , c(
    paste0("sc3_", k, "_markers_clusts"), paste0("sc3_", k, "_markers_auroc"),
    paste0("sc3_", k, "_markers_padj"), "feature_symbol")]
  dat <- dat[dat[ , paste0("sc3_", k, "_markers_padj")] < p_val & !is.na(
    dat[, paste0("sc3_", k, "_markers_padj")]), ]
  dat <- dat[dat[ , paste0("sc3_", k, "_markers_auroc")] > auroc, ]
  d <- NULL
  for (i in sort(unique(dat[, paste0("sc3_", k, "_markers_clusts")]))) {
    tmp <- dat[dat[, paste0("sc3_", k, "_markers_clusts")] == i, ]
    tmp <- tmp[order(tmp[, paste0("sc3_", k, "_markers_auroc")], decreasing = TRUE), ]
    d <- rbind(d, tmp)}
  if (nrow(dat) > 0) {
    return(d)
  } else {
    return(NULL)}}

# Adds download buttons and exponential values.
datatable_custom <- function(dt) {
  datatable(
    dt,
    extensions = "Buttons", options = list(dom = "Blfrtip", buttons = list(
      "copy", "print",
      list(extend = "collection", buttons = c("csv", "excel", "pdf"), text = "Download")),
    rowCallback = JS(
      "function(row, data) {for (i = 1; i < data.length; i++) {if (data[i]>1000 | data[i]<1) {",
        "$('td:eq('+i+')', row).html(data[i].toExponential(2));",
      "}}}")))}
```

# Original Data

We start by reading in data from previous broad analyses and displaying their final results.

## Habib 2017 snRNAseq {.tabset}

The cleaned dataset here is derived from the analysis in [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq), which uses data from @habib_massively_2017.
For full details of preprocessing, please see that analysis, but in brief, standard QC for droplet-based UMI protocols was applied with attention to particular thresholds used in @habib_massively_2017.
The main results of the original publication is k-nearest-neighbor clustering visualized by tSNE, which identified 15 cell types within PFC and hippocampal tissues of five healthy human donors.
As cluster labels and tSNE coordinates were released by the authors, the main figure was recreated in the analysis, along with a successful attempt at replicating that data.

```{r}
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))

# Set up data frame for ggplot2.
gg_df <- data.frame(
  colData(sce)[ , c(
    paste0("habib_tsne", 1:2), paste0("hvg_tsne", 1:2), "habib_cluster_name", "km_17_clusters_name")])
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)

sce
```

### Habib Clusters Habib tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name), label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2",col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters Habib tSNE")
```

### New Clusters Habib tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2", col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("New Clusters Habib tSNE")
```

### Habib Clusters New tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name), label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters New tSNE")
```

### New Clusters New tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("New Clusters New tSNE")
```

# EX/IN Neurons of the PFC

We start by looking in the PFC region and exploring differences in excitatory and inhibitory neurons.
Tabs separate analyses for different datasets.

## Cleaning and QC {.tabset}

Though QC was already performed on the imported datasets, we perform another round for greater fidelity.

### Habib 2017 snRNAseq

#### Subsetting

We start by subsetting to our areas of interest using the k-means clusters from the previous analysis.

```{r}
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))

# Create a unique cache for each iterated section.
if (!dir.exists(file.path(assets_dir, "cache1"))) {
  dir.create(file.path(assets_dir, "cache1"))}

regions <- "PFC"
c_types <- "exPFC|GABA1|GABA2"
keep <- grepl(regions, colData(sce)$cell_id_stem)
sce <- sce[ , keep]
keep <- grepl(c_types, colData(sce)$km_17_clusters_name)
sce <- sce[ , keep]
dim(sce)
```

#### Low Quality Cells

In order to remove droplets which do not contain a cell but are rather ambient RNA, we visualize the inflection point on a knee plot, as described originally in @macosko_highly_2015.
Removal was then to be originally done using `emptyDrops` from the `DropletUtils` package, but due to an unresolved error (`no counts available to estimate the ambient profile`), we skip it.

```{r}
bc_rank <- barcodeRanks(counts(sce))
uniq <- !duplicated(bc_rank$rank)
par(mar = c(5, 4, 2, 1), bty = "n")
plot(
  bc_rank$rank[uniq], bc_rank$total[uniq], log = "xy", xlab = "Rank",
  ylab = "Total UMI Count", cex = 0.5, cex.lab = 1.2)
abline(h = metadata(bc_rank)$inflection, col = "darkgreen", lty = 2, lwd = 2)
abline(h = metadata(bc_rank)$knee, col = "dodgerblue", lty = 2, lwd = 2)
legend(
  "left", legend = c("Inflection", "Knee"), bty = "n", col = c("darkgreen", "dodgerblue"),
  lty = 2, cex = 1.2, lwd = 2)
```

```{r, cache = TRUE}
# Commented out due to "no counts available to estimate the ambient profile" error.
# rds <- file.path(assets_dir, "cache", "e_out.rds")
# if (file.exists(rds)) {
#   e_out <- readRDS(rds)
# } else {
#   set.seed(1)
#   e_out <- emptyDrops(counts(sce))
#   saveRDS(e_out, rds)}
```

#### Mito/Ribo Genes

Using an annotation from [HGNC](https://www.genenames.org/), we assess the proportion of mitochondrial/ribosomal genes within the cells.

```{r}
ribo_genes <- read.table(file.path(assets_dir, "ribo-genes.txt"), sep = "\t", header = TRUE)
is_mito <- which(rowData(sce)$chromosome_name == "MT")
is_ribo <- which(rowData(sce)$external_gene_name %in% ribo_genes$Approved.Symbol)
sce <- calculateQCMetrics(sce, feature_controls = list(Mt = is_mito, Ri = is_ribo))
par(mfrow = c(2, 2), mar = c(5, 4, 1, 1), bty = "n")
hist(
  log10(sce$total_counts), xlab = "log10(Library Sizes)", main = "",
  breaks = 20, col = "grey80", ylab = "Number of Cells")
hist(
  log10(sce$total_features_by_counts), xlab = "log10(Number of Expressed Genes)", main = "",
  breaks = 20, col = "grey80", ylab = "Number of Cells")
hist(
  sce$pct_counts_Ri, xlab = "Ribosomal Proportion Percentage", ylab = "Number of Cells",
  breaks = 40, main = "", col = "grey80")
hist(
  sce$pct_counts_Mt, xlab = "Mitochondrial Proportion Percentage", ylab = "Number of Cells",
  breaks = 80, main = "", col = "grey80")
par(mfrow = c(2, 2), mar = c(5, 4, 1, 1), bty = "n")
smoothScatter(
  log10(sce$total_counts), log10(sce$total_features_by_counts),
  xlab = "log10(Library Sizes)", ylab = "log10(Num. Expressed Genes)")
smoothScatter(
  log10(sce$total_counts), sce$pct_counts_Ri,
  xlab = "log10(Library Sizes)", ylab = "Ribosomal Proportion %")
smoothScatter(
  log10(sce$total_counts), sce$pct_counts_Mt,
  xlab = "log10(Library Sizes)", ylab = "Mitochondrial Proportion %")
smoothScatter(
  sce$pct_counts_Ri,sce$pct_counts_Mt, xlab = "Ribosomal Proportion %",
  ylab = "Mitochondrial Proportion %")
```

We then use the `isOutlier` function from `scater` to remove cells with an overabundance of mitochondrial/ribosomal gene expression, as these are likely to be damaged cells.
We also remove cells determined to be low quality by their library size and feature counts.
In the table below, "TRUE" indicates cells that are kept.

```{r}
libsize_drop <- isOutlier(sce$total_counts, nmads = 3, type = "lower", log = TRUE)
feature_drop <- isOutlier(sce$total_features_by_counts, nmads = 3, type = "lower", log = TRUE)
mito_drop <- isOutlier(sce$pct_counts_Mt, nmads = 3, type = "higher")
ribo_drop <- isOutlier(sce$pct_counts_Ri, nmads = 3, type = "higher")
keep <- !(libsize_drop | feature_drop | mito_drop | ribo_drop)
kable(table(colData(sce)$habib_cluster, keep), row.names = TRUE, padding = 0) %>%
  kable_styling(bootstrap_options = "striped", font_size = 13, full_width = FALSE, position = "left")
sce <- sce[ , keep]
dim(sce)
```

#### Lowly Expressed Genes

According to the original paper, nuclei that have less than 200 genes in one or more UMIs should be removed.
We start by first visualizing some gene-level summary statistics.

```{r}
par(mfrow = c(1, 3), mar = c(5, 4, 1, 1))
hist(
  log10(rowData(sce)$mean_counts + 1e-6), col = "grey80",  main = "",
  breaks = 40, xlab = "log10(Average Number of UMI + 1e-6)")
hist(
  log10(rowData(sce)$n_cells_by_counts + 1), col = "grey80", main = "",
  breaks = 40, xlab = "log10(Number of Expressed Cells + 1)")
plot(
  log10(rowData(sce)$mean_counts + 1e-6), pch = 16,
  col = rgb(0, 0, 0, 0.4), log10(rowData(sce)$n_cells_by_counts + 1),
  xlab = "log10(Average Number of UMI + 1e-6)", ylab = "log10(Number of Expressed Cells + 1)")
```

We remove genes as necessary and view the summary statistics again.

```{r}
names(rowData(sce))[names(rowData(sce)) == "strand"] <- "strand_n" # Must be renamed due to error.
n_genes <- colSums(counts(sce) >= 2)
n_genes <- colSums(counts(sce) >= 1)
n_cells <- rowSums(counts(sce) >= 2)
sce <- sce[which(n_cells >= 10), ]
dim(sce)
par(mfrow = c(1, 3), mar = c(5, 4, 1, 1))
hist(
  log10(rowData(sce)$mean_counts + 1e-6), col = "grey80",  main = "",
  breaks = 40, xlab = "log10(Average Number of UMI + 1e-6)")
hist(
  log10(rowData(sce)$n_cells_by_counts + 1), col = "grey80", main = "",
  breaks = 40, xlab = "log10(Number of Expressed Cells + 1)")
plot(
  log10(rowData(sce)$mean_counts + 1e-6), pch = 16,
  col = rgb(0, 0, 0, 0.4), log10(rowData(sce)$n_cells_by_counts + 1),
  xlab = "log10(Average Number of UMI + 1e-6)", ylab = "log10(Number of Expressed Cells + 1)")
```

#### Normalization

We use `computeSumFactors` from the `scran` package to perform normalization.
This function uses a linear deconvolution system to account for expected variation across different cell types/sizes [@l_lun_pooling_2016], producing "scale factor" values that indicates the extent to which a cell should be scaled.
For additional QC, we also remove cells that have size factors from the function that are very small ($< 0.01$) or negative.
In an experiment where most systematic differences between cells are driven by capture efficiency and sequencing depth, we should see a correlation between size factors and library size, so we visualize this.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "quickCluster.rds")
if (file.exists(rds)) {
  quickCluster <- readRDS(rds)
} else {
  quickCluster <- quickCluster(sce, use.ranks = FALSE, min.mean = 0.1, method = "igraph")
  saveRDS(quickCluster, rds)}
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "size_factors.rds")
if (file.exists(rds)) {
  size_factors <- readRDS(rds)
} else {
  size_factors <- computeSumFactors(sce, cluster = quickCluster, min.mean = 0.1)
  saveRDS(size_factors, rds)}
```

```{r}
sce <- size_factors
sce <- sce[ , which(sizeFactors(sce) > 0.01)]
par(mfrow = c(1, 2), mar = c(5, 4, 2, 1), bty = "n")
smoothScatter(
  sce$total_counts, sizeFactors(sce), log = "xy", xlab = "Total Counts", ylab = "Size Factors")
plot(
  sce$total_counts, sizeFactors(sce), log = "xy", xlab = "Total Counts",
  ylab = "Size Factors", cex = 0.3, pch = 20, col = rgb(0.1, 0.2, 0.7, 0.3))
abline(h = 0.05)
```

The plots are very well-correlated, which not only confirm the source of bias but also indicate that the previous QC steps were sufficient, therefore we go ahead and normalize the data.

```{r}
sce <- normalize(sce)
dim(sce)
```

## Dimensionality Reduction {.tabset}

This section details steps taken to reduce the dimensionality of the dataset.

### Habib 2017 snRNAseq

#### Habib tSNE Habib Clusters

We start by visualizing the tSNE coordinates provided in @habib_massively_2017 at this subset level.
Note that the subset was performed based on the k-means clusters from the previous analysis, so the clusters derived from @habib_massively_2017 will be expectedly more heterogeneous.

```{r}
# Set up data frame for ggplot2.
gg_df <- data.frame(
  colData(sce)[ , c(
    paste0("habib_tsne", 1:2), paste0("hvg_tsne", 1:2), "habib_cluster_name", "km_17_clusters_name")])
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name),
  label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2", col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons Habib Clusters Habib tSNE")
```

#### Whole Set HVG tSNE HVG k-means

Next we take a look at both the k-means clusters and HVG tSNEs created in the previous analysis.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons KM 17 Clusters Old HVG tSNE")
```

#### PCA

Now generating new data, we perform PCA using `denoisePCA` from the `scran` package, which automatically selects PCs by modeling technical noise.

```{r}
new_trend <- makeTechTrend(x = sce)
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "pca.rds")
if (file.exists(rds)) {
  pca <- readRDS(rds)
} else {
  pca <- denoisePCA(sce, technical = new_trend, BSPARAM = IrlbaParam())
  saveRDS(pca, rds)}
```

```{r}
sce <- pca
add_df <- data.frame(reducedDim(sce, "PCA"))
names(add_df) <- paste0("allgenes_sub_pc", seq(ncol(add_df)))
colData(sce) <- cbind(
  colData(sce), allgenes_sub_pc1 = add_df$allgenes_sub_pc1,
  allgenes_sub_pc2 = add_df$allgenes_sub_pc2)
gg_df <- data.frame(gg_df, add_df[1:2])
```

We use the first 50 PCs, with their ability to explain variance shown here.

```{r}
par(mfrow = c(1, 1))
plot(
  log10(attr(reducedDim(sce), "percentVar")), xlab = "PC",
  ylab = "log10(Proportion of Variance Explained)", pch = 20,
  cex = 0.6, col = rgb(0.8, 0.2, 0.2, 0.5))
abline(v = ncol(reducedDim(sce, "PCA")), lty = 2, col = "red")
```

We visualize only the first two components as they may have more descriptive power than usual for this smaller subset.
As expected, we see that PCA alone has decent power to separate EX/IN neurons.

```{r}
plotPCA(sce, colour_by = "km_17_clusters_name") +
  ggtitle("PFC EX/IN Neurons KM 17 Clusters PCA") + theme(legend.title = element_blank())
```

#### All Genes tSNE

Now we create new tSNEs for the subsetted region and samples, first using all genes in the dataset.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "runTSNE.rds")
if (file.exists(rds)) {
  runTSNE <- readRDS(rds)
} else {
  runTSNE <- runTSNE(sce, use_dimred = "PCA", perplexity = 30, rand_seed = 1)
  saveRDS(runTSNE, rds)}
```

```{r}
sce <- runTSNE
add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_sub_tsne", seq(ncol(add_df)))
colData(sce) <- cbind(
  colData(sce), allgenes_sub_tsne1 = add_df$allgenes_sub_tsne1,
  allgenes_sub_tsne2 = add_df$allgenes_sub_tsne2)
gg_df <- data.frame(gg_df, add_df)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(
    allgenes_sub_tsne1 = median(allgenes_sub_tsne1),
    allgenes_sub_tsne2 = median(allgenes_sub_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "allgenes_sub_tsne1", y = "allgenes_sub_tsne2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons KM 17 Clusters All Genes tSNE")
```

#### HVG

We now reduce dimensions using a new set of the top ~500 HVGs specific for our subset.
We start by plotting the variability of genes in our dataset against the expected Poisson technical noise.

```{r}
fit <- trendVar(sce, use.spikes = FALSE, loess.args = list(span = 0.05))
par(mfrow = c(1, 1), mar = c(5, 4, 2, 1), bty = "n")
plot(
  fit$mean, fit$var, pch = 20,
  col = rgb(0.1, 0.2, 0.7, 0.6), xlab = "log(Mean)", ylab = "Variance")
curve(fit$trend(x), col = "orange", lwd = 2, add = TRUE)
curve(new_trend(x), col = "red", lwd = 2, add = TRUE)
legend(
  "top", legend = c("Poisson Noise", "Observed Trend"), lty = 1,
  lwd = 2, col = c("red", "orange"), bty = "n")
```

We extract the genes with the largest biological components and plot them here.

```{r}
fit$trend <- new_trend
dec <- decomposeVar(fit = fit)
top_dec <- dec[order(dec$bio, decreasing = TRUE), ]
plotExpression(sce, features = rownames(top_dec)[1:10])
```

For comparison, we also visualize the top 50 genes by total expression, not taking into account the components.

```{r}
plotHighestExprs(sce)
```

Finally, we select the top roughly 500 HVGs using their FDR and biological residual thresholds and visualize them below.

```{r}
dec1 <- dec
dec1$bio[which(dec$bio < 1e-5)] <- 1e-5
dec1$FDR[which(dec$FDR < 1e-100)] <- 1e-100

kable(table(dec$FDR < 0.05, dec$bio > 0.015), row.names = TRUE, padding = 0) %>%
  kable_styling(bootstrap_options = "striped", font_size = 13, full_width = FALSE, position = "left")
par(mfrow = c(1, 2))
hist(log10(dec1$bio), breaks = 100, main = "")
hist(log10(dec1$FDR), breaks = 100, main = "")
```

And create a new SCE object containing the subsetted data.

```{r}
keep <- which(dec$FDR < 0.01 & dec$bio > 0.01)
length(keep) # Because the table function above is having trouble, we sanity check like this instead.
sce_hvg <- sce[keep, ]
edat <- t(as.matrix(logcounts(sce_hvg)))
edat <- scale(edat)
sce_hvg
```

#### HVG PCA

Now that we have a new `sce_hvg` object formed, we perform PCA on the log-transformed normalized expression data of the HVGs.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "ppk.rds")
if (file.exists(rds)) {
  ppk <- readRDS(rds)
} else {
  ppk <- propack.svd(edat, neig = 50)
  saveRDS(ppk, rds)}
```

```{r}
pca <- t(ppk$d*t(ppk$u))
reducedDims(sce_hvg) <- SimpleList(PCA = pca)
add_df <- data.frame(reducedDim(sce_hvg, "PCA"))
names(add_df) <- paste0("hvg_sub_pc", seq(ncol(add_df)))
colData(sce) <- cbind(
  colData(sce), hvg_sub_pc1 = add_df$hvg_sub_pc1, hvg_sub_pc2 = add_df$hvg_sub_pc2)
gg_df <- data.frame(gg_df, add_df[1:2])

plotPCA(sce_hvg, colour_by = "km_17_clusters_name")  +
  ggtitle("PFC EX/IN Neurons KM 17 Clusters HVG PCA") + theme(legend.title = element_blank())
```

#### HVG tSNE

We now take the PCs produced and generate a tSNE for `sce_hvg`.
As expected, when using HVGs, sub-structure within the data is better revealed.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "Rtsne.rds")
if (file.exists(rds)) {
  Rtsne <- readRDS(rds)
} else {
  set.seed(1)
  Rtsne <- Rtsne(pca, pca = FALSE, perplexity = 30)
  saveRDS(Rtsne, rds)}
```

```{r}
reducedDims(sce_hvg) <- SimpleList(PCA = pca, TSNE = Rtsne$Y)
add_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df) <- paste0("hvg_sub_tsne", seq(ncol(add_df)))
colData(sce) <- cbind(
  colData(sce), hvg_sub_tsne1 = add_df$hvg_sub_tsne1, hvg_sub_tsne2 = add_df$hvg_sub_tsne2)
gg_df <- data.frame(gg_df, add_df)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_sub_tsne1 = median(hvg_sub_tsne1), hvg_sub_tsne2 = median(hvg_sub_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_sub_tsne1", y = "hvg_sub_tsne2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons KM 17 Clusters HVG tSNE")
```

## Clustering {.tabset}

While the previous sections explored the components and visualizations of previously generated clusters, we create new ones here.

### Habib 2017 snRNAseq

#### SC3

Using SC3, we attempt both a deeper and broader clustering of the data, generating clusters in the range of 2-8.

```{r}
num_clust <- c(2:8)
rowData(sce_hvg)$feature_symbol <- rowData(sce_hvg)$external_gene_name
counts(sce_hvg) <- as.matrix(counts(sce_hvg))
logcounts(sce_hvg) <- as.matrix(logcounts(sce_hvg))
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "sce_hvg.rds")
if (file.exists(rds)) {
  sce_hvg <- readRDS(rds)
} else {
  sce_hvg <- sc3(sce_hvg, ks = num_clust, biology = TRUE)
  saveRDS(sce_hvg, rds)}
```

Next, we inspect our clusters alongside those that were created in the previous analysis.
As can be seen, they coincide well with our previously created clusters.

```{r}
for (i in num_clust) {
  sc3_label <- paste0("sc3_", i, "_clusters")
  gg_df[[sc3_label]] <- as.factor(colData(sce_hvg)[ , sc3_label])}

clusts <- c(paste0("sc3_", num_clust, "_clusters"), "km_17_clusters_name")
clusts_nice <- c(paste0("SC3 ", num_clust, " Clusters"), "KM 17 Clusters")

for (i in 1:length(clusts)) {
  if (i == length(clusts)) {
    print(dim_red_plot(
      data = gg_df, x = "hvg_sub_tsne1", y = "hvg_sub_tsne2", col = clusts[i], type = "cat") +
        xlab("tSNE 1") + ylab("tSNE 2") +
        ggtitle(paste("PFC EX/IN Neurons", clusts_nice[i], "HVG tSNE")))
  } else {
    print(dim_red_plot(
      data = gg_df, x = "hvg_sub_tsne1", y = "hvg_sub_tsne2", col = clusts[i], type = "other") +
        xlab("tSNE 1") + ylab("tSNE 2") +
        ggtitle(paste("PFC EX/IN Neurons", clusts_nice[i], "HVG tSNE")))}}
```

#### Labeling

Now we add labels to the set(s) we are interested.

**SC3 2 Clusters**

By looking at only two clusters, we reduce the complexity to address basic differences between excitatory and inhibitory cells.

```{r}
gg_df$sc3_2_clusters_name <- NA
sc3_2_clusters <- as.integer(gg_df$sc3_2_clusters)
for (i in 1:length(sc3_2_clusters)) {
  if (sc3_2_clusters[i] == 1) {
    gg_df[i, ncol(gg_df)] <- "GABA"
  } else if (sc3_2_clusters[i] == 2) {
    gg_df[i, ncol(gg_df)] <- "exPFC"}}

colData(sce_hvg) <- cbind(colData(sce_hvg), sc3_2_clusters_name = gg_df$sc3_2_clusters_name)
gg_df$sc3_2_clusters_name <- factor(gg_df$sc3_2_clusters_name)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  sc3_2_clusters_name = levels(gg_df$sc3_2_clusters_name),
  label = levels(gg_df$sc3_2_clusters_name))
label_df2 <- gg_df %>%
  group_by(sc3_2_clusters_name) %>%
  summarize(hvg_sub_tsne1 = median(hvg_sub_tsne1), hvg_sub_tsne2 = median(hvg_sub_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_sub_tsne1", y = "hvg_sub_tsne2",
  col = "sc3_2_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons SC3 2 Clusters HVG tSNE")
```

**SC3 3 Clusters**

SC3 3 Clusters mimics the clusters previously derived when generated 17 k-means clusters in the previous analysis.

```{r}
gg_df$sc3_3_clusters_name <- NA
sc3_3_clusters <- as.integer(gg_df$sc3_3_clusters)
for (i in 1:length(sc3_3_clusters)) {
  if (sc3_3_clusters[i] == 1) {
    gg_df[i, ncol(gg_df)] <- "exPFC"
  } else if (sc3_3_clusters[i] == 2) {
    gg_df[i, ncol(gg_df)] <- "GABA2"
  } else if (sc3_3_clusters[i] == 3) {
    gg_df[i, ncol(gg_df)] <- "GABA1"}}

colData(sce_hvg) <- cbind(colData(sce_hvg), sc3_3_clusters_name = gg_df$sc3_3_clusters_name)
gg_df$sc3_3_clusters_name <- factor(gg_df$sc3_3_clusters_name)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  sc3_3_clusters_name = levels(gg_df$sc3_3_clusters_name),
  label = levels(gg_df$sc3_3_clusters_name))
label_df2 <- gg_df %>%
  group_by(sc3_3_clusters_name) %>%
  summarize(hvg_sub_tsne1 = median(hvg_sub_tsne1), hvg_sub_tsne2 = median(hvg_sub_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_sub_tsne1", y = "hvg_sub_tsne2",
  col = "sc3_3_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons SC3 3 Clusters HVG tSNE")
```

**SC3 8 Clusters**

Finally, we look at the largest cluster set generated.

```{r}
gg_df$sc3_8_clusters_name <- NA
sc3_8_clusters <- as.integer(gg_df$sc3_8_clusters)
for (i in 1:length(sc3_8_clusters)) {
  if (sc3_8_clusters[i] == 1) {
    gg_df[i, ncol(gg_df)] <- "exPFC1"
  } else if (sc3_8_clusters[i] == 2) {
    gg_df[i, ncol(gg_df)] <- "GABA1"
  } else if (sc3_8_clusters[i] == 3) {
    gg_df[i, ncol(gg_df)] <- "exPFC2"
  } else if (sc3_8_clusters[i] == 4) {
    gg_df[i, ncol(gg_df)] <- "GABA2"
  } else if (sc3_8_clusters[i] == 5) {
    gg_df[i, ncol(gg_df)] <- "GABA5"
  } else if (sc3_8_clusters[i] == 6) {
    gg_df[i, ncol(gg_df)] <- "GABA4"
  } else if (sc3_8_clusters[i] == 7) {
    gg_df[i, ncol(gg_df)] <- "GABA3"
  } else if (sc3_8_clusters[i] == 8) {
    gg_df[i, ncol(gg_df)] <- "GABA6"}}

colData(sce_hvg) <- cbind(colData(sce_hvg), sc3_8_clusters_name = gg_df$sc3_8_clusters_name)
gg_df$sc3_8_clusters_name <- factor(gg_df$sc3_8_clusters_name)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  sc3_8_clusters_name = levels(gg_df$sc3_8_clusters_name),
  label = levels(gg_df$sc3_8_clusters_name))
label_df2 <- gg_df %>%
  group_by(sc3_8_clusters_name) %>%
  summarize(hvg_sub_tsne1 = median(hvg_sub_tsne1), hvg_sub_tsne2 = median(hvg_sub_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_sub_tsne1", y = "hvg_sub_tsne2",
  col = "sc3_8_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons SC3 8 Clusters HVG tSNE")
```

## Differential Expression {.tabset}

In this section, we calculate differentially expressed genes (DEGs) and identify marker genes for each cluster.
It should be noted that the top ~500 HVGs identified earlier are being used for this section, rather than the whole set of genes.

### Habib 2017 snRNAseq

```{r}
labeled_clusts <- c(2, 3, 8)
pdata <- c("sc3_2_clusters_name", "sc3_3_clusters_name", "sc3_8_clusters_name")
```

#### Expression Matrix

First, we plot an expression matrix to get an overview of the overall expression of each cluster.

```{r}
for (i in labeled_clusts) {
  print(sc3_plot_expression(sce_hvg, k = i, show_pdata = pdata))}
```

#### DEG

Next, we calculate DEGs using a non-parametric Kruskal-Wallis test.
The figure displays the top 50 DEGs where $p < 0.01$.

```{r, fig.height = 9}
for (i in labeled_clusts) {
  print(sc3_plot_de_genes(sce_hvg, k = i, show_pdata = pdata))}
```

#### Marker Genes

To assign marker genes, a binary classifier is constructed based on the mean cluster expression value.
Classifier prediction is then calculated using the gene expression ranks.
Genes with $AUROC > 0.1$ and $p < 0.01$ are selected and the top 10 are visualized in the following figure.

```{r, fig.height = 11.5}
for (i in labeled_clusts) {
  print(sc3_plot_markers(sce_hvg, k = i, auroc = 0.1, show_pdata = pdata))}
```

We can also view a data table containing all the marker genes.

```{r}
markers <- as.data.frame(organise_marker_genes(sce_hvg, k = 2, p_val = 0.01, auroc = 0.1))
markers$sc3_2_clusters_name <- NA
sc3_2_clusters <- as.integer(markers$sc3_2_markers_clusts)
for (i in 1:length(sc3_2_clusters)) {
  if (sc3_2_clusters[i] == 1) {
    markers[i, ncol(markers)] <- "GABA"
  } else if (sc3_2_clusters[i] == 2) {
    markers[i, ncol(markers)] <- "exPFC"}}
datatable_custom(as.data.table(markers))

markers <- as.data.frame(organise_marker_genes(sce_hvg, k = 3, p_val = 0.01, auroc = 0.1))
markers$sc3_3_clusters_name <- NA
sc3_3_clusters <- as.integer(markers$sc3_3_markers_clusts)
for (i in 1:length(sc3_3_clusters)) {
  if (sc3_3_clusters[i] == 1) {
    markers[i, ncol(markers)] <- "exPFC"
  } else if (sc3_3_clusters[i] == 2) {
    markers[i, ncol(markers)] <- "GABA2"
  } else if (sc3_3_clusters[i] == 3) {
    markers[i, ncol(markers)] <- "GABA1"}}
datatable_custom(as.data.table(markers))

markers <- as.data.frame(organise_marker_genes(sce_hvg, k = 8, p_val = 0.01, auroc = 0.1))
markers$sc3_8_clusters_name <- NA
sc3_8_clusters <- as.integer(markers$sc3_8_markers_clusts)
for (i in 1:length(sc3_8_clusters)) {
  if (sc3_8_clusters[i] == 1) {
    markers[i, ncol(markers)] <- "exPFC1"
  } else if (sc3_8_clusters[i] == 2) {
    markers[i, ncol(markers)] <- "GABA1"
  } else if (sc3_8_clusters[i] == 3) {
    markers[i, ncol(markers)] <- "exPFC2"
  } else if (sc3_8_clusters[i] == 4) {
    markers[i, ncol(markers)] <- "GABA2"
  } else if (sc3_8_clusters[i] == 5) {
    markers[i, ncol(markers)] <- "GABA5"
  } else if (sc3_8_clusters[i] == 6) {
    markers[i, ncol(markers)] <- "GABA4"
  } else if (sc3_8_clusters[i] == 7) {
    markers[i, ncol(markers)] <- "GABA3"
  } else if (sc3_8_clusters[i] == 8) {
    markers[i, ncol(markers)] <- "GABA6"}}
datatable_custom(as.data.table(markers))
```

## Pathway Analysis {.tabset}

We take marker genes or other interesting DEGs and perform pathway analysis to find enriched pathways.

**g:Profiler**

A useful tool for pathway analysis is g:Profiler [@raudvere_g:profiler:_2019], a web service that takes a list of genes and uses the hypergeometric test to find functionally enriched pathways from a number of databases.
While an official R client was trialed for this section, it was found to have various deficiencies, so we opt to use the web GUI, parameters of which are documented [here](https://biit.cs.ut.ee/gprofiler/page/docs).
Fortunately, reproducibility is granted through an auto-query feature, where a web URL is generated that leads to the original request.
These URLs are included here and are also useful for interactive exploration.

Two figures are provided in each subsection:

- A Manhattan plot which shows the relative enrichment of various data source terms.
By visiting the web app, one can click the circles and generate a table comparing the terms between the two gene lists.
- A table breaking down data source terms, their p-values, and genes determined to be associated with each term.

### Habib 2017 snRNAseq

#### SC3 2 Clusters

The parameters used, with the input being the marker genes for each cluster:

```
version = e95_eg42_p13_f6e58b9
organism = hsapiens
all results = false
ordered = true
no iea = true
sources = GO:MF, GO:CC, GO:BP, KEGG, REAC
combined = false # true in Manhattan plot.
numeric ns = ENTREZGENE_ACC
domain scope = annotated
measure underrepresentation = false
significance threshold method = g_SCS
user threshold = 0.05
no evidences = false
```

**Between All Clusters**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/iZHsBbijSa)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-2c/manhattan.png)

![](../assets/gprofiler/PFC-EXIN-habib-sc3-2c/multiquery.png)

**exPFC**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/SgjGMMQkT4)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-2c/exPFC.png)

**GABA**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/a--ISwfkRC)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-2c/GABA.png)

#### SC3 3 Clusters

The parameters used, with the input being the marker genes for each cluster:

```
version = e95_eg42_p13_f6e58b9
organism = hsapiens
all results = false
ordered = true
no iea = true
sources = GO:MF, GO:CC, GO:BP, KEGG, REAC
combined = false # true in Manhattan plot.
numeric ns = ENTREZGENE_ACC
domain scope = annotated
measure underrepresentation = false
significance threshold method = g_SCS
user threshold = 0.05
no evidences = false
```

**Between All Clusters**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/9OO_1JYaR-)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-3c/manhattan.png)

![](../assets/gprofiler/PFC-EXIN-habib-sc3-3c/multiquery.png)

**exPFC**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/AvBc51mhSt)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-3c/exPFC.png)

**GABA1**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/BzPZz33_Sh)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-3c/GABA1.png)

**GABA2**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/PTmyATRFSr)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-3c/GABA2.png)

## Expression of Specific Genes

We look at a set of genes of interest to see if their expression levels are represented by some clusters over others.

```{r}
genes <- c(
  "PVALB", "CALB1", "CALB2", "SST", "GRIA1", "GRIA2", "GRIA3",
  "GRIA4", "SATB1", "SATB2", "WFS1", "TBR1", "GAD1", "GAD2")
colData(sce) <- cbind(
  colData(sce), sc3_3_clusters_name = sce_hvg$sc3_3_clusters_name,
  sc3_8_clusters_name = sce_hvg$sc3_8_clusters_name)
```

### Habib 2017 snRNAseq

#### SC3 3 Clusters

```{r}
for (i in genes) {
  print(plotExpression(sce, i, x = "sc3_3_clusters_name", colour_by = "sc3_3_clusters_name")) +
    theme(legend.title = element_blank())}
```

#### SC3 8 Clusters

```{r}
for (i in genes) {
  print(plotExpression(sce, i, x = "sc3_8_clusters_name", colour_by = "sc3_8_clusters_name")) +
    theme(legend.title = element_blank())}
```

# References

This is the concluding section of the document.
Here we write relevant results to disk, output the `sessionInfo`, and create a bibliography for works cited.

```{r}
sessionInfo()
```
