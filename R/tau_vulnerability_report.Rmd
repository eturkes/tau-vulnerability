---
title: "Tau Vulnerability Report"
author:
  - name: "Emir Turkes [et2628@cumc.columbia.edu]"
  - name: "Columbia University"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
bibliography: "../tau-vulnerability.bib"
biblio-style: apalike
link-citations: true
output:
  html_document:
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
knit:
  (function(inputFile, encoding) {
    rmarkdown::render(
      inputFile, encoding = encoding, output_file = "../results/tau-vulnerability-report.html")})
---

```{r, include = FALSE}
#    This file is part of tau-vulnerability.
#    Copyright (C) 2019  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

knitr::opts_chunk$set(fig.width = 8.5, fig.height = 7)
```

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
div.main-container {max-width: none; width: 100%;}
</style>

*This is an in-depth analysis to characterize differential vulnerability to tauopathy.*

The background for this data is as follows:

- snRNAseq data from @habib_massively_2017 cleaned and analyzed in [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq).

This analysis was performed in R except where noted.
The source code and instructions for rerunning the analysis can be found at [github.com/eturkes/tau-vulnerability](https://github.com/eturkes/tau-vulnerability).

# Final Results

**Read just this section for the final results of the analysis and a summary of the methods.**

# ~~~ Breakdown of Methods ~~~ {-}

**Sections from here to the end break down the methods used and are optional to read.**

We start by loading in any required packages and setting some global variables.

```{r}
packages <- c(
  "conflicted", "SingleCellExperiment", "magrittr", "dplyr", "ggplot2", "ggrepel", "scran",
  "BiocSingular", "scater", "Rtsne", "svd", "SC3", "DT", "data.table")
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))

options(stringsAsFactors = FALSE)

assets_dir <- file.path(getwd(), "..", "assets")
results_dir <- file.path(getwd(), "..", "results")

# ggplot2 function providing custom aesthetics and automatic placement of categorical labels.
# For continuous data, a colorbar is implemented.
dim_red_plot <- function(data, x, y, col, type) {
  gg <- ggplot(data, aes_string(x = x, y = y, color = col)) +
    geom_point(alpha = 0.35, stroke = 0.05, shape = 21, aes_string(fill = col)) +
    theme_classic() +
    theme(
      legend.position = "right", plot.title = element_text(hjust = 0.5),
      legend.title = element_blank()) +
    guides(color = guide_legend(override.aes = list(alpha = 1)))
    if (type == "cat") {
      gg <- gg + geom_label_repel(data = label_df2, aes(label = label), show.legend = FALSE)
    } else if (type == "cont") {
      gg <- ggplot(data, aes_string(x = x, y = y)) +
        geom_point(alpha = 0.35, stroke = 0.05, aes_string(color = col)) +
        theme_classic() +
        theme(
          legend.position = "right", plot.title = element_text(hjust = 0.5),
          legend.title = element_blank()) +
        scale_colour_gradient(low = "blue", high = "red")}
  gg}

# From SC3 source, needed to look at more marker genes than the top 10.
organise_marker_genes <- function(object, k, p_val, auroc) {
  dat <- rowData(object)[ , c(
    paste0("sc3_", k, "_markers_clusts"), paste0("sc3_", k, "_markers_auroc"),
    paste0("sc3_", k, "_markers_padj"), "feature_symbol")]
  dat <- dat[dat[ , paste0("sc3_", k, "_markers_padj")] < p_val & !is.na(
    dat[, paste0("sc3_", k, "_markers_padj")]), ]
  dat <- dat[dat[ , paste0("sc3_", k, "_markers_auroc")] > auroc, ]
  d <- NULL
  for (i in sort(unique(dat[, paste0("sc3_", k, "_markers_clusts")]))) {
    tmp <- dat[dat[, paste0("sc3_", k, "_markers_clusts")] == i, ]
    tmp <- tmp[order(tmp[, paste0("sc3_", k, "_markers_auroc")], decreasing = TRUE), ]
    d <- rbind(d, tmp)}
  if (nrow(dat) > 0) {
    return(d)
  } else {
    return(NULL)}}

# Adds download buttons and exponential values.
datatable_custom <- function(dt) {
  datatable(
    dt,
    extensions = "Buttons", options = list(dom = "Blfrtip", buttons = list(
      "copy", "print",
      list(extend = "collection", buttons = c("csv", "excel", "pdf"), text = "Download")),
    rowCallback = JS(
      "function(row, data) {for (i = 1; i < data.length; i++) {if (data[i]>1000 | data[i]<1) {",
        "$('td:eq('+i+')', row).html(data[i].toExponential(2));",
      "}}}")))}
```

# Original Data

We start by reading in data from previous broad analyses and displaying their final results.

## Habib 2017 snRNAseq {.tabset}

The cleaned dataset here is derived from the analysis in [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq), which uses data from @habib_massively_2017.
For full details of preprocessing, please see that analysis, but in brief, standard QC for droplet-based UMI protocols was applied with attention to particular thresholds used in @habib_massively_2017.
The main results of the original publication is k-nearest-neighbor clustering visualized by tSNE, which identified 15 cell types within PFC and hippocampal tissues of five healthy human donors.
As cluster labels and tSNE coordinates were released by the authors, the main figure was recreated in the analysis, along with a successful attempt at replicating that data.

```{r}
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))
sce_hvg <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce_hvg.rds"))

# Set up data frame for ggplot2.
add_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df) <- paste0("hvg_tsne", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce_hvg)[ , c(
    "sample", "cell_id_stem", paste0("habib_tsne", 1:2), "log10_total_features_by_counts",
    "habib_cluster", "habib_cluster_name", "km_17_clusters_name")],
  add_df)
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)
```

```{r}
sce
sce_hvg
```

### Habib Clusters Habib tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name), label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2",col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters Habib tSNE")
```

### New Clusters Habib tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2", col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("New Clusters Habib tSNE")
```

### Habib Clusters New tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name), label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("Habib Clusters New tSNE")
```

### New Clusters New tSNE

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("New Clusters New tSNE")
```

# EX/IN Neurons of the PFC

We start by looking in the PFC region and exploring differences in excitatory and inhibitory neurons.
Tabs separate analyses for different datasets.

## Preliminary Cleaning {.tabset}

Subsetting and any other necessary cleaning take place at this stage.

### Habib 2017 snRNAseq

```{r}
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))
sce_hvg <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce_hvg.rds"))

# Create a unique cache for each iterated section.
if (!dir.exists(file.path(assets_dir, "cache1"))) {
  dir.create(file.path(assets_dir, "cache1"))}

regions <- "PFC"
c_types_habib <- "exPFC1|exPFC2|GABA1|GABA2"
c_types_km <- "exPFC|GABA1|GABA2"

keep <- grepl(regions, colData(sce)$cell_id_stem)
sce <- sce[ , keep]
keep <- grepl(c_types_habib, colData(sce)$habib_cluster_name)
sce <- sce[ , keep]

keep <- grepl(regions, colData(sce_hvg)$cell_id_stem)
sce_hvg <- sce_hvg[ , keep]
keep <- grepl(c_types_km, colData(sce_hvg)$km_17_clusters_name)
sce_hvg <- sce_hvg[ , keep]

# Set up data frame for ggplot2.
add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_tsne", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce)[ , c(
    "sample", "cell_id_stem", paste0("habib_tsne", 1:2),
    "log10_total_features_by_counts", "habib_cluster", "habib_cluster_name")],
  add_df)
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)

# Set up data frame for ggplot2.
add_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df) <- paste0("hvg_tsne", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce_hvg)[ , c(
    "sample", "cell_id_stem", paste0("habib_tsne", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  add_df)
rownames(gg_df) <- NULL
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)
```

```{r}
dim(sce)
dim(sce_hvg)
```

## Dimensionality Reduction {.tabset}

This section details steps taken to reduce the dimensionality of the dataset.

### Habib 2017 snRNAseq

#### Habib tSNE Habib Clusters

We start by visualizing the tSNE coordinates provided in @habib_massively_2017 at this subset level.
It should be noted that these coordinates may not optimal as they were generated while analyzing the entire set.
Another thing to note is that they were created using HVGs (highly variable genes) rather than the entire list of genes in the dataset.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name),
  label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2", col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons Habib Clusters Habib tSNE")
```

#### Whole Set HVG tSNE HVG k-means

Next we take a look at the k-means clusters in the original broad analysis at [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq).
We view them on the HVG tSNEs created in the same previous analysis.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons KM 17 Clusters Old HVG tSNE")
```

#### Consolidation of Data

From here, we apply techniques on the subset data itself, which may be more informative than dimensionality reduction that was performed on the entire dataset.
To simply the analysis, we select one of the two clustering/tSNE schemes, choosing the k-means/HVG tSNE combination as it has been clustered into three rather than four clusters, which will facilitate more straightforward three-way analyses.
This requires moving some data around to consolidate it into one SCE object.

```{r}
# Both SCE objects must be subset the same way for this to work.
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))
sce_hvg <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce_hvg.rds"))
keep <- grepl(regions, colData(sce_hvg)$cell_id_stem)
sce <- sce[ , keep]
sce_hvg <- sce_hvg[ , keep]
keep <- grepl(c_types_km, colData(sce_hvg)$km_17_clusters_name)
sce <- sce[ , keep]
sce_hvg <- sce_hvg[ , keep]

allgenes_pca_orig <- reducedDim(sce, "PCA")
hvg_pca_orig <- reducedDim(sce_hvg, "PCA")

add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_tsne_orig", seq(ncol(add_df)))
add_df2 <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df2) <- paste0("hvg_tsne_orig", seq(ncol(add_df)))

colData(sce) <- cbind(
  colData(sce), km_17_clusters = sce_hvg$km_17_clusters,
  km_17_clusters_name = sce_hvg$km_17_clusters_name, allgenes_tsne_orig1 = add_df[1],
  allgenes_tsne_orig2 = add_df[2], hvg_tsne_orig1 = add_df2[1],
  hvg_tsne_orig2 = add_df2[2])

rm(add_df2)
sce
```

#### PCA

Now that our data is consolidated, we perform PCA using `denoisePCA` from the `scran` package, which automatically selects PCs by modeling technical noise.

```{r}
new_trend <- makeTechTrend(x = sce)
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "pca.rds")
if (file.exists(rds)) {
  pca <- readRDS(rds)
} else {
  pca <- denoisePCA(sce, technical = new_trend, BSPARAM = IrlbaParam())
  saveRDS(pca, rds)}
```

```{r}
# Set up data frame for ggplot2.
sce <- pca
add_df <- data.frame(reducedDim(sce, "PCA"))
names(add_df) <- paste0("allgenes_pc_new", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce)[ , c(
    "sample", "cell_id_stem", paste0("allgenes_tsne_orig", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  add_df[1:2])
rownames(gg_df) <- NULL
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)
rm(pca)
```

We use the first 50 PCs, with their ability to explain variance shown here.

```{r}
par(mfrow = c(1, 1))
plot(
  log10(attr(reducedDim(sce), "percentVar")), xlab = "PC",
  ylab = "log10(Proportion of Variance Explained)", pch = 20,
  cex = 0.6, col = rgb(0.8, 0.2, 0.2, 0.5))
abline(v = ncol(reducedDim(sce, "PCA")), lty = 2, col = "red")
```

We visualize only the first two components as they may have more descriptive power than usual for this smaller subset. As expected, we see that PCA alone has decent power to separate EX/IN neurons.

```{r}
plotPCA(sce, colour_by = "km_17_clusters_name") +
  ggtitle("PFC EX/IN Neurons KM 17 Clusters PCA") + theme(legend.title = element_blank())
```

#### All Genes tSNE

Now we create new tSNEs for the subsetted region and samples, first using all genes in the dataset.
After tweaking the perplexity within a range of 10-100, we settle upon a conservative value of 30 to represent the structure of the data.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "runTSNE.rds")
if (file.exists(rds)) {
  runTSNE <- readRDS(rds)
} else {
  runTSNE <- runTSNE(sce, use_dimred = "PCA", perplexity = 30, rand_seed = 1)
  saveRDS(runTSNE, rds)}
```

```{r}
sce <- runTSNE
add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_tsne_new", seq(ncol(add_df)))
gg_df <- data.frame(gg_df, add_df)
rm(runTSNE)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(
    allgenes_tsne_new1 = median(allgenes_tsne_new1),
    allgenes_tsne_new2 = median(allgenes_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "allgenes_tsne_new1", y = "allgenes_tsne_new2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons KM 17 Clusters All Genes tSNE")
```

#### HVG

We now reduce dimensions using a new set of top ~1,000 HVGs specific for our subset.
We start by plotting the variability of genes in our dataset against the expected Poisson technical noise.

```{r}
fit <- trendVar(sce, use.spikes = FALSE, loess.args = list(span = 0.05))
par(mfrow = c(1, 1), mar = c(5, 4, 2, 1), bty = "n")
plot(
  fit$mean, fit$var, pch = 20,
  col = rgb(0.1, 0.2, 0.7, 0.6), xlab = "log(Mean)", ylab = "Variance")
curve(fit$trend(x), col = "orange", lwd = 2, add = TRUE)
curve(new_trend(x), col = "red", lwd = 2, add = TRUE)
legend(
  "top", legend = c("Poisson Noise", "Observed Trend"), lty = 1,
  lwd = 2, col = c("red", "orange"), bty = "n")
```

We extract the genes with the largest biological components and plot them here.

```{r}
fit$trend <- new_trend
dec <- decomposeVar(fit = fit)
top_dec <- dec[order(dec$bio, decreasing = TRUE), ]
rm(fit)
plotExpression(sce, features = rownames(top_dec)[1:10])
```

For comparison, we also visualize the top 50 genes by total expression, not taking into account the components.

```{r}
plotHighestExprs(sce)
```

Finally, we select the top roughly 1,000 HVGs using their FDR and biological residual thresholds and visualize them below.

```{r}
dec1 <- dec
dec1$bio[which(dec$bio < 1e-5)] <- 1e-5
dec1$FDR[which(dec$FDR < 1e-100)] <- 1e-100
rm(top_dec)

# For some reason this does not give accurate results, though it did in another analysis.
# kable(table(dec$FDR < 1e-3, dec$bio > 0.0075), row.names = TRUE, padding = 0) %>%
#   kable_styling(bootstrap_options = "striped", font_size = 13, full_width = FALSE, position = "left")
par(mfrow = c(1, 2))
hist(log10(dec1$bio), breaks = 100, main = "")
hist(log10(dec1$FDR), breaks = 100, main = "")
```

And create a new SCE object containing the subsetted data.

```{r}
keep <- which(dec$FDR < 1e-4, dec$bio > 0.005)
length(keep) # Because the table function above is having trouble, we sanity check like this instead.
sce_hvg <- sce[keep, ]
edat <- t(as.matrix(logcounts(sce_hvg)))
edat <- scale(edat)
rm(dec, dec1)
sce_hvg
```

#### HVG PCA

Now that we have a new `sce_hvg` object formed, we perform PCA on the log-transformed normalized expression data of the HVGs.
We see that this time, PCA could not separate the cell types well.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "ppk.rds")
if (file.exists(rds)) {
  ppk <- readRDS(rds)
} else {
  ppk <- propack.svd(edat, neig = 50)
  saveRDS(ppk, rds)}
```

```{r}
# Set up data frame for ggplot2.
pca <- t(ppk$d*t(ppk$u))
reducedDims(sce_hvg) <- SimpleList(PCA = pca)
add_df <- data.frame(reducedDim(sce_hvg, "PCA"))
names(add_df) <- paste0("hvg_pc_new", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce_hvg)[ , c(
    "sample", "cell_id_stem", paste0("hvg_tsne_orig", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  add_df[1:2])
rownames(gg_df) <- NULL
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)
rm(edat)

plotPCA(sce_hvg, colour_by = "km_17_clusters_name")  +
  ggtitle("PFC EX/IN Neurons KM 17 Clusters HVG PCA") + theme(legend.title = element_blank())
```

#### HVG tSNE

We now take the PCs produced and generate a tSNE for `sce_hvg`, using the same perplexity value of 30 as before.
In this case, subclusters within the GABA clusters start to become apparent.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "Rtsne.rds")
if (file.exists(rds)) {
  Rtsne <- readRDS(rds)
} else {
  set.seed(1)
  Rtsne <- Rtsne(pca, pca = FALSE, perplexity = 30)
  saveRDS(Rtsne, rds)}
```

```{r}
reducedDims(sce_hvg) <- SimpleList(PCA = pca, TSNE = Rtsne$Y)
add_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df) <- paste0("hvg_tsne_new", seq(ncol(add_df)))
gg_df <- data.frame(gg_df, add_df)
rm(Rtsne, pca, add_df)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne_new1 = median(hvg_tsne_new1), hvg_tsne_new2 = median(hvg_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons KM 17 Clusters HVG tSNE")
```

## Clustering {.tabset}

While the previous sections explored the components and visualizations of previously generated clusters, we create new ones here.

### Habib 2017 snRNAseq

#### SC3

Using SC3, we attempt both a deeper and broader clustering of the data, generating clusters in the range of 2-8.

```{r}
num_clust <- c(2:8)
rowData(sce_hvg)$feature_symbol <- rowData(sce_hvg)$external_gene_name
counts(sce_hvg) <- as.matrix(counts(sce_hvg))
logcounts(sce_hvg) <- as.matrix(logcounts(sce_hvg))
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache1", "sce_hvg.rds")
if (file.exists(rds)) {
  sce_hvg <- readRDS(rds)
} else {
  sce_hvg <- sc3(sce_hvg, ks = num_clust, biology = TRUE)
  saveRDS(sce_hvg, rds)}
```

Next, we inspect our clusters alongside those that were created in the previous analysis.
As can be seen, they coincide well with our previously created clusters.

```{r}
for (i in num_clust) {
  sc3_label <- paste0("sc3_", i, "_clusters")
  gg_df[[sc3_label]] <- as.factor(colData(sce_hvg)[ , sc3_label])}

clusts <- c(paste0("sc3_", num_clust, "_clusters"), "km_17_clusters_name")
clusts_nice <- c(paste0("SC3 ", num_clust, " Clusters"), "KM 17 Clusters")

for (i in 1:length(clusts)) {
  if (i == length(clusts)) {
    print(dim_red_plot(
      data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2", col = clusts[i], type = "cat") +
        xlab("tSNE 1") + ylab("tSNE 2") +
        ggtitle(paste("PFC EX/IN Neurons", clusts_nice[i], "HVG tSNE")))
  } else {
    print(dim_red_plot(
      data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2", col = clusts[i], type = "other") +
        xlab("tSNE 1") + ylab("tSNE 2") +
        ggtitle(paste("PFC EX/IN Neurons", clusts_nice[i], "HVG tSNE")))}}
```

#### Labeling

Now we add labels to the set(s) we are interested.

**SC3 2 Clusters**

By looking at only two clusters, we reduce the complication, though additional insight, from subclusters.

```{r}
gg_df$sc3_2_clusters_name <- NA
sc3_2_clusters <- as.integer(gg_df$sc3_2_clusters)
for (i in 1:length(sc3_2_clusters)) {
  if (sc3_2_clusters[i] == 1) {
    gg_df[i, ncol(gg_df)] <- "GABA"
  } else if (sc3_2_clusters[i] == 2) {
    gg_df[i, ncol(gg_df)] <- "exPFC"}}

colData(sce_hvg) <- cbind(colData(sce_hvg), sc3_2_clusters_name = gg_df$sc3_2_clusters_name)
gg_df$sc3_2_clusters_name <- factor(gg_df$sc3_2_clusters_name)
```

And we visualize the labeled SC3 2 Clusters.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  sc3_2_clusters_name = levels(gg_df$sc3_2_clusters_name),
  label = levels(gg_df$sc3_2_clusters_name))
label_df2 <- gg_df %>%
  group_by(sc3_2_clusters_name) %>%
  summarize(hvg_tsne_new1 = median(hvg_tsne_new1), hvg_tsne_new2 = median(hvg_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2",
  col = "sc3_2_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons SC3 2 Clusters HVG tSNE")
```

**SC3 3 Clusters**

SC3 3 Clusters is particularly interesting because it can be used to conduct a three-way analysis.

```{r}
gg_df$sc3_3_clusters_name <- NA
sc3_3_clusters <- as.integer(gg_df$sc3_3_clusters)
for (i in 1:length(sc3_3_clusters)) {
  if (sc3_3_clusters[i] == 1) {
    gg_df[i, ncol(gg_df)] <- "exPFC"
  } else if (sc3_3_clusters[i] == 2) {
    gg_df[i, ncol(gg_df)] <- "GABA2"
  } else if (sc3_3_clusters[i] == 3) {
    gg_df[i, ncol(gg_df)] <- "GABA1"}}

colData(sce_hvg) <- cbind(colData(sce_hvg), sc3_3_clusters_name = gg_df$sc3_3_clusters_name)
gg_df$sc3_3_clusters_name <- factor(gg_df$sc3_3_clusters_name)
```

And we visualize the labeled SC3 3 Clusters.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  sc3_3_clusters_name = levels(gg_df$sc3_3_clusters_name),
  label = levels(gg_df$sc3_3_clusters_name))
label_df2 <- gg_df %>%
  group_by(sc3_3_clusters_name) %>%
  summarize(hvg_tsne_new1 = median(hvg_tsne_new1), hvg_tsne_new2 = median(hvg_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2",
  col = "sc3_3_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons SC3 3 Clusters HVG tSNE")
```

**SC3 8 Clusters**

We label the largest cluster set generated.

```{r}
gg_df$sc3_8_clusters_name <- NA
sc3_8_clusters <- as.integer(gg_df$sc3_8_clusters)
for (i in 1:length(sc3_8_clusters)) {
  if (sc3_8_clusters[i] == 1) {
    gg_df[i, ncol(gg_df)] <- "exPFC1"
  } else if (sc3_8_clusters[i] == 2) {
    gg_df[i, ncol(gg_df)] <- "GABA1"
  } else if (sc3_8_clusters[i] == 3) {
    gg_df[i, ncol(gg_df)] <- "exPFC2"
  } else if (sc3_8_clusters[i] == 4) {
    gg_df[i, ncol(gg_df)] <- "GABA2"
  } else if (sc3_8_clusters[i] == 5) {
    gg_df[i, ncol(gg_df)] <- "GABA5"
  } else if (sc3_8_clusters[i] == 6) {
    gg_df[i, ncol(gg_df)] <- "GABA4"
  } else if (sc3_8_clusters[i] == 7) {
    gg_df[i, ncol(gg_df)] <- "GABA3"
  } else if (sc3_8_clusters[i] == 8) {
    gg_df[i, ncol(gg_df)] <- "GABA6"}}

colData(sce_hvg) <- cbind(colData(sce_hvg), sc3_8_clusters_name = gg_df$sc3_8_clusters_name)
gg_df$sc3_8_clusters_name <- factor(gg_df$sc3_8_clusters_name)
```

And we visualize the labeled SC3 8 Clusters.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  sc3_8_clusters_name = levels(gg_df$sc3_8_clusters_name),
  label = levels(gg_df$sc3_8_clusters_name))
label_df2 <- gg_df %>%
  group_by(sc3_8_clusters_name) %>%
  summarize(hvg_tsne_new1 = median(hvg_tsne_new1), hvg_tsne_new2 = median(hvg_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2",
  col = "sc3_8_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX/IN Neurons SC3 8 Clusters HVG tSNE")
```

## Differential Expression {.tabset}

In this section, we calculate differentially expressed genes (DEGs) and identify marker genes for each cluster.
It should be noted that the top ~1,000 HVGs identified earlier are being used, rather than the whole set of genes.

### Habib 2017 snRNAseq

```{r}
labeled_clusts <- c(2, 3, 8)
pdata <- c("sc3_2_clusters_name", "sc3_3_clusters_name", "sc3_8_clusters_name")
```

#### Expression Matrix

First, we plot an expression matrix to get an overview of the overall expression of each cluster.

```{r}
for (i in labeled_clusts) {
  print(sc3_plot_expression(sce_hvg, k = i, show_pdata = pdata))}
```

#### DEG

Next, we calculate DEGs using a non-parametric Kruskal-Wallis test.
The figure displays the top 50 DEGs where $p < 0.01$.

```{r, fig.height = 9}
for (i in labeled_clusts) {
  print(sc3_plot_de_genes(sce_hvg, k = i, show_pdata = pdata))}
```

#### Marker Genes

To assign marker genes, a binary classifier is constructed based on the mean cluster expression value.
Classifier prediction is then calculated using the gene expression ranks.
Genes with $AUROC > 0.1$ and $p < 0.01$ are selected and the top 10 are visualized in the following figure.
Note that $AUROC > 0.85$ is the default, but this threshold only revealed a single marker gene: DLX6-AS1 in the GABA2 cluster.

```{r, fig.height = 11.5}
for (i in labeled_clusts) {
  print(sc3_plot_markers(sce_hvg, k = i, auroc = 0.1, show_pdata = pdata))}
```

We can also view a data table containing all the marker genes.

```{r}
markers <- as.data.frame(organise_marker_genes(sce_hvg, k = 2, p_val = 0.01, auroc = 0.1))
markers$sc3_2_clusters_name <- NA
sc3_2_clusters <- as.integer(markers$sc3_2_markers_clusts)
for (i in 1:length(sc3_2_clusters)) {
  if (sc3_2_clusters[i] == 1) {
    markers[i, ncol(markers)] <- "GABA"
  } else if (sc3_2_clusters[i] == 2) {
    markers[i, ncol(markers)] <- "exPFC"}}
datatable_custom(as.data.table(markers))

markers <- as.data.frame(organise_marker_genes(sce_hvg, k = 3, p_val = 0.01, auroc = 0.1))
markers$sc3_3_clusters_name <- NA
sc3_3_clusters <- as.integer(markers$sc3_3_markers_clusts)
for (i in 1:length(sc3_3_clusters)) {
  if (sc3_3_clusters[i] == 1) {
    markers[i, ncol(markers)] <- "exPFC"
  } else if (sc3_3_clusters[i] == 2) {
    markers[i, ncol(markers)] <- "GABA2"
  } else if (sc3_3_clusters[i] == 3) {
    markers[i, ncol(markers)] <- "GABA1"}}
datatable_custom(as.data.table(markers))

markers <- as.data.frame(organise_marker_genes(sce_hvg, k = 8, p_val = 0.01, auroc = 0.1))
markers$sc3_8_clusters_name <- NA
sc3_8_clusters <- as.integer(markers$sc3_8_markers_clusts)
for (i in 1:length(sc3_8_clusters)) {
  if (sc3_8_clusters[i] == 1) {
    markers[i, ncol(markers)] <- "exPFC1"
  } else if (sc3_8_clusters[i] == 2) {
    markers[i, ncol(markers)] <- "GABA1"
  } else if (sc3_8_clusters[i] == 3) {
    markers[i, ncol(markers)] <- "exPFC2"
  } else if (sc3_8_clusters[i] == 4) {
    markers[i, ncol(markers)] <- "GABA2"
  } else if (sc3_8_clusters[i] == 5) {
    markers[i, ncol(markers)] <- "GABA5"
  } else if (sc3_8_clusters[i] == 6) {
    markers[i, ncol(markers)] <- "GABA4"
  } else if (sc3_8_clusters[i] == 7) {
    markers[i, ncol(markers)] <- "GABA3"
  } else if (sc3_8_clusters[i] == 8) {
    markers[i, ncol(markers)] <- "GABA6"}}
datatable_custom(as.data.table(markers))
```

## Pathway Analysis {.tabset}

We take marker genes or other interesting DEGs and perform pathway analysis to find enriched pathways.

**g:Profiler**

A useful tool for pathway analysis is g:Profiler [@raudvere_g:profiler:_2019], a web service that takes a list of genes and uses the hypergeometric test to find functionally enriched pathways from a number of databases.
While an official R client was trialed for this section, it was found to have various deficiencies, so we opt to use the web GUI, parameters of which are documented [here](https://biit.cs.ut.ee/gprofiler/page/docs).
Fortunately, reproducibility is granted through an auto-query feature, where a web URL is generated that leads to the original request.
These URLs are included here and are also useful for interactive exploration.

Two figures are provided in each subsection:

- A Manhattan plot which shows the relative enrichment of various data source terms.
By visiting the web app, one can click the circles and generate a table comparing the terms between the two gene lists.
- A table breaking down data source terms, their p-values, and genes determined to be associated with each term.

### Habib 2017 snRNAseq

#### SC3 2 Clusters

Below are the parameters used, with the inputs being the marker genes for each cluster.

```
version = e95_eg42_p13_f6e58b9
organism = hsapiens
all results = false
ordered = true
no iea = true
sources = GO:MF, GO:CC, GO:BP, KEGG, REAC
combined = false # true in Manhattan plot.
numeric ns = ENTREZGENE_ACC
domain scope = annotated
measure underrepresentation = false
significance threshold method = g_SCS
user threshold = 0.05
no evidences = false
```

**Between All Clusters**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/iZHsBbijSa)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-2c/manhattan.png)

![](../assets/gprofiler/PFC-EXIN-habib-sc3-2c/multiquery.png)

**exPFC**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/SgjGMMQkT4)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-2c/exPFC.png)

**GABA**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/a--ISwfkRC)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-2c/GABA.png)

#### SC3 3 Clusters

Below are the parameters used, with the inputs being the marker genes for each cluster.

```
version = e95_eg42_p13_f6e58b9
organism = hsapiens
all results = false
ordered = true
no iea = true
sources = GO:MF, GO:CC, GO:BP, KEGG, REAC
combined = false # true in Manhattan plot.
numeric ns = ENTREZGENE_ACC
domain scope = annotated
measure underrepresentation = false
significance threshold method = g_SCS
user threshold = 0.05
no evidences = false
```

**Between All Clusters**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/9OO_1JYaR-)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-3c/manhattan.png)

![](../assets/gprofiler/PFC-EXIN-habib-sc3-3c/multiquery.png)

**exPFC**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/AvBc51mhSt)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-3c/exPFC.png)

**GABA1**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/BzPZz33_Sh)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-3c/GABA1.png)

**GABA2**

*[Link to Query](https://biit.cs.ut.ee/gplink/l/PTmyATRFSr)*

![](../assets/gprofiler/PFC-EXIN-habib-sc3-3c/GABA2.png)

## Expression of Specific Genes

We look at a set of genes relevant to tauopathy to see if their expression levels are represented by some clusters over others.

```{r}
genes <- c(
  "PVALB", "CALB1", "CALB2", "SST", "GRIA1", "GRIA2", "GRIA3",
  "GRIA4", "SATB1", "SATB2", "WFS1", "TBR1", "GAD1", "GAD2")
# TODO: Add these earlier, along with with reducedDims.
colData(sce) <- cbind(
  colData(sce), sc3_3_clusters_name = sce_hvg$sc3_3_clusters_name,
  sc3_8_clusters_name = sce_hvg$sc3_8_clusters_name)
```

### Habib 2017 snRNAseq

#### SC3 3 Clusters

```{r}
for (i in genes) {
  print(plotExpression(sce, i, x = "sc3_3_clusters_name", colour_by = "sc3_3_clusters_name")) +
    theme(legend.title = element_blank())}
```

#### SC3 8 Clusters

```{r}
for (i in genes) {
  print(plotExpression(sce, i, x = "sc3_8_clusters_name", colour_by = "sc3_8_clusters_name")) +
    theme(legend.title = element_blank())}
```

# IN Neurons of the PFC

We continue to look in the PFC region, this time further breaking down the inhibitory neurons.
Tabs separate analyses for different datasets.

## Preliminary Cleaning {.tabset}

Subsetting and any other necessary cleaning take place at this stage.

### Habib 2017 snRNAseq

```{r}
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))
sce_hvg <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce_hvg.rds"))

# Create a unique cache for each iterated section.
if (!dir.exists(file.path(assets_dir, "cache2"))) {
  dir.create(file.path(assets_dir, "cache2"))}

regions <- "PFC"
c_types_habib <- "GABA1|GABA2"
c_types_km <- "GABA1|GABA2"

keep <- grepl(regions, colData(sce)$cell_id_stem)
sce <- sce[ , keep]
keep <- grepl(c_types_habib, colData(sce)$habib_cluster_name)
sce <- sce[ , keep]

keep <- grepl(regions, colData(sce_hvg)$cell_id_stem)
sce_hvg <- sce_hvg[ , keep]
keep <- grepl(c_types_km, colData(sce_hvg)$km_17_clusters_name)
sce_hvg <- sce_hvg[ , keep]

# Set up data frame for ggplot2.
add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_tsne", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce)[ , c(
    "sample", "cell_id_stem", paste0("habib_tsne", 1:2),
    "log10_total_features_by_counts", "habib_cluster", "habib_cluster_name")],
  add_df)
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)

# Set up data frame for ggplot2.
add_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df) <- paste0("hvg_tsne", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce_hvg)[ , c(
    "sample", "cell_id_stem", paste0("habib_tsne", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  add_df)
rownames(gg_df) <- NULL
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)
```

```{r}
dim(sce)
dim(sce_hvg)
```

## Dimensionality Reduction {.tabset}

This section details steps taken to reduce the dimensionality of the dataset.

### Habib 2017 snRNAseq

#### Habib tSNE Habib Clusters

We start by visualizing the tSNE coordinates provided in @habib_massively_2017 at this subset level.
It should be noted that these coordinates may not optimal as they were generated while analyzing the entire set.
Another thing to note is that they were created using HVGs (highly variable genes) rather than the entire list of genes in the dataset.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name),
  label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2", col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC IN Neurons Habib Clusters Habib tSNE")
```

#### Whole Set HVG tSNE HVG k-means

Next we take a look at the k-means clusters in the original broad analysis at [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq).
We view them on the HVG tSNEs created in the same previous analysis.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC IN Neurons KM 17 Clusters Old HVG tSNE")
```

#### Consolidation of Data

From here, we apply techniques on the subset data itself, which may be more informative than dimensionality reduction that was performed on the entire dataset.
To simply the analysis, we select one of the two clustering/tSNE schemes, choosing the k-means/HVG tSNE combination as it has been clustered into three rather than four clusters, which will facilitate more straightforward three-way analyses.
This requires moving some data around to consolidate it into one SCE object.

```{r}
# Both SCE objects must be subset the same way for this to work.
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))
sce_hvg <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce_hvg.rds"))
keep <- grepl(regions, colData(sce_hvg)$cell_id_stem)
sce <- sce[ , keep]
sce_hvg <- sce_hvg[ , keep]
keep <- grepl(c_types_km, colData(sce_hvg)$km_17_clusters_name)
sce <- sce[ , keep]
sce_hvg <- sce_hvg[ , keep]

allgenes_pca_orig <- reducedDim(sce, "PCA")
hvg_pca_orig <- reducedDim(sce_hvg, "PCA")

add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_tsne_orig", seq(ncol(add_df)))
add_df2 <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df2) <- paste0("hvg_tsne_orig", seq(ncol(add_df)))

colData(sce) <- cbind(
  colData(sce), km_17_clusters = sce_hvg$km_17_clusters,
  km_17_clusters_name = sce_hvg$km_17_clusters_name, allgenes_tsne_orig1 = add_df[1],
  allgenes_tsne_orig2 = add_df[2], hvg_tsne_orig1 = add_df2[1],
  hvg_tsne_orig2 = add_df2[2])

rm(add_df2)
sce
```

#### PCA

Now that our data is consolidated, we perform PCA using `denoisePCA` from the `scran` package, which automatically selects PCs by modeling technical noise.

```{r}
new_trend <- makeTechTrend(x = sce)
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache2", "pca.rds")
if (file.exists(rds)) {
  pca <- readRDS(rds)
} else {
  pca <- denoisePCA(sce, technical = new_trend, BSPARAM = IrlbaParam())
  saveRDS(pca, rds)}
```

```{r}
# Set up data frame for ggplot2.
sce <- pca
add_df <- data.frame(reducedDim(sce, "PCA"))
names(add_df) <- paste0("allgenes_pc_new", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce)[ , c(
    "sample", "cell_id_stem", paste0("allgenes_tsne_orig", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  add_df[1:2])
rownames(gg_df) <- NULL
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)
rm(pca)
```

We use the first 50 PCs, with their ability to explain variance shown here.

```{r}
par(mfrow = c(1, 1))
plot(
  log10(attr(reducedDim(sce), "percentVar")), xlab = "PC",
  ylab = "log10(Proportion of Variance Explained)", pch = 20,
  cex = 0.6, col = rgb(0.8, 0.2, 0.2, 0.5))
abline(v = ncol(reducedDim(sce, "PCA")), lty = 2, col = "red")
```

We visualize only the first two components as they may have more descriptive power than usual for this smaller subset. They appear to separate the two inhibitory clusters rather well.

```{r}
plotPCA(sce, colour_by = "km_17_clusters_name") +
  ggtitle("PFC IN Neurons KM 17 Clusters PCA") + theme(legend.title = element_blank())
```

#### All Genes tSNE

Now we create new tSNEs for the subsetted region and samples, first using all genes in the dataset.
After tweaking the perplexity within a range of 10-100, we settle upon a conservative value of 30 to represent the structure of the data.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache2", "runTSNE.rds")
if (file.exists(rds)) {
  runTSNE <- readRDS(rds)
} else {
  runTSNE <- runTSNE(sce, use_dimred = "PCA", perplexity = 30, rand_seed = 1)
  saveRDS(runTSNE, rds)}
```

```{r}
sce <- runTSNE
add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_tsne_new", seq(ncol(add_df)))
gg_df <- data.frame(gg_df, add_df)
rm(runTSNE)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(
    allgenes_tsne_new1 = median(allgenes_tsne_new1),
    allgenes_tsne_new2 = median(allgenes_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "allgenes_tsne_new1", y = "allgenes_tsne_new2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC IN Neurons KM 17 Clusters All Genes tSNE")
```

#### HVG

We now reduce dimensions using a new set of top ~1,000 HVGs specific for our subset.
We start by plotting the variability of genes in our dataset against the expected Poisson technical noise.

```{r}
fit <- trendVar(sce, use.spikes = FALSE, loess.args = list(span = 0.05))
par(mfrow = c(1, 1), mar = c(5, 4, 2, 1), bty = "n")
plot(
  fit$mean, fit$var, pch = 20,
  col = rgb(0.1, 0.2, 0.7, 0.6), xlab = "log(Mean)", ylab = "Variance")
curve(fit$trend(x), col = "orange", lwd = 2, add = TRUE)
curve(new_trend(x), col = "red", lwd = 2, add = TRUE)
legend(
  "top", legend = c("Poisson Noise", "Observed Trend"), lty = 1,
  lwd = 2, col = c("red", "orange"), bty = "n")
```

We extract the genes with the largest biological components and plot them here.

```{r}
fit$trend <- new_trend
dec <- decomposeVar(fit = fit)
top_dec <- dec[order(dec$bio, decreasing = TRUE), ]
rm(fit)
plotExpression(sce, features = rownames(top_dec)[1:10])
```

For comparison, we also visualize the top 50 genes by total expression, not taking into account the components.

```{r}
plotHighestExprs(sce)
```

Finally, we select the top roughly 500 HVGs using their FDR and biological residual thresholds and visualize them below.

```{r}
dec1 <- dec
dec1$bio[which(dec$bio < 1e-5)] <- 1e-5
dec1$FDR[which(dec$FDR < 1e-100)] <- 1e-100
rm(top_dec)

# For some reason this does not give accurate results, though it did in another analysis.
# kable(table(dec$FDR < 1e-3, dec$bio > 0.0075), row.names = TRUE, padding = 0) %>%
#   kable_styling(bootstrap_options = "striped", font_size = 13, full_width = FALSE, position = "left")
par(mfrow = c(1, 2))
hist(log10(dec1$bio), breaks = 100, main = "")
hist(log10(dec1$FDR), breaks = 100, main = "")
```

And create a new SCE object containing the subsetted data.

```{r}
keep <- which(dec$FDR < 1e-4, dec$bio > 0.005)
length(keep) # Because the table function above is having trouble, we sanity check like this instead.
sce_hvg <- sce[keep, ]
edat <- t(as.matrix(logcounts(sce_hvg)))
edat <- scale(edat)
rm(dec, dec1)
sce_hvg
```

#### HVG PCA

Now that we have a new `sce_hvg` object formed, we perform PCA on the log-transformed normalized expression data of the HVGs.
We see that this time, PCA could not separate the cell types well.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache2", "ppk.rds")
if (file.exists(rds)) {
  ppk <- readRDS(rds)
} else {
  ppk <- propack.svd(edat, neig = 50)
  saveRDS(ppk, rds)}
```

```{r}
# Set up data frame for ggplot2.
pca <- t(ppk$d*t(ppk$u))
reducedDims(sce_hvg) <- SimpleList(PCA = pca)
add_df <- data.frame(reducedDim(sce_hvg, "PCA"))
names(add_df) <- paste0("hvg_pc_new", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce_hvg)[ , c(
    "sample", "cell_id_stem", paste0("hvg_tsne_orig", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  add_df[1:2])
rownames(gg_df) <- NULL
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)
rm(edat)

plotPCA(sce_hvg, colour_by = "km_17_clusters_name")  +
  ggtitle("PFC IN Neurons KM 17 Clusters HVG PCA") + theme(legend.title = element_blank())
```

#### HVG tSNE

We now take the PCs produced and generate a tSNE for `sce_hvg`, using the same perplexity value of 30 as before.
In this case, subclusters within the GABA clusters start to become apparent.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache2", "Rtsne.rds")
if (file.exists(rds)) {
  Rtsne <- readRDS(rds)
} else {
  set.seed(1)
  Rtsne <- Rtsne(pca, pca = FALSE, perplexity = 30)
  saveRDS(Rtsne, rds)}
```

```{r}
reducedDims(sce_hvg) <- SimpleList(PCA = pca, TSNE = Rtsne$Y)
add_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df) <- paste0("hvg_tsne_new", seq(ncol(add_df)))
gg_df <- data.frame(gg_df, add_df)
rm(Rtsne, pca, add_df)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne_new1 = median(hvg_tsne_new1), hvg_tsne_new2 = median(hvg_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC IN Neurons KM 17 Clusters HVG tSNE")
```

## Clustering {.tabset}

While the previous sections explored the components and visualizations of previously generated clusters, we create new ones here.

### Habib 2017 snRNAseq

#### SC3

Using SC3, we attempt to both replicate clusters and generate deeper ones, generating clusters in the range of 2-8.

```{r}
num_clust <- c(2:8)
rowData(sce_hvg)$feature_symbol <- rowData(sce_hvg)$external_gene_name
counts(sce_hvg) <- as.matrix(counts(sce_hvg))
logcounts(sce_hvg) <- as.matrix(logcounts(sce_hvg))
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache2", "sce_hvg.rds")
if (file.exists(rds)) {
  sce_hvg <- readRDS(rds)
} else {
  sce_hvg <- sc3(sce_hvg, ks = num_clust, biology = TRUE)
  saveRDS(sce_hvg, rds)}
```

Next, we inspect our clusters alongside those that were created in the previous analysis.
As can be seen, they coincide well with our previously created clusters.

```{r}
for (i in num_clust) {
  sc3_label <- paste0("sc3_", i, "_clusters")
  gg_df[[sc3_label]] <- as.factor(colData(sce_hvg)[ , sc3_label])}

clusts <- c(paste0("sc3_", num_clust, "_clusters"), "km_17_clusters_name")
clusts_nice <- c(paste0("SC3 ", num_clust, " Clusters"), "KM 17 Clusters")

for (i in 1:length(clusts)) {
  if (i == length(clusts)) {
    print(dim_red_plot(
      data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2", col = clusts[i], type = "cat") +
        xlab("tSNE 1") + ylab("tSNE 2") +
        ggtitle(paste("PFC IN Neurons", clusts_nice[i], "HVG tSNE")))
  } else {
    print(dim_red_plot(
      data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2", col = clusts[i], type = "other") +
        xlab("tSNE 1") + ylab("tSNE 2") +
        ggtitle(paste("PFC IN Neurons", clusts_nice[i], "HVG tSNE")))}}
```

#### Labeling

Now we add labels to the set(s) we are interested.

**SC3 2 Clusters**

By looking at only two clusters, we reduce the complication, though additional insight, from subclusters.

```{r}
gg_df$sc3_2_clusters_name <- NA
sc3_2_clusters <- as.integer(gg_df$sc3_2_clusters)
for (i in 1:length(sc3_2_clusters)) {
  if (sc3_2_clusters[i] == 1) {
    gg_df[i, ncol(gg_df)] <- "GABA2"
  } else if (sc3_2_clusters[i] == 2) {
    gg_df[i, ncol(gg_df)] <- "GABA1"}}

colData(sce_hvg) <- cbind(colData(sce_hvg), sc3_2_clusters_name = gg_df$sc3_2_clusters_name)
gg_df$sc3_2_clusters_name <- factor(gg_df$sc3_2_clusters_name)
```

And we visualize the labeled SC3 2 Clusters.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  sc3_2_clusters_name = levels(gg_df$sc3_2_clusters_name),
  label = levels(gg_df$sc3_2_clusters_name))
label_df2 <- gg_df %>%
  group_by(sc3_2_clusters_name) %>%
  summarize(hvg_tsne_new1 = median(hvg_tsne_new1), hvg_tsne_new2 = median(hvg_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2",
  col = "sc3_2_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC IN Neurons SC3 2 Clusters HVG tSNE")
```

## Differential Expression {.tabset}

In this section, we calculate differentially expressed genes (DEGs) and identify marker genes for each cluster.
It should be noted that the top ~1,000 HVGs identified earlier are being used, rather than the whole set of genes.

### Habib 2017 snRNAseq

```{r}
labeled_clusts <- c(2)
pdata <- c("sc3_2_clusters_name")
```

#### Expression Matrix

First, we plot an expression matrix to get an overview of the overall expression of each cluster.

```{r}
for (i in labeled_clusts) {
  print(sc3_plot_expression(sce_hvg, k = i, show_pdata = pdata))}
```

#### DEG

Next, we calculate DEGs using a non-parametric Kruskal-Wallis test.
The figure displays the top 50 DEGs where $p < 0.01$.

```{r, fig.height = 9}
for (i in labeled_clusts) {
  print(sc3_plot_de_genes(sce_hvg, k = i, show_pdata = pdata))}
```

#### Marker Genes

To assign marker genes, a binary classifier is constructed based on the mean cluster expression value.
Classifier prediction is then calculated using the gene expression ranks.
Genes with $AUROC > 0.1$ and $p < 0.01$ are selected and the top 10 are visualized in the following figure.
Note that $AUROC > 0.85$ is the default, but this threshold only revealed a single marker gene: DLX6-AS1 in the GABA2 cluster.

```{r, fig.height = 5.5}
for (i in labeled_clusts) {
  print(sc3_plot_markers(sce_hvg, k = i, auroc = 0.1, show_pdata = pdata))}
```

We can also view a data table containing all the marker genes.

```{r}
markers <- as.data.frame(organise_marker_genes(sce_hvg, k = 2, p_val = 0.01, auroc = 0.1))
markers$sc3_2_clusters_name <- NA
sc3_2_clusters <- as.integer(markers$sc3_2_markers_clusts)
for (i in 1:length(sc3_2_clusters)) {
  if (sc3_2_clusters[i] == 1) {
    markers[i, ncol(markers)] <- "GABA2"
  } else if (sc3_2_clusters[i] == 2) {
    markers[i, ncol(markers)] <- "GABA1"}}
datatable_custom(as.data.table(markers))
```

# EX Neurons of the PFC

We continue to look in the PFC region, this time further breaking down the excitatory neurons.
Tabs separate analyses for different datasets.

## Preliminary Cleaning {.tabset}

Subsetting and any other necessary cleaning take place at this stage.

### Habib 2017 snRNAseq

```{r}
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))
sce_hvg <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce_hvg.rds"))

# Create a unique cache for each iterated section.
if (!dir.exists(file.path(assets_dir, "cache3"))) {
  dir.create(file.path(assets_dir, "cache3"))}

regions <- "PFC"
c_types_habib <- "exPFC1|exPFC2"
c_types_km <- "exPFC"

keep <- grepl(regions, colData(sce)$cell_id_stem)
sce <- sce[ , keep]
keep <- grepl(c_types_habib, colData(sce)$habib_cluster_name)
sce <- sce[ , keep]

keep <- grepl(regions, colData(sce_hvg)$cell_id_stem)
sce_hvg <- sce_hvg[ , keep]
keep <- grepl(c_types_km, colData(sce_hvg)$km_17_clusters_name)
sce_hvg <- sce_hvg[ , keep]

# Set up data frame for ggplot2.
add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_tsne", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce)[ , c(
    "sample", "cell_id_stem", paste0("habib_tsne", 1:2),
    "log10_total_features_by_counts", "habib_cluster", "habib_cluster_name")],
  add_df)
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)

# Set up data frame for ggplot2.
add_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df) <- paste0("hvg_tsne", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce_hvg)[ , c(
    "sample", "cell_id_stem", paste0("habib_tsne", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  add_df)
rownames(gg_df) <- NULL
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)
```

```{r}
dim(sce)
dim(sce_hvg)
```

## Dimensionality Reduction {.tabset}

This section details steps taken to reduce the dimensionality of the dataset.

### Habib 2017 snRNAseq

#### Habib tSNE Habib Clusters

We start by visualizing the tSNE coordinates provided in @habib_massively_2017 at this subset level.
It should be noted that these coordinates may not optimal as they were generated while analyzing the entire set.
Another thing to note is that they were created using HVGs (highly variable genes) rather than the entire list of genes in the dataset.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  habib_cluster_name = levels(gg_df$habib_cluster_name),
  label = levels(gg_df$habib_cluster_name))
label_df2 <- gg_df %>%
  group_by(habib_cluster_name) %>%
  summarize(habib_tsne1 = median(habib_tsne1), habib_tsne2 = median(habib_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "habib_tsne1", y = "habib_tsne2", col = "habib_cluster_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX Neurons Habib Clusters Habib tSNE")
```

#### Whole Set HVG tSNE HVG k-means

Next we take a look at the k-means clusters in the original broad analysis at [github.com/eturkes/habib-2017-snRNAseq](https://github.com/eturkes/habib-2017-snRNAseq).
We view them on the HVG tSNEs created in the same previous analysis.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne1 = median(hvg_tsne1), hvg_tsne2 = median(hvg_tsne2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne1", y = "hvg_tsne2", col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX Neurons KM 17 Clusters Old HVG tSNE")
```

#### Consolidation of Data

From here, we apply techniques on the subset data itself, which may be more informative than dimensionality reduction that was performed on the entire dataset.
To simply the analysis, we select one of the two clustering/tSNE schemes, choosing the k-means/HVG tSNE combination as it has been clustered into three rather than four clusters, which will facilitate more straightforward three-way analyses.
This requires moving some data around to consolidate it into one SCE object.

```{r}
# Both SCE objects must be subset the same way for this to work.
sce <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce.rds"))
sce_hvg <- readRDS(file.path(assets_dir, "habib-2017-snRNAseq", "sce_hvg.rds"))
keep <- grepl(regions, colData(sce_hvg)$cell_id_stem)
sce <- sce[ , keep]
sce_hvg <- sce_hvg[ , keep]
keep <- grepl(c_types_km, colData(sce_hvg)$km_17_clusters_name)
sce <- sce[ , keep]
sce_hvg <- sce_hvg[ , keep]

allgenes_pca_orig <- reducedDim(sce, "PCA")
hvg_pca_orig <- reducedDim(sce_hvg, "PCA")

add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_tsne_orig", seq(ncol(add_df)))
add_df2 <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df2) <- paste0("hvg_tsne_orig", seq(ncol(add_df)))

colData(sce) <- cbind(
  colData(sce), km_17_clusters = sce_hvg$km_17_clusters,
  km_17_clusters_name = sce_hvg$km_17_clusters_name, allgenes_tsne_orig1 = add_df[1],
  allgenes_tsne_orig2 = add_df[2], hvg_tsne_orig1 = add_df2[1],
  hvg_tsne_orig2 = add_df2[2])

rm(add_df2)
sce
```

#### PCA

Now that our data is consolidated, we perform PCA using `denoisePCA` from the `scran` package, which automatically selects PCs by modeling technical noise.

```{r}
new_trend <- makeTechTrend(x = sce)
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache3", "pca.rds")
if (file.exists(rds)) {
  pca <- readRDS(rds)
} else {
  pca <- denoisePCA(sce, technical = new_trend, BSPARAM = IrlbaParam())
  saveRDS(pca, rds)}
```

```{r}
# Set up data frame for ggplot2.
sce <- pca
add_df <- data.frame(reducedDim(sce, "PCA"))
names(add_df) <- paste0("allgenes_pc_new", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce)[ , c(
    "sample", "cell_id_stem", paste0("allgenes_tsne_orig", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  add_df[1:2])
rownames(gg_df) <- NULL
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)
rm(pca)
```

We use the first 50 PCs, with their ability to explain variance shown here.

```{r}
par(mfrow = c(1, 1))
plot(
  log10(attr(reducedDim(sce), "percentVar")), xlab = "PC",
  ylab = "log10(Proportion of Variance Explained)", pch = 20,
  cex = 0.6, col = rgb(0.8, 0.2, 0.2, 0.5))
abline(v = ncol(reducedDim(sce, "PCA")), lty = 2, col = "red")
```

We visualize only the first two components as they may have more descriptive power than usual for this smaller subset. They appear to separate the two inhibitory clusters rather well.

```{r}
plotPCA(sce, colour_by = "km_17_clusters_name") +
  ggtitle("PFC EX Neurons KM 17 Clusters PCA") + theme(legend.title = element_blank())
```

#### All Genes tSNE

Now we create new tSNEs for the subsetted region and samples, first using all genes in the dataset.
After tweaking the perplexity within a range of 10-100, we settle upon a conservative value of 30 to represent the structure of the data.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache3", "runTSNE.rds")
if (file.exists(rds)) {
  runTSNE <- readRDS(rds)
} else {
  runTSNE <- runTSNE(sce, use_dimred = "PCA", perplexity = 30, rand_seed = 1)
  saveRDS(runTSNE, rds)}
```

```{r}
sce <- runTSNE
add_df <- data.frame(reducedDim(sce, "TSNE"))
names(add_df) <- paste0("allgenes_tsne_new", seq(ncol(add_df)))
gg_df <- data.frame(gg_df, add_df)
rm(runTSNE)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(
    allgenes_tsne_new1 = median(allgenes_tsne_new1),
    allgenes_tsne_new2 = median(allgenes_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "allgenes_tsne_new1", y = "allgenes_tsne_new2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX Neurons KM 17 Clusters All Genes tSNE")
```

#### HVG

We now reduce dimensions using a new set of top ~1,000 HVGs specific for our subset.
We start by plotting the variability of genes in our dataset against the expected Poisson technical noise.

```{r}
fit <- trendVar(sce, use.spikes = FALSE, loess.args = list(span = 0.05))
par(mfrow = c(1, 1), mar = c(5, 4, 2, 1), bty = "n")
plot(
  fit$mean, fit$var, pch = 20,
  col = rgb(0.1, 0.2, 0.7, 0.6), xlab = "log(Mean)", ylab = "Variance")
curve(fit$trend(x), col = "orange", lwd = 2, add = TRUE)
curve(new_trend(x), col = "red", lwd = 2, add = TRUE)
legend(
  "top", legend = c("Poisson Noise", "Observed Trend"), lty = 1,
  lwd = 2, col = c("red", "orange"), bty = "n")
```

We extract the genes with the largest biological components and plot them here.

```{r}
fit$trend <- new_trend
dec <- decomposeVar(fit = fit)
top_dec <- dec[order(dec$bio, decreasing = TRUE), ]
rm(fit)
plotExpression(sce, features = rownames(top_dec)[1:10])
```

For comparison, we also visualize the top 50 genes by total expression, not taking into account the components.

```{r}
plotHighestExprs(sce)
```

Finally, we select the top roughly 500 HVGs using their FDR and biological residual thresholds and visualize them below.

```{r}
dec1 <- dec
dec1$bio[which(dec$bio < 1e-5)] <- 1e-5
dec1$FDR[which(dec$FDR < 1e-100)] <- 1e-100
rm(top_dec)

# For some reason this does not give accurate results, though it did in another analysis.
# kable(table(dec$FDR < 1e-3, dec$bio > 0.0075), row.names = TRUE, padding = 0) %>%
#   kable_styling(bootstrap_options = "striped", font_size = 13, full_width = FALSE, position = "left")
par(mfrow = c(1, 2))
hist(log10(dec1$bio), breaks = 100, main = "")
hist(log10(dec1$FDR), breaks = 100, main = "")
```

And create a new SCE object containing the subsetted data.

```{r}
keep <- which(dec$FDR < 1e-4, dec$bio > 0.005)
length(keep) # Because the table function above is having trouble, we sanity check like this instead.
sce_hvg <- sce[keep, ]
edat <- t(as.matrix(logcounts(sce_hvg)))
edat <- scale(edat)
rm(dec, dec1)
sce_hvg
```

#### HVG PCA

Now that we have a new `sce_hvg` object formed, we perform PCA on the log-transformed normalized expression data of the HVGs.
We see that this time, PCA could not separate the cell types well.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache3", "ppk.rds")
if (file.exists(rds)) {
  ppk <- readRDS(rds)
} else {
  ppk <- propack.svd(edat, neig = 50)
  saveRDS(ppk, rds)}
```

```{r}
# Set up data frame for ggplot2.
pca <- t(ppk$d*t(ppk$u))
reducedDims(sce_hvg) <- SimpleList(PCA = pca)
add_df <- data.frame(reducedDim(sce_hvg, "PCA"))
names(add_df) <- paste0("hvg_pc_new", seq(ncol(add_df)))
gg_df <- data.frame(
  colData(sce_hvg)[ , c(
    "sample", "cell_id_stem", paste0("hvg_tsne_orig", 1:2),
    "log10_total_features_by_counts", "km_17_clusters", "km_17_clusters_name")],
  add_df[1:2])
rownames(gg_df) <- NULL
gg_df$km_17_clusters_name <- factor(gg_df$km_17_clusters_name)
rm(edat)

plotPCA(sce_hvg, colour_by = "km_17_clusters_name")  +
  ggtitle("PFC EX Neurons KM 17 Clusters HVG PCA") + theme(legend.title = element_blank())
```

#### HVG tSNE

We now take the PCs produced and generate a tSNE for `sce_hvg`, using the same perplexity value of 30 as before.
In this case, subclusters within the exPFC clusters start to become apparent.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache3", "Rtsne.rds")
if (file.exists(rds)) {
  Rtsne <- readRDS(rds)
} else {
  set.seed(1)
  Rtsne <- Rtsne(pca, pca = FALSE, perplexity = 30)
  saveRDS(Rtsne, rds)}
```

```{r}
reducedDims(sce_hvg) <- SimpleList(PCA = pca, TSNE = Rtsne$Y)
add_df <- data.frame(reducedDim(sce_hvg, "TSNE"))
names(add_df) <- paste0("hvg_tsne_new", seq(ncol(add_df)))
gg_df <- data.frame(gg_df, add_df)
rm(Rtsne, pca, add_df)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  km_17_clusters_name = levels(gg_df$km_17_clusters_name),
  label = levels(gg_df$km_17_clusters_name))
label_df2 <- gg_df %>%
  group_by(km_17_clusters_name) %>%
  summarize(hvg_tsne_new1 = median(hvg_tsne_new1), hvg_tsne_new2 = median(hvg_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2",
  col = "km_17_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX Neurons KM 17 Clusters HVG tSNE")
```

## Clustering {.tabset}

While the previous sections explored the components and visualizations of previously generated clusters, we create new ones here.

### Habib 2017 snRNAseq

#### SC3

Using SC3, we attempt to both replicate clusters and generate deeper ones, generating clusters in the range of 2-8.

```{r}
num_clust <- c(2:8)
rowData(sce_hvg)$feature_symbol <- rowData(sce_hvg)$external_gene_name
counts(sce_hvg) <- as.matrix(counts(sce_hvg))
logcounts(sce_hvg) <- as.matrix(logcounts(sce_hvg))
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache3", "sce_hvg.rds")
if (file.exists(rds)) {
  sce_hvg <- readRDS(rds)
} else {
  sce_hvg <- sc3(sce_hvg, ks = num_clust, biology = TRUE)
  saveRDS(sce_hvg, rds)}
```

Next, we inspect our clusters alongside those that were created in the previous analysis.
As can be seen, they coincide well with our previously created clusters.

```{r}
for (i in num_clust) {
  sc3_label <- paste0("sc3_", i, "_clusters")
  gg_df[[sc3_label]] <- as.factor(colData(sce_hvg)[ , sc3_label])}

clusts <- c(paste0("sc3_", num_clust, "_clusters"), "km_17_clusters_name")
clusts_nice <- c(paste0("SC3 ", num_clust, " Clusters"), "KM 17 Clusters")

for (i in 1:length(clusts)) {
  if (i == length(clusts)) {
    print(dim_red_plot(
      data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2", col = clusts[i], type = "cat") +
        xlab("tSNE 1") + ylab("tSNE 2") +
        ggtitle(paste("PFC EX Neurons", clusts_nice[i], "HVG tSNE")))
  } else {
    print(dim_red_plot(
      data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2", col = clusts[i], type = "other") +
        xlab("tSNE 1") + ylab("tSNE 2") +
        ggtitle(paste("PFC EX Neurons", clusts_nice[i], "HVG tSNE")))}}
```

#### Labeling

Now we add labels to the set(s) we are interested.

**SC3 2 Clusters**

By looking at only two clusters, we reduce the complication, though additional insight, from subclusters.

```{r}
gg_df$sc3_2_clusters_name <- NA
sc3_2_clusters <- as.integer(gg_df$sc3_2_clusters)
for (i in 1:length(sc3_2_clusters)) {
  if (sc3_2_clusters[i] == 1) {
    gg_df[i, ncol(gg_df)] <- "exPFC2"
  } else if (sc3_2_clusters[i] == 2) {
    gg_df[i, ncol(gg_df)] <- "exPFC1"}}

colData(sce_hvg) <- cbind(colData(sce_hvg), sc3_2_clusters_name = gg_df$sc3_2_clusters_name)
gg_df$sc3_2_clusters_name <- factor(gg_df$sc3_2_clusters_name)
```

And we visualize the labeled SC3 2 Clusters.

```{r}
# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  sc3_2_clusters_name = levels(gg_df$sc3_2_clusters_name),
  label = levels(gg_df$sc3_2_clusters_name))
label_df2 <- gg_df %>%
  group_by(sc3_2_clusters_name) %>%
  summarize(hvg_tsne_new1 = median(hvg_tsne_new1), hvg_tsne_new2 = median(hvg_tsne_new2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "hvg_tsne_new1", y = "hvg_tsne_new2",
  col = "sc3_2_clusters_name", type = "cat") +
  xlab("tSNE 1") + ylab("tSNE 2") + ggtitle("PFC EX Neurons SC3 2 Clusters HVG tSNE")
```

## Differential Expression {.tabset}

In this section, we calculate differentially expressed genes (DEGs) and identify marker genes for each cluster.
It should be noted that the top ~1,000 HVGs identified earlier are being used, rather than the whole set of genes.

### Habib 2017 snRNAseq

```{r}
labeled_clusts <- c(2)
pdata <- c("sc3_2_clusters_name")
```

#### Expression Matrix

First, we plot an expression matrix to get an overview of the overall expression of each cluster.

```{r}
for (i in labeled_clusts) {
  print(sc3_plot_expression(sce_hvg, k = i, show_pdata = pdata))}
```

#### DEG

Next, we calculate DEGs using a non-parametric Kruskal-Wallis test.
The figure displays the top 50 DEGs where $p < 0.01$.

```{r, fig.height = 9}
for (i in labeled_clusts) {
  print(sc3_plot_de_genes(sce_hvg, k = i, show_pdata = pdata))}
```

#### Marker Genes

To assign marker genes, a binary classifier is constructed based on the mean cluster expression value.
Classifier prediction is then calculated using the gene expression ranks.
Genes with $AUROC > 0.1$ and $p < 0.01$ are selected and the top 10 are visualized in the following figure.

```{r, fig.height = 5.5}
for (i in labeled_clusts) {
  print(sc3_plot_markers(sce_hvg, k = i, auroc = 0.1, show_pdata = pdata))}
```

We can also view a data table containing all the marker genes.

```{r}
markers <- as.data.frame(organise_marker_genes(sce_hvg, k = 2, p_val = 0.01, auroc = 0.1))
markers$sc3_2_clusters_name <- NA
sc3_2_clusters <- as.integer(markers$sc3_2_markers_clusts)
for (i in 1:length(sc3_2_clusters)) {
  if (sc3_2_clusters[i] == 1) {
    markers[i, ncol(markers)] <- "exPFC2"
  } else if (sc3_2_clusters[i] == 2) {
    markers[i, ncol(markers)] <- "exPFC1"}}
datatable_custom(as.data.table(markers))
```

# References

This is the concluding section of the document.
Here we write relevant results to disk, output the `sessionInfo`, and create a bibliography for works cited.

```{r}
sessionInfo()
```
