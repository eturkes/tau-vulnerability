---
title: "13 Habib Neuronal IN"
author:
  - name: "Emir Turkes [emir.turkes@eturkes.com]"
  - name: "UK Dementia Research Institute at UCL"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
bibliography: "../tau-vulnerability.bib"
biblio-style: apalike
link-citations: true
output:
  html_document:
    code_folding: show
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
knit:
  (function(inputFile, encoding) {
    rmarkdown::render(
      inputFile, encoding = encoding, output_file = "../results/13-habib-neuronal-IN.html")})
---

```{r, include = FALSE}
#    This file is part of tau-vulnerability.
#    Copyright (C) 2019  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

knitr::opts_chunk$set(fig.width = 15, fig.height = 13)
```

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
div.main-container {max-width: none; width: 100%;}
</style>

*This file is a part of the [Tau Vulnerability Project](https://github.com/eturkes/tau-vulnerability).*

This document follows up its preparation file to provide and in-depth analysis of neuronal populations in the dataset from @habib_massively_2017.
We start by setting some global variables and loading in any required packages.

```{r}
assets_dir <- file.path(getwd(), "..", "assets")
results_dir <- file.path(getwd(), "..", "results")

packages <- c(
  "conflicted", "SingleCellExperiment", "magrittr", "dplyr", "ggplot2", "ggrepel", "S4Vectors",
  "SummarizedExperiment", "DropletUtils", "scran", "BiocSingular", "scater", "Rtsne", "svd", "SC3",
  "DT", "data.table", "Seurat", "uwot", "viridis", "WGCNA", "pheatmap", "RColorBrewer")
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))

conflict_prefer("which", "BiocGenerics")
options(stringsAsFactors = FALSE)

# Create a unique cache and results data directory for each iterated section.
if (!dir.exists(file.path(assets_dir, "cache", "13"))) {
  dir.create(file.path(assets_dir, "cache", "13"), recursive = TRUE)}
if (!dir.exists(file.path(results_dir, "data", "13"))) {
  dir.create(file.path(results_dir, "data", "13"), recursive = TRUE)}

# ggplot2 function providing custom aesthetics and automatic placement of categorical labels.
# For continuous data, a colorbar is implemented.
dim_red_plot <- function(data, x, y, col, type) {
  gg <- ggplot(data, aes_string(x = x, y = y, color = col)) +
    geom_point(alpha = 0.35, stroke = 0.05, shape = 21, aes_string(fill = col)) +
    theme_classic() +
    theme(
      legend.position = "right", plot.title = element_text(hjust = 0.5),
      legend.title = element_blank()) +
    guides(color = guide_legend(override.aes = list(alpha = 1)))
    if (type == "cat") {
      gg <- gg + geom_label_repel(
        data = label_df2, aes(label = label), show.legend = FALSE, size = 3)
    } else if (type == "cont") {
      gg <- ggplot(data, aes_string(x = x, y = y)) +
        geom_point(alpha = 0.35, stroke = 0.05, aes_string(color = col)) +
        theme_classic() +
        theme(
          legend.position = "right", plot.title = element_text(hjust = 0.5),
          legend.title = element_blank()) +
        scale_colour_viridis()}
  gg}

# From SC3 source, needed to look at more marker genes than the top 10.
organise_marker_genes <- function(object, k, p_val, auroc) {
  dat <- rowData(object)[ , c(
    paste0("sc3_", k, "_markers_clusts"), paste0("sc3_", k, "_markers_auroc"),
    paste0("sc3_", k, "_markers_padj"), "feature_symbol")]
  dat <- dat[dat[ , paste0("sc3_", k, "_markers_padj")] < p_val & !is.na(
    dat[, paste0("sc3_", k, "_markers_padj")]), ]
  dat <- dat[dat[ , paste0("sc3_", k, "_markers_auroc")] > auroc, ]
  d <- NULL
  for (i in sort(unique(dat[, paste0("sc3_", k, "_markers_clusts")]))) {
    tmp <- dat[dat[, paste0("sc3_", k, "_markers_clusts")] == i, ]
    tmp <- tmp[order(tmp[, paste0("sc3_", k, "_markers_auroc")], decreasing = TRUE), ]
    d <- rbind(d, tmp)}
  if (nrow(dat) > 0) {
    return(d)
  } else {
    return(NULL)}}

# From SC3 source, needed to look at more DE genes than the top 50.
organise_de_genes <- function(object, k, p_val) {
  de_genes <- rowData(object)[, paste0("sc3_", k, "_de_padj")]
  names(de_genes) <- rowData(object)$feature_symbol
  de_genes <- de_genes[!is.na(de_genes)]
  de_genes <- de_genes[de_genes < p_val]
  de_genes <- de_genes[order(de_genes)]
  return(de_genes)}

# Adds download buttons.
datatable_custom <- function(dt) {
  datatable(
    dt,
    extensions = "Buttons", options = list(dom = "Blfrtip", buttons = list(
      "copy", "print",
      list(extend = "collection", buttons = c("csv", "excel", "pdf"), text = "Download"))))}
```

We load in the data from the previous analysis.

```{r}
sce <- readRDS(file.path(results_dir, "data", "08", "sce.rds"))
sce
```

# Subsetting to EX

```{r}
# Set up data frame for ggplot2.
gg_df <- data.frame(
  colData(sce)[ , c(
    "cell_id_stem", paste0("habib_tsne", 1:2), "log10_total_features_by_counts",
    "habib_cluster_name", "hvg_seurat_clusters_res_name", paste0("sub_hvg_ppk_umap", 1:2))])
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  hvg_seurat_clusters_res_name = levels(gg_df$hvg_seurat_clusters_res_name),
  label = levels(gg_df$hvg_seurat_clusters_res_name))
label_df2 <- gg_df %>%
  group_by(hvg_seurat_clusters_res_name) %>%
  summarize(
    sub_hvg_ppk_umap1 = median(sub_hvg_ppk_umap1),
    sub_hvg_ppk_umap2 = median(sub_hvg_ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "sub_hvg_ppk_umap1", y = "sub_hvg_ppk_umap2",
  col = "hvg_seurat_clusters_res_name", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") +
  ggtitle("Subset HVG Seurat ~1.3 Resolution Clusters Subset HVG PPK UMAP") + theme_linedraw()
```

```{r}
keep <- sce$sub_hvg_ppk_umap1 > 5
saveRDS(keep, file.path(results_dir, "data", "13", "keep1.rds"))
sce <- sce[ , keep]
sce
```

We remove genes that are now lowly expressed after the subset.

```{r}
sce <- calculateQCMetrics(sce)
detected_genes <- rowSums(counts(sce) >= 2)
sce <- sce[which(detected_genes >= 10), ]
dim(sce)[1]
```

Due to the change in dimensions from subsetting, we renormalize.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "sub_quickCluster.rds")
if (file.exists(rds)) {
  quickCluster <- readRDS(rds)
} else {
  set.seed(1)
  quickCluster <- quickCluster(sce, use.ranks = FALSE, BSPARAM = IrlbaParam())
  saveRDS(quickCluster, rds)}
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "sub_size_factors.rds")
if (file.exists(rds)) {
  size_factors <- readRDS(rds)
} else {
  size_factors <- computeSumFactors(sce, cluster = quickCluster, min.mean = 0.1)
  saveRDS(size_factors, rds)}
```

```{r}
sce <- normalize(sce)
```

And we view the subsetted UMAP figure.

```{r}
# Set up data frame for ggplot2.
gg_df <- data.frame(
  colData(sce)[ , c(
    "cell_id_stem", paste0("habib_tsne", 1:2), "log10_total_features_by_counts",
    "habib_cluster_name", "hvg_seurat_clusters_res_name", paste0("sub_hvg_ppk_umap", 1:2))])
rownames(gg_df) <- NULL
gg_df$habib_cluster_name <- factor(gg_df$habib_cluster_name)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  hvg_seurat_clusters_res_name = levels(gg_df$hvg_seurat_clusters_res_name),
  label = levels(gg_df$hvg_seurat_clusters_res_name))
label_df2 <- gg_df %>%
  group_by(hvg_seurat_clusters_res_name) %>%
  summarize(
    sub_hvg_ppk_umap1 = median(sub_hvg_ppk_umap1),
    sub_hvg_ppk_umap2 = median(sub_hvg_ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "sub_hvg_ppk_umap1", y = "sub_hvg_ppk_umap2",
  col = "hvg_seurat_clusters_res_name", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") +
  ggtitle("Subset HVG Seurat ~1.3 Resolution Clusters Subset HVG PPK UMAP") + theme_linedraw()
```

## HVG

To further reduce noise, we subset the genes to those that are most biologically variable.

```{r}
new_trend <- makeTechTrend(x = sce)
fit <- trendVar(sce, use.spikes = FALSE, loess.args = list(span = 0.05))
fit$trend <- new_trend
dec <- decomposeVar(fit = fit)
top_dec <- rownames(dec[order(dec$bio, decreasing = TRUE), ])[1:10]
rm(fit)
plotExpression(sce, features = top_dec) +
  stat_summary(
    fun.y = median, fun.ymin = median, fun.ymax = median, geom = "crossbar", width = 0.3, alpha = 0.8)

fdr_median <- median(dec$FDR, na.rm = TRUE)
fdr_median
bio_median <- median(dec$bio, na.rm = TRUE)
bio_median
```

We decide that the FDR median is too large to be used as a cutoff, so we use half of the median, which is more reasonable.

```{r, fig.height = 6}
fdr_half_median <- median(dec$FDR, na.rm = TRUE) / 2
fdr_half_median
bio_half_median <- median(dec$bio, na.rm = TRUE) / 2
bio_half_median

par(mfrow = c(1, 2))
hist(log10(dec$FDR), breaks = 100, main = "")
abline(v = c(log10(fdr_half_median), log10(min(dec$FDR[dec$FDR > 0]))), lty = 2, col = "red")
hist(log10(dec$bio), breaks = 100, main = "")
abline(v = c(log10(bio_half_median), log10(max(dec$bio))), lty = 2, col = "red")

keep <- which(dec$FDR < fdr_half_median & dec$bio >= bio_half_median)
sce_hvg <- sce[keep, ]
rm(dec)
dim(sce_hvg)[1]
```

We retain ~1,500 HVGs, a suitable number for our analysis.

### PPK SVD + UMAP

We repeat our preferred dimensionality reduction method from earlier.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "hvg_ppk.rds")
if (file.exists(rds)) {
  ppk <- readRDS(rds)
} else {
  set.seed(1)
  ppk <- propack.svd(scale(t(as.matrix(logcounts(sce_hvg)))), neig = 50)
  saveRDS(ppk, rds)}
```

```{r}
pca <- t(ppk$d * t(ppk$u))
hvg_retain_pcs <- 9
hvg_retain_pcs
par(mfrow = c(1, 1))
plot(
  log10(ppk$d), xlab = "PC", ylab = "log10(Proportion of Variance Explained)",
  pch = 20, cex = 0.6, col = rgb(0.8, 0.2, 0.2, 0.5))
abline(v = hvg_retain_pcs, lty = 2, col = "red")
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "hvg_ppk_umap.rds")
if (file.exists(rds)) {
  umap <- readRDS(rds)
} else {
  set.seed(0)
  umap <- umap(pca[ , 1:hvg_retain_pcs], min_dist = 0.2)
  saveRDS(umap, rds)}
```

```{r}
reducedDims(sce_hvg) <- SimpleList(PCA = pca, UMAP = umap)
add_df <- data.frame(reducedDim(sce_hvg, "UMAP"))
names(add_df) <- paste0("IN_hvg_ppk_umap", seq(ncol(add_df)))
colData(sce_hvg) <- cbind(
  colData(sce_hvg), IN_hvg_ppk_umap1 = add_df$IN_hvg_ppk_umap1,
  IN_hvg_ppk_umap2 = add_df$IN_hvg_ppk_umap2)
colData(sce) <- cbind(
  colData(sce), IN_hvg_ppk_umap1 = add_df$IN_hvg_ppk_umap1,
  IN_hvg_ppk_umap2 = add_df$IN_hvg_ppk_umap2)
gg_df <- data.frame(gg_df, add_df)
rm(pca, add_df)

label_df2 <- gg_df %>%
  group_by(hvg_seurat_clusters_res_name) %>%
  summarize(
    IN_hvg_ppk_umap1 = median(IN_hvg_ppk_umap1), IN_hvg_ppk_umap2 = median(IN_hvg_ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
  col = "hvg_seurat_clusters_res_name", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Whole Set Seurat Clusters Subset HVG PPK UMAP")
dim_red_plot(
  data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
  col = "cell_id_stem", type = "other") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Sample Distribution Subset HVG PPK UMAP")
dim_red_plot(
  data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
  col = "log10_total_features_by_counts", type = "cont") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("log10(Total Features) Subset HVG PPK UMAP")
```

We see that subsetting to HVGs clarifies the UMAP figure, so we use those coordinates for all downstream analysis.

# Clustering

## Seurat

Seurat is a nearest neighbor graph clustering method with a `resolution` parameter that indirectly influences the number of clusters generated.
Concerning `resolution`, the authors write:

> setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells.
Optimal resolution often increases for larger datasets.

We try scaling the median of these recommended settings (0.8, which is also the default) to the size of our dataset.
As Seurat typically uses HVGs, we also use `sce_hvg` as input.

```{r}
resolution <- (dim(sce)[2] / 3000) * 0.8
resolution
```

We cluster in the range of $\pm 0.2$ from this resolution.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "seurat_hvg_res_minus0.2.rds")
if (file.exists(rds)) {
  seurat_hvg <- readRDS(rds)
} else {
  seurat_hvg <- as.Seurat(sce_hvg, counts = "counts", data = NULL)
  seurat_hvg <- NormalizeData(seurat_hvg)
  seurat_hvg <- FindVariableFeatures(seurat_hvg, nfeatures = dim(sce_hvg)[1])
  seurat_hvg <- ScaleData(seurat_hvg, features = rownames(seurat_hvg))
  seurat_hvg <- FindNeighbors(seurat_hvg, reduction = "PCA", dims = 1:hvg_retain_pcs)
  seurat_hvg <- FindClusters(seurat_hvg, resolution = resolution - 0.2)
  saveRDS(seurat_hvg, rds)}
```

```{r}
gg_df$hvg_seurat_clusters_res_minus0.2 <- seurat_hvg$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  hvg_seurat_clusters_res_minus0.2 = levels(gg_df$hvg_seurat_clusters_res_minus0.2),
  label = levels(gg_df$hvg_seurat_clusters_res_minus0.2))
label_df2 <- gg_df %>%
  group_by(hvg_seurat_clusters_res_minus0.2) %>%
  summarize(
    IN_hvg_ppk_umap1 = median(IN_hvg_ppk_umap1), IN_hvg_ppk_umap2 = median(IN_hvg_ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
  col = "hvg_seurat_clusters_res_minus0.2", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") +
  ggtitle("Subset HVG Seurat ~0.2 Resolution Clusters Subset HVG PPK UMAP")
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "seurat_hvg_res_minus0.1.rds")
if (file.exists(rds)) {
  seurat_hvg <- readRDS(rds)
} else {
  seurat_hvg <- as.Seurat(sce_hvg, counts = "counts", data = NULL)
  seurat_hvg <- NormalizeData(seurat_hvg)
  seurat_hvg <- FindVariableFeatures(seurat_hvg, nfeatures = dim(sce_hvg)[1])
  seurat_hvg <- ScaleData(seurat_hvg, features = rownames(seurat_hvg))
  seurat_hvg <- FindNeighbors(seurat_hvg, reduction = "PCA", dims = 1:hvg_retain_pcs)
  seurat_hvg <- FindClusters(seurat_hvg, resolution = resolution - 0.1)
  saveRDS(seurat_hvg, rds)}
```

```{r}
gg_df$hvg_seurat_clusters_res_minus0.1 <- seurat_hvg$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  hvg_seurat_clusters_res_minus0.1 = levels(gg_df$hvg_seurat_clusters_res_minus0.1),
  label = levels(gg_df$hvg_seurat_clusters_res_minus0.1))
label_df2 <- gg_df %>%
  group_by(hvg_seurat_clusters_res_minus0.1) %>%
  summarize(
    IN_hvg_ppk_umap1 = median(IN_hvg_ppk_umap1), IN_hvg_ppk_umap2 = median(IN_hvg_ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
  col = "hvg_seurat_clusters_res_minus0.1", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") +
  ggtitle("Subset HVG Seurat ~0.3 Resolution Clusters Subset HVG PPK UMAP")
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "seurat_hvg_res.rds")
if (file.exists(rds)) {
  seurat_hvg <- readRDS(rds)
} else {
  seurat_hvg <- as.Seurat(sce_hvg, counts = "counts", data = NULL)
  seurat_hvg <- NormalizeData(seurat_hvg)
  seurat_hvg <- FindVariableFeatures(seurat_hvg, nfeatures = dim(sce_hvg)[1])
  seurat_hvg <- ScaleData(seurat_hvg, features = rownames(seurat_hvg))
  seurat_hvg <- FindNeighbors(seurat_hvg, reduction = "PCA", dims = 1:hvg_retain_pcs)
  seurat_hvg <- FindClusters(seurat_hvg, resolution = resolution)
  saveRDS(seurat_hvg, rds)}
```

```{r}
gg_df$hvg_seurat_clusters_res <- seurat_hvg$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  hvg_seurat_clusters_res = levels(gg_df$hvg_seurat_clusters_res),
  label = levels(gg_df$hvg_seurat_clusters_res))
label_df2 <- gg_df %>%
  group_by(hvg_seurat_clusters_res) %>%
  summarize(
    IN_hvg_ppk_umap1 = median(IN_hvg_ppk_umap1), IN_hvg_ppk_umap2 = median(IN_hvg_ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
  col = "hvg_seurat_clusters_res", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") +
  ggtitle("Subset HVG Seurat ~0.4 Resolution Clusters Subset HVG PPK UMAP")
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "seurat_hvg_res_plus0.1.rds")
if (file.exists(rds)) {
  seurat_hvg <- readRDS(rds)
} else {
  seurat_hvg <- as.Seurat(sce_hvg, counts = "counts", data = NULL)
  seurat_hvg <- NormalizeData(seurat_hvg)
  seurat_hvg <- FindVariableFeatures(seurat_hvg, nfeatures = dim(sce_hvg)[1])
  seurat_hvg <- ScaleData(seurat_hvg, features = rownames(seurat_hvg))
  seurat_hvg <- FindNeighbors(seurat_hvg, reduction = "PCA", dims = 1:hvg_retain_pcs)
  seurat_hvg <- FindClusters(seurat_hvg, resolution = resolution + 0.1)
  saveRDS(seurat_hvg, rds)}
```

```{r}
gg_df$hvg_seurat_clusters_res_plus0.1 <- seurat_hvg$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  hvg_seurat_clusters_res_plus0.1 = levels(gg_df$hvg_seurat_clusters_res_plus0.1),
  label = levels(gg_df$hvg_seurat_clusters_res_plus0.1))
label_df2 <- gg_df %>%
  group_by(hvg_seurat_clusters_res_plus0.1) %>%
  summarize(
    IN_hvg_ppk_umap1 = median(IN_hvg_ppk_umap1), IN_hvg_ppk_umap2 = median(IN_hvg_ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
  col = "hvg_seurat_clusters_res_plus0.1", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") +
  ggtitle("Subset HVG Seurat ~0.5 Resolution Clusters Subset HVG PPK UMAP")
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "seurat_hvg_res_plus0.2.rds")
if (file.exists(rds)) {
  seurat_hvg <- readRDS(rds)
} else {
  seurat_hvg <- as.Seurat(sce_hvg, counts = "counts", data = NULL)
  seurat_hvg <- NormalizeData(seurat_hvg)
  seurat_hvg <- FindVariableFeatures(seurat_hvg, nfeatures = dim(sce_hvg)[1])
  seurat_hvg <- ScaleData(seurat_hvg, features = rownames(seurat_hvg))
  seurat_hvg <- FindNeighbors(seurat_hvg, reduction = "PCA", dims = 1:hvg_retain_pcs)
  seurat_hvg <- FindClusters(seurat_hvg, resolution = resolution + 0.2)
  saveRDS(seurat_hvg, rds)}
```

```{r}
gg_df$hvg_seurat_clusters_res_plus0.2 <- seurat_hvg$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  hvg_seurat_clusters_res_plus0.2 = levels(gg_df$hvg_seurat_clusters_res_plus0.2),
  label = levels(gg_df$hvg_seurat_clusters_res_plus0.2))
label_df2 <- gg_df %>%
  group_by(hvg_seurat_clusters_res_plus0.2) %>%
  summarize(
    IN_hvg_ppk_umap1 = median(IN_hvg_ppk_umap1), IN_hvg_ppk_umap2 = median(IN_hvg_ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
  col = "hvg_seurat_clusters_res_plus0.2", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") +
  ggtitle("Subset HVG Seurat ~0.6 Resolution Clusters Subset HVG PPK UMAP")
```

We also try at 2 and 3 times the median of the recommended settings.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "seurat_hvg_res_times2.rds")
if (file.exists(rds)) {
  seurat_hvg <- readRDS(rds)
} else {
  seurat_hvg <- as.Seurat(sce_hvg, counts = "counts", data = NULL)
  seurat_hvg <- NormalizeData(seurat_hvg)
  seurat_hvg <- FindVariableFeatures(seurat_hvg, nfeatures = dim(sce_hvg)[1])
  seurat_hvg <- ScaleData(seurat_hvg, features = rownames(seurat_hvg))
  seurat_hvg <- FindNeighbors(seurat_hvg, reduction = "PCA", dims = 1:hvg_retain_pcs)
  seurat_hvg <- FindClusters(seurat_hvg, resolution = resolution * 2)
  saveRDS(seurat_hvg, rds)}
```

```{r}
gg_df$hvg_seurat_clusters_res_times2 <- seurat_hvg$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  hvg_seurat_clusters_res_times2 = levels(gg_df$hvg_seurat_clusters_res_times2),
  label = levels(gg_df$hvg_seurat_clusters_res_times2))
label_df2 <- gg_df %>%
  group_by(hvg_seurat_clusters_res_times2) %>%
  summarize(
    IN_hvg_ppk_umap1 = median(IN_hvg_ppk_umap1), IN_hvg_ppk_umap2 = median(IN_hvg_ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
  col = "hvg_seurat_clusters_res_times2", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") +
  ggtitle("Subset HVG Seurat ~0.8 Resolution Clusters Subset HVG PPK UMAP")
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "seurat_hvg_res_times3.rds")
if (file.exists(rds)) {
  seurat_hvg <- readRDS(rds)
} else {
  seurat_hvg <- as.Seurat(sce_hvg, counts = "counts", data = NULL)
  seurat_hvg <- NormalizeData(seurat_hvg)
  seurat_hvg <- FindVariableFeatures(seurat_hvg, nfeatures = dim(sce_hvg)[1])
  seurat_hvg <- ScaleData(seurat_hvg, features = rownames(seurat_hvg))
  seurat_hvg <- FindNeighbors(seurat_hvg, reduction = "PCA", dims = 1:hvg_retain_pcs)
  seurat_hvg <- FindClusters(seurat_hvg, resolution = resolution * 3)
  saveRDS(seurat_hvg, rds)}
```

```{r}
gg_df$hvg_seurat_clusters_res_times3 <- seurat_hvg$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  hvg_seurat_clusters_res_times3 = levels(gg_df$hvg_seurat_clusters_res_times3),
  label = levels(gg_df$hvg_seurat_clusters_res_times3))
label_df2 <- gg_df %>%
  group_by(hvg_seurat_clusters_res_times3) %>%
  summarize(
    IN_hvg_ppk_umap1 = median(IN_hvg_ppk_umap1), IN_hvg_ppk_umap2 = median(IN_hvg_ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
  col = "hvg_seurat_clusters_res_times3", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") +
  ggtitle("Subset HVG Seurat ~1.2 Resolution Clusters Subset HVG PPK UMAP")
```

We see that clusters do not increase with increasing resolution and that they stabilized at 5 clusters.
Therefore, we go forward with the analysis using the recommended resolution.

```{r}
seurat_hvg <- readRDS(file.path(assets_dir, "cache", "13", "seurat_hvg_res.rds"))
```

## SC3

As an alternative, we try clustering using SC3.
First, we estimate the optimal $k$ for our dataset.

```{r}
rowData(sce_hvg)$feature_symbol = rowData(sce_hvg)$external_gene_name
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "13", "hvg_sc3_estimate_k.rds")
if (file.exists(rds)) {
  hvg_sc3_estimate_k <- readRDS(rds)
} else {
  set.seed(1)
  hvg_sc3_estimate_k <- sc3_estimate_k(sce_hvg)
  saveRDS(hvg_sc3_estimate_k, rds)}
```

```{r}
sce_hvg <- hvg_sc3_estimate_k
rm(hvg_sc3_estimate_k)
metadata(sce_hvg)$sc3$k_estimation
```

SC3's optimal $k$ seems large compared to Seurat's suggestions, so we generate 2-7 clusters to capture those with Seurat with a margin of error.

```{r}
num_clust <- c(2:7)
counts(sce_hvg) <- as.matrix(counts(sce_hvg))
logcounts(sce_hvg) <- as.matrix(logcounts(sce_hvg))
```

```{r}
# Knitr caching turned off due to:
# Error in lazyLoadDBinsertVariable(vars[i], from, datafile, ascii, compress,  :
# long vectors not supported yet
rds <- file.path(assets_dir, "cache", "13", "hvg_sc3.rds")
if (file.exists(rds)) {
  hvg_sc3 <- readRDS(rds)
} else {
  hvg_sc3 <- sc3(sce_hvg, ks = num_clust, gene_filter = FALSE, biology = TRUE)
  saveRDS(hvg_sc3, rds)}
```

```{r}
sce_hvg <- hvg_sc3
rm(hvg_sc3)

for (i in num_clust) {
  sc3_label <- paste0("sc3_", i, "_clusters")
  hvg_sc3_label <- paste0("hvg_sc3_", i, "_clusters")
  gg_df[[hvg_sc3_label]] <- factor(colData(sce_hvg)[ , sc3_label])}
clusts <- c(paste0("hvg_sc3_", num_clust, "_clusters"))
clusts_nice <- c(paste0("HVG SC3 ", num_clust, " Clusters"))

for (i in 1:length(clusts)) {
  # Setup for automatic placement of cluster labels.
  label_df <- data.frame(tmp = levels(gg_df[[clusts[i]]]), label = levels(gg_df[[clusts[i]]]))
  names(label_df)[names(label_df) == "tmp"] <- clusts[i]
  label_df2 <- gg_df %>%
    group_by_at(clusts[i]) %>%
    summarize(
      IN_hvg_ppk_umap1 = median(IN_hvg_ppk_umap1),
      IN_hvg_ppk_umap2 = median(IN_hvg_ppk_umap2)) %>%
    left_join(label_df)

  print(dim_red_plot(
    data = gg_df, x = "IN_hvg_ppk_umap1", y = "IN_hvg_ppk_umap2",
    col = clusts[i], type = "cat") +
      xlab("UMAP 1") + ylab("UMAP 2") +
      ggtitle(paste("Subset", clusts_nice[i], "Subset HVG PPK UMAP")))}
```

# IHC Genes

Next, we examine the expression of a set genes for which we have antibodies to conduct immunohistochemistry.
Due to the removal of some genes from QC and the HVG section, we create a new Seurat object with minimal processing but with HVG metadata.

```{r}
sce_orig <- readRDS(file.path(results_dir, "data", "08", "sce_orig.rds"))
keep <- readRDS(file.path(results_dir, "data", "08", "keep1.rds"))
sce_orig <- sce_orig[ , keep]
keep <- readRDS(file.path(results_dir, "data", "08", "keep2.rds"))
sce_orig <- sce_orig[ , keep]
keep <- readRDS(file.path(results_dir, "data", "13", "keep1.rds"))
sce_orig <- sce_orig[ , keep]
sce_orig <- calculateQCMetrics(sce_orig)
detected_genes <- rowSums(counts(sce_orig) >= 1)
sce_orig <- sce_orig[which(detected_genes >= 1), ]

seurat_orig <- as.Seurat(sce_orig, counts = "counts", data = NULL)
umap <- as.matrix(data.frame(sce_hvg$IN_hvg_ppk_umap1, sce_hvg$IN_hvg_ppk_umap2))
colnames(umap) <- paste0("UMAP_", 1:2)
rownames(umap) <- colnames(sce_orig)
seurat_orig[["UMAP"]] <- CreateDimReducObject(
  embeddings = umap, key = "UMAP_", assay = DefaultAssay(seurat_orig))
Idents(object = seurat_orig) <- Idents(object = seurat_hvg)
seurat_orig <- NormalizeData(seurat_orig)
seurat_orig <- ScaleData(seurat_orig, features = rownames(seurat_orig))

genes <- c("TBR1", "SATB2", "SATB1", "WFS1", "GAD1", "CALB1", "SST", "PVALB", "CALB2")
rm(umap)
DoHeatmap(seurat_orig, slot = "data", features = genes, size = 3) +
  NoLegend() +
  scale_fill_gradient2(
    low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
    high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
    guide = "colourbar", aesthetics = "fill")
VlnPlot(seurat_orig, features = genes, ncol = 3)
FeaturePlot(
  seurat_orig, reduction = "UMAP", features = genes, order = TRUE,
  cols = c("lightgrey", "red"), max.cutoff = 20, ncol = 3)
DotPlot(seurat_orig, features = genes, cols = c("blue", "red")) + RotatedAxis()
```

# References

This is the concluding section of the document. Here we write relevant results to disk, output the `sessionInfo`, and create a bibliography for works cited.

```{r}
saveRDS(sce_hvg, file.path(results_dir, "data", "13", "sce_hvg.rds"))
saveRDS(seurat_hvg, file.path(results_dir, "data", "13", "seurat_hvg.rds"))

sessionInfo()
```
