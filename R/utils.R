#    This file is part of tau-vulnerability.
#    Copyright (C) 2019-2020  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

# This file holds common functions and methods.
# ---------------------------------------------

#' ggplot2 function providing custom aesthetics and automatic placement of categorical labels.
#' For continuous data, a colorbar is implemented.
#'
#' @param data SingleCellExperiment or Seurat object.
#' @param x,y Dimensionality reduction coordinates.
#' @param color Column metadata to color points by.
#' @param type \code{"cat"} is categorical, \code{"cont"} is continuous, \code{"NULL"} is generic.
#' @examples
#' red_dim_plot(data = sce, x = "tsne1", y = "tsne2", color = "cluster", type = "cat")
#' red_dim_plot(data = seurat, x = "umap1", y = "umap2", color = "nUMI", type = "cont")
#'
red_dim_plot <- function(data, x, y, color, type = NULL) {

  if ((class(data))[1] == "SingleCellExperiment") {
    gg_df <- data.frame(colData(data)[ , c(x, y, color)])
  } else if ((class(data))[1] == "Seurat") {
    gg_df <- data.frame(data[[x]], data[[y]], data[[color]])
  }
  rownames(gg_df) <- NULL
  gg_df[[color]] <- factor(gg_df[[color]])

  gg <- ggplot(gg_df, aes_string(x = x, y = y, color = color)) +
    geom_point(alpha = 0.35, stroke = 0.05, shape = 21, aes_string(fill = color)) +
    theme_classic() +
    theme(
      legend.position = "right", plot.title = element_text(hjust = 0.5),
      legend.title = element_blank()
    ) +
    guides(color = guide_legend(override.aes = list(alpha = 1)))

  if (is.null(type)) {
    return(gg)

  } else if (type == "cat") {
    label_df <- gg_df %>% group_by_at(color) %>% summarise_at(vars(x:y), median)
    label_df <- cbind(label_df[[1]], label_df)
    names(label_df) <- c("label", color, x, y)
    gg <- gg + geom_label_repel(data = label_df, aes(label = label), show.legend = FALSE)

  } else if (type == "cont") {
    # TODO: Refactor repeated code.
    if ((class(data))[1] == "SingleCellExperiment") {
      gg_df <- data.frame(colData(data)[ , c(x, y, color)])
    } else if ((class(data))[1] == "Seurat") {
      gg_df <- data.frame(data[[x]], data[[y]], data[[color]])
    }
    rownames(gg_df) <- NULL

    gg <- ggplot(gg_df, aes_string(x = x, y = y)) +
      geom_point(alpha = 0.35, stroke = 0.05, aes_string(color = color)) +
      theme_classic() +
      theme(
        legend.position = "right", plot.title = element_text(hjust = 0.5),
        legend.title = element_blank()
      ) +
      scale_color_viridis()
  }
  gg
}

#' Adds download buttons and horizontal scrolling to \code{"DT::datatable"}.
#'
#' @param dt A data.table object.
#' @examples
#' datatable_custom(dt = data_table)
#'
datatable_custom <- function(dt) {

  datatable(
    dt, extensions = "Buttons",
    options = list(
      scrollX = TRUE, dom = "Blfrtip",
      buttons = list(
        "copy", "print",
        list(extend = "collection", buttons = c("csv", "excel", "pdf"), text = "Download")
      )
    )
  )
}

#' Convert human to mouse gene names.
#' Adapted from:
#' https://rjbioinformatics.com/2016/10/14/converting-mouse-to-human-gene-names-with-biomart-package/
#'
#' @param genes A list of human genes.
#' @examples
#' human_to_mouse_genes(genes = gene_list)
#'
human_to_mouse_genes <- function(genes) {

  # Specifying host seems to improve reliability.
  human <- useMart(
    "ensembl", dataset = "hsapiens_gene_ensembl", host = "http://useast.ensembl.org/"
  )
  mouse <- useMart(
    "ensembl", dataset = "mmusculus_gene_ensembl", host = "http://useast.ensembl.org/"
  )

  new_genes <- getLDS(
    attributes = "hgnc_symbol", filters = "hgnc_symbol", values = genes , mart = human,
    attributesL = "mgi_symbol", martL = mouse, uniqueRows = TRUE
  )
  new_genes <- unique(new_genes[ , 2])
}

#' Pipeline for normalization, dimensionality reduction, and clustering of post-QC scRNA-seq data.
#' NOTE: Separate pipelines for UMIs and read counts are incomplete and left commented out.
#'
#' @param seurat Post-QC Seurat object.
#' @param assets_dir Directory to save post-processed Seurat object.
#' @param analysis_no Integer to save object to a specific directory within \code{"assets_dir"}.
#' @param sub_name Subset level for naming of cache object.
#' @param organism \code{"human"} for human, \code{"mouse"} for mouse.
#' @param protocol \code{"umis} for UMIs, \code{"reads"} for full-length reads.
#' @param vars_to_regress Vector of nuisance variables for sctransform to regress out.
#' @param parallel_override See function \code{"parallel_plan"}.
#' @examples
#' cluster_pipeline(
#'   seurat = seurat, assets_dir = assets_dir, analysis_no = 1, sub_name = "neuronal",
#'   organism = "mouse", vars_to_regress = c(batch, "mito_percent"), parallel_override = NULL)
#' )
cluster_pipeline <- function(
  seurat, assets_dir, analysis_no, sub_name, organism, protocol, vars_to_regress, parallel_override
) {

  # Utilize a basic caching system.
  rds <- file.path(assets_dir, "cache", paste0("0", analysis_no), paste0(sub_name, "_seurat.rds"))
  if (file.exists(rds)) {
    seurat <- readRDS(rds)
    return(seurat)

  } else {
    # Remove obsolete data.
    DefaultAssay(seurat) <- "RNA"
    seurat <- seurat[rowSums(as.matrix(GetAssayData(seurat, slot = "counts")) > 0) > 0, ]
    seurat[["SCT"]] <- NULL

    # if (protocol[3] == "umis") {
    #   # Perform sctransform.
    #   # Note that this function produces many iterations of the following benign warning:
    #   # Warning in theta.ml(y = y, mu = fit$fitted): iteration limit reached
    #   parallel_plan(seurat, parallel_override = parallel_override)
    #   seurat <- SCTransform(seurat, vars.to.regress = vars_to_regress, verbose = FALSE)
    #
    # } else if (protocol[3] == "reads") {
    #   # Use ZINB-WaVE while accounting for within-sample gene-level covariates.
    #   sce <- as.SingleCellExperiment(seurat)
    #   logcounts(sce) <- NULL
    #   if (organism == "human") {
    #     dataset = "hsapiens_gene_ensembl"
    #   } else if (organism == "mouse") {
    #     dataset = "mmusculus_gene_ensembl"
    #   }
    #   mart <- useEnsembl(
    #     biomart = "ensembl", dataset = dataset, host = "http://useast.ensembl.org/"
    #   )
    #   attributes <- c(
    #     "external_gene_name", "start_position", "end_position", "percentage_gene_gc_content"
    #   )
    #   gene_anno <- getBM(
    #     attributes = attributes, filters = "external_gene_name",
    #     values = rownames(sce), mart = mart
    #   )
    #   gene_anno <- gene_anno[!duplicated(gene_anno$external_gene_name), ]
    #   sce <- sce[which(rownames(sce) %in% gene_anno$external_gene_name), ]
    #   gene_anno$length <- gene_anno$end_position - gene_anno$start_position
    #   len <- tapply(gene_anno$length, gene_anno$external_gene_name, mean)
    #   len <- len[rownames(sce)]
    #   gcc <- tapply(gene_anno$percentage_gene_gc_content, gene_anno$external_gene_name, mean)
    #   gcc <- gcc[rownames(sce)]
    #   rowData(sce) <- data.frame(gc_content = gcc, length = len)
    #   seurat <- seurat[rownames(seurat) %in% rownames(sce), ]
    #   seurat <- NormalizeData(seurat, verbose = FALSE)
    #   seurat <- FindVariableFeatures(seurat, nfeatures = 1000, verbose = FALSE)
    #   sce <- sce[rownames(sce) %in% VariableFeatures(seurat), ]
    #   counts(sce) <- as.matrix(counts(sce))
    #
    #   # TODO: Finish section.
    #   sce <- zinbwave(
    #     sce, K = 10, X = paste0("~ ", vars_to_regress[1], " + ", vars_to_regress[2]),
    #     V = "~ gc_content + log(length)", BPPARAM = MulticoreParam()
    #   )
    #   saveRDS(
    #     sce,
    #     file.path(assets_dir, "cache", paste0("0", analysis_no), paste0(sub_name, "_zinb.rds"))
    #   )
    # }

    # Perform sctransform.
    # Note that this function produces many iterations of the following benign warning:
    # Warning in theta.ml(y = y, mu = fit$fitted): iteration limit reached
    parallel_plan(seurat, parallel_override = parallel_override)
    seurat <- SCTransform(seurat, vars.to.regress = vars_to_regress, verbose = FALSE)

    # Perform cell cycle scoring.
    if (organism == "human") {
      s_genes <- cc.genes.updated.2019$s.genes
      g2m_genes <- cc.genes.updated.2019$g2m.genes
    } else if (organism == "mouse") {
      s_genes <- human_to_mouse_genes(cc.genes.updated.2019$s.genes)
      g2m_genes <- human_to_mouse_genes(cc.genes.updated.2019$g2m.genes)
    }
    seurat <- CellCycleScoring(seurat, s.features = s_genes, g2m.features = g2m_genes)
    seurat$cc_diff <- seurat$S.Score - seurat$G2M.Score # Combined proliferating cell signal.

    # Perform PCA.
    # We also add the output as column metadata for use with `red_dim_plot`.
    seurat <- RunPCA(seurat, verbose = FALSE)
    add_df <- data.frame(Embeddings(seurat, reduction = "pca")[ , 1:2])
    names(add_df) <- paste0("pca", seq(ncol(add_df)))
    seurat$pca1 <- add_df$pca1
    seurat$pca2 <- add_df$pca2

    # Perform UMAP reduction.
    # We also add the output as column metadata for use with `red_dim_plot`.
    seurat <- RunUMAP(seurat, dims = 1:30, min.dist = 0.75, verbose = FALSE)
    add_df <- data.frame(Embeddings(seurat, reduction = "umap"))
    names(add_df) <- paste0("umap", seq(ncol(add_df)))
    seurat$umap1 <- add_df$umap1
    seurat$umap2 <- add_df$umap2

    # Perform Louvain clustering.
    resolution <- (dim(seurat)[2] / 3000) * 0.8 # Default is optimal for 3K cells so we scale it.
    seurat <- FindNeighbors(seurat, dims = 1:30, verbose = FALSE)
    seurat <- FindClusters(seurat, resolution = resolution, verbose = FALSE)

    saveRDS(seurat, rds)
  }
  seurat
}

#' Set the \code{"plan"} for \code{"future"} based on free memory and object size with the option to
#' override.
#'
#' @param object Object to check if \code{"future.globals.maxSize"} large enough to parallelize.
#' @param parallel_override \code{"NULL"} to calculate plan decision, \code{0} for sequential, a
#' non-zero integer for multiprocess and to set \code{"future.globals.maxSize"}.
#' @examples
#' parallel_plan(object = seurat, parallel_override = 5368709120)
#'
parallel_plan <- function(object, parallel_override = NULL) {

  if (is.null(parallel_override)) {
    # Get free memory.
    gc()
    mem <- as.numeric(unlist(strsplit(system("free -b", intern = TRUE)[2], " "))[7])

    # Distribute free memory (minus 10 GiB) across available cores.
    mem <- mem - 10 * 1024 ^ 3
    mem <- mem / detectCores()

    # Enable parallelization only if `object` can fit in `future.globals.maxSize` (plus 1 Gib).
    if (mem > object.size(object) + 1 * 1024 ^ 3) {
      plan("multiprocess")
      options(future.globals.maxSize = mem)
    } else {
      plan("sequential")
    }

  } else if (parallel_override == 0) {
    plan("sequential")

  } else {
    plan("multiprocess")
    options(future.globals.maxSize = parallel_override)
  }
}


#' Plot genes of a Seurat object in various ways.
#'
#' @param subset_list A list containing Seurat objects.
#' @param subset_names A character vector of names for each Seurat object.
#' @param genes A character vector of genes to plot.
#' @examples
#' gene_plot(subset_list = sublist, subset_names = c("seurat1, "seurat2"), genes = c("TBR1, "GAD1))
#'
gene_plot <- function(subset_list, subset_names, genes) {

  for (i in 1:length(subset_list)) {
    print(subset_names[i])

    if (length(genes) == 2 & (all(genes %in% rownames(subset_list[[i]])))) {
      plots <- FeaturePlot(
        subset_list[[i]], features = genes, order = TRUE, blend = TRUE,
        combine = FALSE, blend.threshold = 0, max.cutoff = "q10"
      )
      print(CombinePlots(plots[3:4], legend = "none"))
    } else if (length(which(genes %in% rownames(subset_list[[i]]))) > 1) {
      print(
        FeaturePlot(
          subset_list[[i]], features = genes, order = TRUE,
          cols = c("lightgrey", "red"), ncol = 2
        )
      )
    }

    if (length(which(genes %in% rownames(subset_list[[i]]))) > 1) {
      print(DotPlot(subset_list[[i]], features = genes, cols = c("blue", "red")) + RotatedAxis())
      print(
        DoHeatmap(subset_list[[i]], slot = "data", features = genes, size = 3) +
          NoLegend() +
          scale_fill_gradient2(
            low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
            high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
            guide = "colourbar", aesthetics = "fill"
          )
      )
      print(VlnPlot(subset_list[[i]], features = genes, ncol = 1))
    } else {
      print("One or fewer genes present.")
    }
  }
}


#' Compare two groups using GSVA.
#' TODO: Make generalizable for different protocols.
#' TODO: Have returning \code{"fit"} after looping make more sense.
#'
#' @param seurat Post-QC Seurat object.
#' @param assets_dir Directory to save post-processed Seurat object.
#' @param analysis_no Integer to save object to a specific directory within \code{"assets_dir"}.
#' @param save_name Stem for saving RDS objects.
#' @param data_name Identifier for dataset.
#' @param organism \code{"human"} for human, \code{"mouse"} for mouse.
#' @param conditions Vector containing the names of the conditions to be compared.
#' @param sub List containing Seurat Idents for each condition.
#' @param gene_set_list List containing the names of gene sets to be used with GSVA.
#' @examples
#' cluster_pipeline(
#'   seurat = seurat, assets_dir = assets_dir, analysis_no = 5,
#'   save_name = "EC_L6_EX", data_name = "allen_human_multicort", organism = "mouse",
#'   conditions = c("EC L6 EX", "EC L2 EX"), sub = sub, gene_set_list = "GO_BP"
#' )
gsva_pipeline <- function(
  seurat, assets_dir, analysis_no, save_name, data_name, organism, conditions, sub, gene_set_list
) {

  # Create subsets.
  seurat <- subset(seurat, idents = c(sub[[1]], sub[[2]]))
  seurat <- seurat[rowSums(as.matrix(GetAssayData(seurat, slot = "counts")) > 0) > 0, ]
  condition1_seurat <- subset(seurat, idents = sub[[1]])
  condition2_seurat <- subset(seurat, idents = sub[[2]])
  rm(seurat)
  sce <- SingleCellExperiment(
    assays = list(
      counts = cbind(
        as.matrix(GetAssayData(condition1_seurat)), as.matrix(GetAssayData(condition2_seurat))
      )
    )
  )
  groups <- factor(rep(c(0, 1), c(dim(condition1_seurat)[2], dim(condition2_seurat)[2])))
  levels(groups) <- conditions

  # Renormalize using SCnorm.
  rds <- file.path(
    assets_dir, "cache", paste0("0", analysis_no), paste0(save_name, "_", "scnorm.rds")
  )
  if (file.exists(rds)) {
    comb_mat <- readRDS(rds)
  } else {
    if (organism == "human") {
      dataset = "hsapiens_gene_ensembl"
    } else if (organism == "mouse") {
      dataset = "mmusculus_gene_ensembl"
    }
    mart <- useEnsembl(biomart = "ensembl", dataset = dataset, host = "http://useast.ensembl.org/")
    attributes <- c(
      "external_gene_name", "start_position", "end_position", "percentage_gene_gc_content"
    )
    gene_anno <- getBM(
      attributes = attributes, filters = "external_gene_name", values = rownames(sce), mart = mart
    )
    gene_anno <- gene_anno[!duplicated(gene_anno$external_gene_name), ]
    sce <- sce[which(rownames(sce) %in% gene_anno$external_gene_name), ]
    gene_anno$length <- gene_anno$end_position - gene_anno$start_position
    len <- tapply(gene_anno$length, gene_anno$external_gene_name, mean)
    len <- len[rownames(sce)]
    gcc <- tapply(gene_anno$percentage_gene_gc_content, gene_anno$external_gene_name, mean)
    gcc <- gcc[rownames(sce)]
    rowData(sce) <- data.frame(gc_content = gcc, length = len)
    sce <- SCnorm(
      sce, Conditions = groups, withinSample = c(rowData(sce)$gc_content, rowData(sce)$length),
      useZerosToScale = TRUE, NCores = detectCores()
    )
    comb_mat <- log(normcounts(sce) + 1)
    saveRDS(comb_mat, rds)
  }

  # Set up the design matrix and heatmap colors.
  rm(condition1_seurat, condition2_seurat)
  design <- model.matrix(~ groups)
  colnames(design) <- conditions
  color_legend <- c("lightgray", "darkgray")
  names(color_legend) <- conditions
  sample_color_map <- color_legend[groups]

  print(hist(comb_mat))

  # Basic DE analysis with `limma`, mostly as a sanity check.
  # Positive logFC values are those upreguled in the coef argument.
  fit <- lmFit(comb_mat, design)
  fit <- eBayes(fit)
  print("Basic DE analysis.")
  print(topTable(fit, coef = conditions[2], number = 25, adjust.method = "holm", p.value = 0.05))

  for (i in 1:length(gene_set_list)) {
    if (organism == "mouse") {
      gene_set_list[i] <- paste0(gene_set_list[i], "_mouse")
    }
    gene_sets <- getGmt(file.path(assets_dir, "..", "gene-sets", paste0(gene_set_list[i], ".gmt")))
    gene_sets

    # Run GSVA and cache the results.
    rds <- file.path(
      assets_dir, "cache", paste0("0", analysis_no),
      paste0(save_name, "_", gene_set_list[i], ".rds")
    )
    if (file.exists(rds)) {
      gsva <- readRDS(rds)
    } else {
      gsva <- gsva(comb_mat, gene_sets, min.sz = 10, max.sz = 500)
      saveRDS(gsva, rds)
    }

    # Fit another linear model, this time performing differential pathway analysis on GSVA output.
    fit <- lmFit(gsva, design)
    fit <- eBayes(fit)
    DE_gene_sets <- topTable(
      fit, coef = conditions[2], number = 25, adjust.method = "holm", p.value = 0.05
    )
    print(gene_set_list[i])
    print(DE_gene_sets)

    gsva_cutoff <- gsva[rownames(DE_gene_sets), ]
    names(sample_color_map) <- colnames(gsva_cutoff)
    gene_set_clustering <- hclust(
      as.dist(1 - cor(t(gsva_cutoff), method = "pearson")), method = "complete"
    )
    heatmap(
      gsva_cutoff, ColSideColors = sample_color_map,
      xlab = data_name, margins = c(2, 50),
      col = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100), ylab = gene_set_list[i],
      labRow = rownames(gsva_cutoff), labCol = " ",
      Rowv = as.dendrogram(gene_set_clustering), Colv = NA
    )
    legend("topleft", names(color_legend), fill = color_legend, inset = 0.01, bg = "white")
  }
  fit
}
