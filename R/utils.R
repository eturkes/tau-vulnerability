#    This file is part of tau-vulnerability.
#    Copyright (C) 2019-2020  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

# This file holds common functions and methods.
# ---------------------------------------------

#' ggplot2 function providing custom aesthetics and automatic placement of categorical labels.
#' For continuous data, a colorbar is implemented.
#'
#' @param data SingleCellExperiment or Seurat object.
#' @param x,y Dimensionality reduction coordinates.
#' @param color Column metadata to color points by.
#' @param type \code{"cat"} is categorical, \code{"cont"} is continuous, \code{"NULL"} is generic.
#' @examples
#' red_dim_plot(data = sce, x = "tsne1", y = "tsne2", color = "cluster", type = "cat")
#' red_dim_plot(data = seurat, x = "umap1", y = "umap2", color = "nUMI", type = "cont")
#'
red_dim_plot <- function(data, x, y, color, type = NULL) {

  if ((class(data))[1] == "SingleCellExperiment") {
    gg_df <- data.frame(colData(data)[ , c(x, y, color)])
  } else if ((class(data))[1] == "Seurat") {
    gg_df <- data.frame(data[[x]], data[[y]], data[[color]])
  }
  rownames(gg_df) <- NULL
  gg_df[[color]] <- factor(gg_df[[color]])

  gg <- ggplot(gg_df, aes_string(x = x, y = y, color = color)) +
    geom_point(alpha = 0.35, stroke = 0.05, shape = 21, aes_string(fill = color)) +
    theme_classic() +
    theme(
      legend.position = "right", plot.title = element_text(hjust = 0.5),
      legend.title = element_blank()
    ) +
    guides(color = guide_legend(override.aes = list(alpha = 1)))

  if (is.null(type)) {
    return(gg)

  } else if (type == "cat") {
    label_df <- gg_df %>% group_by_at(color) %>% summarise_at(vars(x:y), median)
    label_df <- cbind(label_df[[1]], label_df)
    names(label_df) <- c("label", color, x, y)
    gg <- gg + geom_label_repel(data = label_df, aes(label = label), show.legend = FALSE)

  } else if (type == "cont") {
    # TODO: Refactor repeated code.
    if ((class(data))[1] == "SingleCellExperiment") {
      gg_df <- data.frame(colData(data)[ , c(x, y, color)])
    } else if ((class(data))[1] == "Seurat") {
      gg_df <- data.frame(data[[x]], data[[y]], data[[color]])
    }
    rownames(gg_df) <- NULL

    gg <- ggplot(gg_df, aes_string(x = x, y = y)) +
      geom_point(alpha = 0.35, stroke = 0.05, aes_string(color = color)) +
      theme_classic() +
      theme(
        legend.position = "right", plot.title = element_text(hjust = 0.5),
        legend.title = element_blank()
      ) +
      scale_color_viridis()
  }
  gg
}

#' Adds download buttons and horizontal scrolling to \code{"DT::datatable"}.
#'
#' @param dt A data.table object.
#' @examples
#' datatable_custom(dt = data_table)
#'
datatable_custom <- function(dt) {

  datatable(
    dt, extensions = "Buttons",
    options = list(
      scrollX = TRUE, dom = "Blfrtip",
      buttons = list(
        "copy", "print",
        list(extend = "collection", buttons = c("csv", "excel", "pdf"), text = "Download")
      )
    )
  )
}

#' Convert human to mouse gene names.
#' Adapted from:
#' https://rjbioinformatics.com/2016/10/14/converting-mouse-to-human-gene-names-with-biomart-package/
#'
#' @param genes A list of human genes.
#' @examples
#' human_to_mouse_genes(genes = gene_list)
#'
human_to_mouse_genes <- function(genes) {

  # Specifying host seems to improve reliability.
  human <- useMart(
    "ensembl", dataset = "hsapiens_gene_ensembl", host = "http://useast.ensembl.org/"
  )
  mouse <- useMart(
    "ensembl", dataset = "mmusculus_gene_ensembl", host = "http://useast.ensembl.org/"
  )

  new_genes <- getLDS(
    attributes = "hgnc_symbol", filters = "hgnc_symbol", values = genes , mart = human,
    attributesL = "mgi_symbol", martL = mouse, uniqueRows = TRUE
  )
  new_genes <- unique(new_genes[ , 2])
}

#' Pipeline for clustering and dimensionality reduction of post-QC scRNA-seq data.
#'
#' @param seurat Post-QC Seurat object.
#' @param assets_dir Directory to save post-processed Seurat object.
#' @param analysis_no Integer to save object to a specific directory within \code{"assets_dir"}.
#' @param sub_name Subset level for naming of cache object.
#' @param organism \code{"human"} for human, \code{"mouse"} for mouse.
#' @param vars_to_regress Vector of nuisance variables to regress out.
#' @param parallel_override See function \code{"parallel_plan"}.
#' @examples
#' cluster_pipeline(
#'   seurat = seurat, assets_dir = assets_dir, analysis_no = 1, sub_name = "neuronal",
#'   organism = "mouse", vars_to_regress = c(batch, "mito_percent"), parallel_override = NULL)
#' )
cluster_pipeline <- function(
  seurat, assets_dir, analysis_no, sub_name, organism, vars_to_regress, parallel_override
) {

  # Utilize a basic caching system.
  rds <- file.path(assets_dir, "cache", paste0("0", analysis_no), paste0(sub_name, "_seurat.rds"))
  if (file.exists(rds)) {
    seurat <- readRDS(rds)
    return(seurat)

  } else {
    # Perform sctransform.
    # Note that this function produces many iterations of the following benign warning:
    # Warning in theta.ml(y = y, mu = fit$fitted): iteration limit reached
    parallel_plan(seurat, parallel_override = parallel_override)
    seurat <- SCTransform(seurat, vars.to.regress = vars_to_regress, verbose = FALSE)

    # Perform cell cycle scoring.
    if (organism == "human") {
      s_genes <- cc.genes.updated.2019$s.genes
      g2m_genes <- cc.genes.updated.2019$g2m.genes
    } else if (organism == "mouse") {
      s_genes <- human_to_mouse_genes(cc.genes.updated.2019$s.genes)
      g2m_genes <- human_to_mouse_genes(cc.genes.updated.2019$g2m.genes)
    }
    seurat <- CellCycleScoring(seurat, s.features = s_genes, g2m.features = g2m_genes)
    seurat$cc_diff <- seurat$S.Score - seurat$G2M.Score # Combined proliferating cell signal.

    # Perform PCA.
    # We also add the output as column metadata for use with `red_dim_plot`.
    seurat <- RunPCA(seurat, verbose = FALSE)
    add_df <- data.frame(Embeddings(seurat, reduction = "pca")[ , 1:2])
    names(add_df) <- paste0("pca", seq(ncol(add_df)))
    seurat$pca1 <- add_df$pca1
    seurat$pca2 <- add_df$pca2

    # Perform UMAP reduction.
    # We also add the output as column metadata for use with `red_dim_plot`.
    seurat <- RunUMAP(seurat, dims = 1:30, min.dist = 0.75, verbose = FALSE)
    add_df <- data.frame(Embeddings(seurat, reduction = "umap"))
    names(add_df) <- paste0("umap", seq(ncol(add_df)))
    seurat$umap1 <- add_df$umap1
    seurat$umap2 <- add_df$umap2

    # Perform Louvain clustering.
    resolution <- (dim(seurat)[2] / 3000) * 0.8 # Default is optimal for 3K cells so we scale it.
    seurat <- FindNeighbors(seurat, dims = 1:30, verbose = FALSE)
    seurat <- FindClusters(seurat, resolution = resolution, verbose = FALSE)

    saveRDS(seurat, rds)
  }
  seurat
}

#' Set the \code{"plan"} for \code{"future"} based on free memory and object size with the option to
#' override.
#'
#' @param object Object to check if \code{"future.globals.maxSize"} large enough to parallelize.
#' @param parallel_override \code{"NULL"} to calculate plan decision, \code{0} for sequential, a
#' non-zero integer for multiprocess and to set \code{"future.globals.maxSize"}.
#' @examples
#' parallel_plan(object = seurat, parallel_override = 5368709120)
#'
parallel_plan <- function(object, parallel_override = NULL) {

  if (is.null(parallel_override)) {
    # Get free memory.
    gc()
    mem <- as.numeric(unlist(strsplit(system("free -b", intern = TRUE)[2], " "))[7])

    # Distribute free memory (minus 10 GiB) across available cores.
    mem <- mem - 10 * 1024 ^ 3
    mem <- mem / detectCores()

    # Enable parallelization only if `object` can fit in `future.globals.maxSize` (plus 1 Gib).
    if (mem > object.size(object) + 1 * 1024 ^ 3) {
      plan("multiprocess")
      options(future.globals.maxSize = mem)
    } else {
      plan("sequential")
    }

  } else if (parallel_override == 0) {
    plan("sequential")

  } else {
    plan("multiprocess")
    options(future.globals.maxSize = parallel_override)
  }
}


#' Plot genes of a Seurat object in various ways.
#'
#' @param subset_list A list containing Seurat objects.
#' @param subset_names A character vector of names for each Seurat object.
#' @param genes A character vector of genes to plot.
#' @examples
#' gene_plot(subset_list = sublist, subset_names = c("seurat1, "seurat2"), genes = c("TBR1, "GAD1))
#'
gene_plot <- function(subset_list, subset_names, genes) {

  for (i in 1:length(subset_list)) {
    print(subset_names[i])

    if (length(genes) == 2 & (all(genes %in% rownames(subset_list[[i]])))) {
      plots <- FeaturePlot(
        subset_list[[i]], features = genes, order = TRUE, blend = TRUE,
        combine = FALSE, blend.threshold = 0, max.cutoff = "q10"
      )
      print(CombinePlots(plots[3:4], legend = "none"))
    } else if (length(which(genes %in% rownames(subset_list[[i]]))) > 1) {
      print(
        FeaturePlot(
          subset_list[[i]], features = genes, order = TRUE,
          cols = c("lightgrey", "red"), max.cutoff = "q10", ncol = 3
        )
      )
    }

    if (length(which(genes %in% rownames(subset_list[[i]]))) > 1) {
      print(DotPlot(subset_list[[i]], features = genes, cols = c("blue", "red")) + RotatedAxis())
      print(
        DoHeatmap(subset_list[[i]], slot = "data", features = genes, size = 3) +
          NoLegend() +
          scale_fill_gradient2(
            low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
            high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
            guide = "colourbar", aesthetics = "fill"
          )
      )
      print(VlnPlot(subset_list[[i]], features = genes, ncol = 1))
    } else {
      print("One or fewer genes present.")
    }
  }
}
