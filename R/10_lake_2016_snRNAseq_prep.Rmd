---
title: "10 Lake 2016 snRNAseq Prep"
author:
  - name: "Emir Turkes [emir.turkes@eturkes.com]"
  - name: "UK Dementia Research Institute at UCL"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
bibliography: "../tau-vulnerability.bib"
biblio-style: apalike
link-citations: true
output:
  html_document:
    code_folding: show
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
knit:
  (function(inputFile, encoding) {
    rmarkdown::render(
      inputFile, encoding = encoding, output_file = "../results/10-lake-2016-snRNAseq-prep.html")})
---

```{r, include = FALSE}
#    This file is part of tau-vulnerability.
#    Copyright (C) 2019  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

knitr::opts_chunk$set(fig.width = 15, fig.height = 13)
```

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
div.main-container {max-width: none; width: 100%;}
</style>

*This file is a part of the [Tau Vulnerability Project](https://github.com/eturkes/tau-vulnerability).*

In this document we apply additional processing on the cleaned dataset derived from the analysis in [github.com/eturkes/lake-2016-snRNAseq](https://github.com/eturkes/lake-2016-snRNAseq).
We start by setting some global variables and loading in any required packages.

```{r}
assets_dir <- file.path(getwd(), "..", "assets")
results_dir <- file.path(getwd(), "..", "results")

packages <- c(
  "conflicted", "SingleCellExperiment", "magrittr", "dplyr", "ggplot2", "ggrepel", "S4Vectors",
  "SummarizedExperiment", "DropletUtils", "scran", "BiocSingular", "scater", "Rtsne", "svd", "SC3",
  "DT", "data.table", "Seurat", "uwot", "viridis", "WGCNA", "pheatmap", "RColorBrewer")
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))

conflict_prefer("which", "BiocGenerics")
options(stringsAsFactors = FALSE)

# Create a unique cache and results data directory for each iterated section.
if (!dir.exists(file.path(assets_dir, "cache", "10"))) {
  dir.create(file.path(assets_dir, "cache", "10"), recursive = TRUE)}
if (!dir.exists(file.path(results_dir, "data", "10"))) {
  dir.create(file.path(results_dir, "data", "10"), recursive = TRUE)}

# ggplot2 function providing custom aesthetics and automatic placement of categorical labels.
# For continuous data, a colorbar is implemented.
dim_red_plot <- function(data, x, y, col, type) {
  gg <- ggplot(data, aes_string(x = x, y = y, color = col)) +
    geom_point(alpha = 0.35, stroke = 0.05, shape = 21, aes_string(fill = col)) +
    theme_classic() +
    theme(
      legend.position = "right", plot.title = element_text(hjust = 0.5),
      legend.title = element_blank()) +
    guides(color = guide_legend(override.aes = list(alpha = 1)))
    if (type == "cat") {
      gg <- gg + geom_label_repel(data = label_df2, aes(label = label), show.legend = FALSE)
    } else if (type == "cont") {
      gg <- ggplot(data, aes_string(x = x, y = y)) +
        geom_point(alpha = 0.35, stroke = 0.05, aes_string(color = col)) +
        theme_classic() +
        theme(
          legend.position = "right", plot.title = element_text(hjust = 0.5),
          legend.title = element_blank()) +
        scale_colour_viridis()}
  gg}

# Adds download buttons.
datatable_custom <- function(dt) {
  datatable(
    dt,
    extensions = "Buttons", options = list(dom = "Blfrtip", buttons = list(
      "copy", "print",
      list(extend = "collection", buttons = c("csv", "excel", "pdf"), text = "Download"))))}
```

# Read in Normalized Data

We do not perform QC as only normalized TPMs were distributed and not raw counts.

```{r}
sce <- readRDS(file.path(assets_dir, "lake-2016-snRNAseq", "sce_orig.rds"))
sce
```

# Dimensionality Reduction

## PPK SVD + UMAP

We calculate a truncated SVD (singular value decomposition) from which PCs can be extracted from it.
In our testing, this approach, particularly the PROPACK implementation, was found to have high power in distinguishing subpopulations of common cell types.

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "10", "ppk.rds")
if (file.exists(rds)) {
  ppk <- readRDS(rds)
} else {
  set.seed(1)
  ppk <- propack.svd(scale(t(as.matrix(logcounts(sce)))), neig = 50)
  saveRDS(ppk, rds)}
```

```{r}
pca <- t(ppk$d * t(ppk$u))
retain_pcs <- 22
retain_pcs
par(mfrow = c(1, 1))
plot(
  log10(ppk$d), xlab = "PC", ylab = "log10(Proportion of Variance Explained)",
  pch = 20, cex = 0.6, col = rgb(0.8, 0.2, 0.2, 0.5))
abline(v = retain_pcs, lty = 2, col = "red")
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "ppk_umap.rds")
if (file.exists(rds)) {
  umap <- readRDS(rds)
} else {
  set.seed(1)
  umap <- umap(pca[ , 1:retain_pcs], min_dist = 0.5)
  saveRDS(umap, rds)}
```

```{r}
reducedDims(sce) <- SimpleList(PCA = pca, UMAP = umap)
add_df <- data.frame(reducedDim(sce, "UMAP"))
names(add_df) <- paste0("ppk_umap", seq(ncol(add_df)))
colData(sce) <- cbind(
  colData(sce), ppk_umap1 = add_df$ppk_umap1, ppk_umap2 = add_df$ppk_umap2)
rm(pca, umap)

# Set up data frame for ggplot2.
gg_df <- data.frame(colData(sce)[ , c("lake_cluster_name", paste0("ppk_umap", 1:2))])
rownames(gg_df) <- NULL
gg_df$lake_cluster_name <- factor(gg_df$lake_cluster_name)

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  lake_cluster_name = levels(gg_df$lake_cluster_name),
  label = levels(gg_df$lake_cluster_name))
label_df2 <- gg_df %>%
  group_by(lake_cluster_name) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2", col = "lake_cluster_name", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Lake Clusters PPK UMAP")
```

## Seurat

Seurat is a nearest neighbor graph clustering method with a `resolution` parameter that indirectly influences the number of clusters generated.
Concerning `resolution`, the authors write:

> setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells.
Optimal resolution often increases for larger datasets.

Our cell count is:

```{r}
dim(sce)[2]
```

Which is close to the amount in the recommendation.
Therefore, we cluster in the range of $\pm 0.2$ from the default resolution of 0.8.

```{r}
resolution <- 0.8
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "seurat_res_minus0.2.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
} else {
  seurat <- as.Seurat(sce, counts = "logcounts", data = NULL)
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  seurat <- ScaleData(seurat, features = rownames(seurat))
  seurat <- FindNeighbors(seurat, reduction = "PCA", dims = 1:retain_pcs)
  seurat <- FindClusters(seurat, resolution = resolution - 0.2)
  saveRDS(seurat, rds)}
```

```{r}
gg_df$seurat_clusters_res_minus0.2 <- seurat$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_clusters_res_minus0.2 = levels(gg_df$seurat_clusters_res_minus0.2),
  label = levels(gg_df$seurat_clusters_res_minus0.2))
label_df2 <- gg_df %>%
  group_by(seurat_clusters_res_minus0.2) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2",
  col = "seurat_clusters_res_minus0.2", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Seurat 0.6 Resolution Clusters PPK UMAP")
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "seurat_res_minus0.1.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
} else {
  seurat <- as.Seurat(sce, counts = "logcounts", data = NULL)
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  seurat <- ScaleData(seurat, features = rownames(seurat))
  seurat <- FindNeighbors(seurat, reduction = "PCA", dims = 1:retain_pcs)
  seurat <- FindClusters(seurat, resolution = resolution - 0.1)
  saveRDS(seurat, rds)}
```

```{r}
gg_df$seurat_clusters_res_minus0.1 <- seurat$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_clusters_res_minus0.1 = levels(gg_df$seurat_clusters_res_minus0.1),
  label = levels(gg_df$seurat_clusters_res_minus0.1))
label_df2 <- gg_df %>%
  group_by(seurat_clusters_res_minus0.1) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2",
  col = "seurat_clusters_res_minus0.1", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Seurat 0.7 Resolution Clusters PPK UMAP")
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "seurat_res.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
} else {
  seurat <- as.Seurat(sce, counts = "logcounts", data = NULL)
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  seurat <- ScaleData(seurat, features = rownames(seurat))
  seurat <- FindNeighbors(seurat, reduction = "PCA", dims = 1:retain_pcs)
  seurat <- FindClusters(seurat, resolution = resolution)
  saveRDS(seurat, rds)}
```

```{r}
gg_df$seurat_clusters_res <- seurat$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_clusters_res = levels(gg_df$seurat_clusters_res), label = levels(gg_df$seurat_clusters_res))
label_df2 <- gg_df %>%
  group_by(seurat_clusters_res) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2", col = "seurat_clusters_res", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Seurat 0.8 Resolution Clusters PPK UMAP")
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "seurat_res_plus0.1.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
} else {
  seurat <- as.Seurat(sce, counts = "logcounts", data = NULL)
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  seurat <- ScaleData(seurat, features = rownames(seurat))
  seurat <- FindNeighbors(seurat, reduction = "PCA", dims = 1:retain_pcs)
  seurat <- FindClusters(seurat, resolution = resolution + 0.1)
  saveRDS(seurat, rds)}
```

```{r}
gg_df$seurat_clusters_res_plus0.1 <- seurat$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_clusters_res_plus0.1 = levels(gg_df$seurat_clusters_res_plus0.1),
  label = levels(gg_df$seurat_clusters_res_plus0.1))
label_df2 <- gg_df %>%
  group_by(seurat_clusters_res_plus0.1) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2",
  col = "seurat_clusters_res_plus0.1", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Seurat 0.9 Resolution Clusters PPK UMAP")
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "seurat_res_plus0.2.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
} else {
  seurat <- as.Seurat(sce, counts = "logcounts", data = NULL)
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  seurat <- ScaleData(seurat, features = rownames(seurat))
  seurat <- FindNeighbors(seurat, reduction = "PCA", dims = 1:retain_pcs)
  seurat <- FindClusters(seurat, resolution = resolution + 0.2)
  saveRDS(seurat, rds)}
```

```{r}
gg_df$seurat_clusters_res_plus0.2 <- seurat$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_clusters_res_plus0.2 = levels(gg_df$seurat_clusters_res_plus0.2),
  label = levels(gg_df$seurat_clusters_res_plus0.2))
label_df2 <- gg_df %>%
  group_by(seurat_clusters_res_plus0.2) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2",
  col = "seurat_clusters_res_plus0.2", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Seurat 1.0 Resolution Clusters PPK UMAP")
```

As the data appears somewhat underclustered regarding inhibitory neurons, we try clustering at `resolution * 2` using the same range as before.

```{r}
resolution <- 0.8 * 2
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "seurat_res2x_minus0.2.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
} else {
  seurat <- as.Seurat(sce, counts = "logcounts", data = NULL)
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  seurat <- ScaleData(seurat, features = rownames(seurat))
  seurat <- FindNeighbors(seurat, reduction = "PCA", dims = 1:retain_pcs)
  seurat <- FindClusters(seurat, resolution = resolution - 0.2)
  saveRDS(seurat, rds)}
```

```{r}
gg_df$seurat_clusters_res_minus0.2 <- seurat$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_clusters_res_minus0.2 = levels(gg_df$seurat_clusters_res_minus0.2),
  label = levels(gg_df$seurat_clusters_res_minus0.2))
label_df2 <- gg_df %>%
  group_by(seurat_clusters_res_minus0.2) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2",
  col = "seurat_clusters_res_minus0.2", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Seurat 1.4 Resolution Clusters PPK UMAP")
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "seurat_res2x_minus0.1.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
} else {
  seurat <- as.Seurat(sce, counts = "logcounts", data = NULL)
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  seurat <- ScaleData(seurat, features = rownames(seurat))
  seurat <- FindNeighbors(seurat, reduction = "PCA", dims = 1:retain_pcs)
  seurat <- FindClusters(seurat, resolution = resolution - 0.1)
  saveRDS(seurat, rds)}
```

```{r}
gg_df$seurat_clusters_res_minus0.1 <- seurat$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_clusters_res_minus0.1 = levels(gg_df$seurat_clusters_res_minus0.1),
  label = levels(gg_df$seurat_clusters_res_minus0.1))
label_df2 <- gg_df %>%
  group_by(seurat_clusters_res_minus0.1) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2",
  col = "seurat_clusters_res_minus0.1", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Seurat 1.5 Resolution Clusters PPK UMAP")
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "seurat_res2x.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
} else {
  seurat <- as.Seurat(sce, counts = "logcounts", data = NULL)
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  seurat <- ScaleData(seurat, features = rownames(seurat))
  seurat <- FindNeighbors(seurat, reduction = "PCA", dims = 1:retain_pcs)
  seurat <- FindClusters(seurat, resolution = resolution)
  saveRDS(seurat, rds)}
```

```{r}
gg_df$seurat_clusters_res <- seurat$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_clusters_res = levels(gg_df$seurat_clusters_res), label = levels(gg_df$seurat_clusters_res))
label_df2 <- gg_df %>%
  group_by(seurat_clusters_res) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2", col = "seurat_clusters_res", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Seurat 1.6 Resolution Clusters PPK UMAP")
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "seurat_res2x_plus0.1.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
} else {
  seurat <- as.Seurat(sce, counts = "logcounts", data = NULL)
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  seurat <- ScaleData(seurat, features = rownames(seurat))
  seurat <- FindNeighbors(seurat, reduction = "PCA", dims = 1:retain_pcs)
  seurat <- FindClusters(seurat, resolution = resolution + 0.1)
  saveRDS(seurat, rds)}
```

```{r}
gg_df$seurat_clusters_res_plus0.1 <- seurat$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_clusters_res_plus0.1 = levels(gg_df$seurat_clusters_res_plus0.1),
  label = levels(gg_df$seurat_clusters_res_plus0.1))
label_df2 <- gg_df %>%
  group_by(seurat_clusters_res_plus0.1) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2",
  col = "seurat_clusters_res_plus0.1", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Seurat 1.7 Resolution Clusters PPK UMAP")
```

```{r}
rds <- file.path(assets_dir, "cache", "10", "seurat_res2x_plus0.2.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
} else {
  seurat <- as.Seurat(sce, counts = "logcounts", data = NULL)
  seurat <- FindVariableFeatures(seurat, selection.method = "vst", nfeatures = 2000)
  seurat <- ScaleData(seurat, features = rownames(seurat))
  seurat <- FindNeighbors(seurat, reduction = "PCA", dims = 1:retain_pcs)
  seurat <- FindClusters(seurat, resolution = resolution + 0.2)
  saveRDS(seurat, rds)}
```

```{r}
gg_df$seurat_clusters_res_plus0.2 <- seurat$seurat_clusters

# Setup for automatic placement of cluster labels.
label_df <- data.frame(
  seurat_clusters_res_plus0.2 = levels(gg_df$seurat_clusters_res_plus0.2),
  label = levels(gg_df$seurat_clusters_res_plus0.2))
label_df2 <- gg_df %>%
  group_by(seurat_clusters_res_plus0.2) %>%
  summarize(ppk_umap1 = median(ppk_umap1), ppk_umap2 = median(ppk_umap2)) %>%
  left_join(label_df)

dim_red_plot(
  data = gg_df, x = "ppk_umap1", y = "ppk_umap2",
  col = "seurat_clusters_res_plus0.2", type = "cat") +
  xlab("UMAP 1") + ylab("UMAP 2") + ggtitle("Seurat 1.8 Resolution Clusters PPK UMAP")
```

We find that increasing resolution does not add additional inhibitory clusters.
We also find that across resolution values, the results appear reasonable.
For now, we select 0.8 resolution, as that is the default value.

# Seurat DEG

```{r}
seurat <- readRDS(file.path(assets_dir, "cache", "10", "seurat_res.rds"))
seurat
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "10", "seurat_markers_res.rds")
if (file.exists(rds)) {
  seurat_markers <- readRDS(rds)
} else {
  seurat_markers <- FindAllMarkers(seurat, only.pos = TRUE)
  saveRDS(seurat_markers, rds)}
```

```{r}
top <- seurat_markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_logFC)
DoHeatmap(seurat, features = top$gene, size = 3) +
  NoLegend() + scale_fill_gradientn(colors = c("blue", "white", "red"))

top <- seurat_markers %>% group_by(cluster) %>% top_n(n = 1, wt = avg_logFC)
datatable_custom(top)
VlnPlot(seurat, features = top$gene[1:8], ncol = 3)
VlnPlot(seurat, features = top$gene[9:16], ncol = 3)
FeaturePlot(
  seurat, reduction = "UMAP", features = top$gene[1:8], order = TRUE,
  cols = c("lightgrey", "red"), max.cutoff = 20, ncol = 3)
FeaturePlot(
  seurat, reduction = "UMAP", features = top$gene[9:16], order = TRUE,
  cols = c("lightgrey", "red"), max.cutoff = 20, ncol = 3)
DotPlot(seurat, features = top$gene, cols = c("blue", "red")) + RotatedAxis()

datatable_custom(seurat_markers %>% group_by(cluster) %>% top_n(n = 30, wt = avg_logFC))
```

```{r, cache = TRUE}
rds <- file.path(assets_dir, "cache", "10", "seurat_markers_res_updown.rds")
if (file.exists(rds)) {
  seurat_markers <- readRDS(rds)
} else {
  seurat_markers <- FindAllMarkers(seurat)
  saveRDS(seurat_markers, rds)}
```

```{r}
top <- seurat_markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_logFC)
DoHeatmap(seurat, features = top$gene, size = 3) +
  NoLegend() + scale_fill_gradientn(colors = c("blue", "white", "red"))

top <- seurat_markers %>% group_by(cluster) %>% top_n(n = 1, wt = avg_logFC)
datatable_custom(top)
VlnPlot(seurat, features = top$gene[1:8], ncol = 3)
VlnPlot(seurat, features = top$gene[9:16], ncol = 3)
FeaturePlot(
  seurat, reduction = "UMAP", features = top$gene[1:8], order = TRUE,
  cols = c("lightgrey", "red"), max.cutoff = 20, ncol = 3)
FeaturePlot(
  seurat, reduction = "UMAP", features = top$gene[9:16], order = TRUE,
  cols = c("lightgrey", "red"), max.cutoff = 20, ncol = 3)
DotPlot(seurat, features = top$gene, cols = c("blue", "red")) + RotatedAxis()

datatable_custom(seurat_markers %>% group_by(cluster) %>% top_n(n = 30, wt = avg_logFC))
```

# IHC Genes

Next, we examine the expression of a set genes for which we have antibodies to conduct immunohistochemistry.
Due to the removal of some genes from QC and the HVG section, we create a new Seurat object with minimal processing but with HVG metadata.

```{r}
seurat <- readRDS(file.path(assets_dir, "cache", "10", "seurat_res.rds"))
seurat
```

```{r}
genes <- c("TBR1", "SATB2", "SATB1", "WFS1", "GAD1", "CALB1", "SST", "PVALB", "CALB2")
DoHeatmap(seurat, slot = "data", features = genes, size = 3) +
  NoLegend() +
  scale_fill_gradient2(
    low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
    high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
    guide = "colourbar", aesthetics = "fill")
VlnPlot(seurat, features = genes, ncol = 3)
FeaturePlot(
  seurat, reduction = "UMAP", features = genes, order = TRUE,
  cols = c("lightgrey", "red"), max.cutoff = 20, ncol = 3)
DotPlot(seurat, features = genes, cols = c("blue", "red")) + RotatedAxis()
```

# References

This is the concluding section of the document. Here we write relevant results to disk, output the `sessionInfo`, and create a bibliography for works cited.

```{r}
sessionInfo()
```
