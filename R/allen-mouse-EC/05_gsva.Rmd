---
title: '05 GSVA - `r unlist(strsplit(getwd(), "/"))[6]`'
author:
  - name: "Emir Turkes [emir.turkes@eturkes.com]"
  - name: "UK Dementia Research Institute at UCL"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
bibliography: '../../`r unlist(strsplit(getwd(), "/"))[4]`.bib'
link-citations: true
output:
  html_document:
    code_folding: hide
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(
    "..", "..", "results", unlist(strsplit(getwd(), "/"))[6], "05-gsva.html"
  ))})
---

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
div.main-container {max-width: none; width: 100%;}
</style>

*This file is a part of the [Tau Vulnerability Project](https://github.com/eturkes/tau-vulnerability).*

In this document we perform GSVA analysis.
The data here is derived from @`r unlist(strsplit(getwd(), "/"))[6]` and will be referenced using the name `r unlist(strsplit(getwd(), "/"))[6]`.

```{r, boilerplate}
# Load in necessary boilerplate and libraries.
# --------------------------------------------

#    This file is part of tau-vulnerability.
#    Copyright (C) 2019-2020  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

# These should be checked per document.
# -------------------------------------

packages <- c(
  "conflicted", "Seurat", "dplyr", "ggplot2", "ggrepel",
  "biomaRt", "SCnorm", "SingleCellExperiment", "GSEABase", "limma",
  "GSVA", "RColorBrewer", "parallel", "DT", "pheatmap"
)
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))
source(file.path(getwd(), "..", "utils.R"))

analysis_no <- 5
organism <- "mouse"
batch_metadata <- "donor_id"
vars_to_regress <- c("age_label", "sex_label")
parallel_override <- NULL # See function `parallel_plan` in `utils.R`.
subset_names <- c("ENT_neuronal", "HIP_neuronal", "ENT_HIP_neuronal")
download_name <- "smrt" # Name of download file corresponding to dataset.
color <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
color[50] <- "#DDDDDD"
options(stringsAsFactors = FALSE)
knitr::opts_chunk$set(fig.width = 10, fig.height = 10)

# Everything else in this chunk remains generally unchanged.
# ----------------------------------------------------------

data_name <- unlist(strsplit(getwd(), "/"))[6] # Name of dataset.
assets_dir <- file.path(getwd(), "..", "..", "assets", data_name) # Backed up caches and data.
tmp_dir <- file.path(getwd(), "..", "..", "tmp", data_name)
results_dir <- file.path(getwd(), "..", "..", "results", data_name)

if (!dir.exists(tmp_dir)) {
  dir.create(tmp_dir, recursive = TRUE)
}

# Unique cache directory for each analysis number.
if (!dir.exists(file.path(assets_dir, "cache", paste0("0", analysis_no)))) {
  dir.create(file.path(assets_dir, "cache", paste0("0", analysis_no)), recursive = TRUE)
}
```

We use data saved from previous analyses.

```{r}
# TODO: Make chunk loopable.
# --------------------------

seurat_orig <- readRDS(
  file.path(
    assets_dir, "cache", paste0("0", analysis_no - 3), paste0(subset_names[1], "_seurat.rds")
  )
)
DefaultAssay(seurat_orig) <- "RNA"
seurat_orig[["SCT"]] <- NULL
seurat_orig
red_dim_plot(seurat_orig, x = "umap1", y = "umap2", color = "seurat_clusters", type = "cat")

# Filter down to genes in gene set to be analyzed.
# TODO: Remove hardcoding and make flexible for more gene sets.
gene_sets <- getGmt(file.path(assets_dir, "..", "gene-sets", "GO_BP_AD_filt_mouse.gmt"))
seurat_orig <- seurat_orig[rownames(seurat_orig) %in% unique(unlist(geneIds(gene_sets))), ]
```

Comparisons Against Early Affected EC L2 EX

## Late Affected EC L6 EX

```{r}
# This chunk typically needs to be edited per dataset.
# ----------------------------------------------------

seurat <- seurat_orig
sub <- vector(mode = "list", length = 2)
sub[[1]] <- 2
sub[[2]] <- 6
conditions <- c("Late Affected EC L6 EX", "Early Affected EC L2 EX")
save_name <- "late_EC_L6_EX_vs_early_EC_L2_EX"
gene_set_list <- "GO_BP_AD_filt"
```

```{r}
# Save `lmFit` result for pooled analysis.
# TODO: Remove hardcoding.
comb3 <- gsva_pipeline(
  seurat, assets_dir = assets_dir, analysis_no = analysis_no,
  save_name = save_name, data_name = data_name, organism = organism,
  conditions = conditions, sub = sub, gene_set_list = gene_set_list
)
```

## Late Affected EC L3 EX

```{r}
# This chunk typically needs to be edited per dataset.
# ----------------------------------------------------

seurat <- seurat_orig
sub <- vector(mode = "list", length = 2)
sub[[1]] <- 14
sub[[2]] <- 6
conditions <- c("Late Affected EC L3 EX", "Early Affected EC L2 EX")
save_name <- "late_EC_L3_EX_vs_early_EC_L2_EX"
gene_set_list <- "GO_BP_AD_filt"
```

```{r}
# Save `lmFit` result for pooled analysis.
# TODO: Remove hardcoding.
comb2 <- gsva_pipeline(
  seurat, assets_dir = assets_dir, analysis_no = analysis_no,
  save_name = save_name, data_name = data_name, organism = organism,
  conditions = conditions, sub = sub, gene_set_list = gene_set_list
)
```

## Later Affected EC L2 EX

```{r}
# This chunk typically needs to be edited per dataset.
# ----------------------------------------------------

seurat <- seurat_orig
sub <- vector(mode = "list", length = 2)
sub[[1]] <- 10
sub[[2]] <- 6
conditions <- c("Later Affected EC L2 EX", "Early Affected EC L2 EX")
save_name <- "later_EC_L2_EX_vs_early_EC_L2_EX"
gene_set_list <- "GO_BP_AD_filt"
```

```{r}
# Save `lmFit` result for pooled analysis.
# TODO: Remove hardcoding.
comb1 <- gsva_pipeline(
  seurat, assets_dir = assets_dir, analysis_no = analysis_no,
  save_name = save_name, data_name = data_name, organism = organism,
  conditions = conditions, sub = sub, gene_set_list = gene_set_list
)
```

## Non Affected EC IN

```{r}
# This chunk typically needs to be edited per dataset.
# ----------------------------------------------------

seurat <- seurat_orig
sub <- vector(mode = "list", length = 2)
sub[[1]] <- c(8, 11, 13, 19, 23, 12, 3, 22, 18)
sub[[2]] <- 6
conditions <- c("Non Affected EC IN", "Early Affected EC L2 EX")
save_name <- "non_EC_IN_vs_early_EC_L2_EX"
gene_set_list <- "GO_BP_AD_filt"
```

```{r}
# Save `lmFit` result for pooled analysis.
# TODO: Remove hardcoding.
comb8 <- gsva_pipeline(
  seurat, assets_dir = assets_dir, analysis_no = analysis_no,
  save_name = save_name, data_name = data_name, organism = organism,
  conditions = conditions, sub = sub, gene_set_list = gene_set_list
)
```

## Late Affected CA3 EX

```{r}
# This chunk typically needs to be edited per dataset.
# ----------------------------------------------------

seurat <- seurat_orig
sub <- vector(mode = "list", length = 2)
sub[[1]] <- 15
sub[[2]] <- 14
conditions <- c("Late Affected CA3 EX", "Early Affected EC L2 EX")
save_name <- "CA3_EX_vs_EC_L2_EX"
gene_set_list <- "GO_BP_AD_filt"
```

```{r}
# Save `lmFit` result for pooled analysis.
# TODO: Remove hardcoding.
comb6 <- gsva_pipeline(
  seurat, assets_dir = assets_dir, analysis_no = analysis_no,
  save_name = save_name, data_name = data_name, organism = organism,
  conditions = conditions, sub = sub, gene_set_list = gene_set_list
)
```

## Late Affected DG EX

```{r}
# This chunk typically needs to be edited per dataset.
# ----------------------------------------------------

seurat <- seurat_orig
sub <- vector(mode = "list", length = 2)
sub[[1]] <- 16
sub[[2]] <- 14
conditions <- c("Late Affected DG EX", "Early Affected EC L2 EX")
save_name <- "DG_EX_vs_EC_L2_EX"
gene_set_list <- "GO_BP_AD_filt"
```

```{r}
# Save `lmFit` result for pooled analysis.
# TODO: Remove hardcoding.
comb7 <- gsva_pipeline(
  seurat, assets_dir = assets_dir, analysis_no = analysis_no,
  save_name = save_name, data_name = data_name, organism = organism,
  conditions = conditions, sub = sub, gene_set_list = gene_set_list
)
```

## Later Affected CA1 EX

```{r}
# This chunk typically needs to be edited per dataset.
# ----------------------------------------------------

seurat <- seurat_orig
sub <- vector(mode = "list", length = 2)
sub[[1]] <- 0
sub[[2]] <- 14
conditions <- c("Later Affected CA1 EX", "Early Affected EC L2 EX")
save_name <- "CA1_EX_vs_EC_L2_EX"
gene_set_list <- "GO_BP_AD_filt"
```

```{r}
# Save `lmFit` result for pooled analysis.
# TODO: Remove hardcoding.
comb4 <- gsva_pipeline(
  seurat, assets_dir = assets_dir, analysis_no = analysis_no,
  save_name = save_name, data_name = data_name, organism = organism,
  conditions = conditions, sub = sub, gene_set_list = gene_set_list
)
```

## Late Affected SUB EX

```{r}
# This chunk typically needs to be edited per dataset.
# ----------------------------------------------------

seurat <- seurat_orig
sub <- vector(mode = "list", length = 2)
sub[[1]] <- 3
sub[[2]] <- 14
conditions <- c("Late Affected SUB EX", "Early Affected EC L2 EX")
save_name <- "sub_EX_vs_EC_L2_EX"
gene_set_list <- "GO_BP_AD_filt"
```

```{r}
# Save `lmFit` result for pooled analysis.
# TODO: Remove hardcoding.
comb5 <- gsva_pipeline(
  seurat, assets_dir = assets_dir, analysis_no = analysis_no,
  save_name = save_name, data_name = data_name, organism = organism,
  conditions = conditions, sub = sub, gene_set_list = gene_set_list
)
```

# Combined

```{r}
coef <- "Early Affected EC L2 EX"
names <- c(
  "ENT L2 EX", "ENT L3 EX", "ENT L6 EX", "HIP CA1", "HIP SUB", "HIP CA3", "HIP DG", "ENT IN"
)
```

```{r}
# TODO: Reduce repetition.
# ------------------------

pval <- 1e-2
sets <- list(
  topTable(comb1, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb2, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb3, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb4, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb5, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb6, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb7, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb8, number = Inf, coef = coef, adjust.method = "holm", p.value = pval)
)
sets <- lapply(sets, function(x) cbind(x , rownames(x)))
sets <- lapply(sets, function(x) x[ , c(dim(x)[2], 1)])
colnames(sets[[1]])[2] <- names[1]
colnames(sets[[2]])[2] <- names[2]
colnames(sets[[3]])[2] <- names[3]
colnames(sets[[4]])[2] <- names[4]
colnames(sets[[5]])[2] <- names[5]
colnames(sets[[6]])[2] <- names[6]
colnames(sets[[7]])[2] <- names[7]
colnames(sets[[8]])[2] <- names[8]
merged_set <- Reduce(function(...) merge(..., all = TRUE), list(
  sets[[1]][ , c(1, 2)], sets[[2]][ , c(1, 2)], sets[[3]][ , c(1, 2)], sets[[4]][ , c(1, 2)], sets[[5]][ , c(1, 2)], sets[[6]][ , c(1, 2)], sets[[7]][ , c(1, 2)], sets[[8]][ , c(1, 2)]
))

set1 <- merged_set[order(-abs(merged_set[[names[1]]])), ]
set2 <- merged_set[order(-abs(merged_set[[names[2]]])), ]
set3 <- merged_set[order(-abs(merged_set[[names[3]]])), ]
set4 <- merged_set[order(-abs(merged_set[[names[4]]])), ]
set5 <- merged_set[order(-abs(merged_set[[names[5]]])), ]
set6 <- merged_set[order(-abs(merged_set[[names[6]]])), ]
set7 <- merged_set[order(-abs(merged_set[[names[7]]])), ]
set8 <- merged_set[order(-abs(merged_set[[names[8]]])), ]

merged_top <- Reduce(function(...) merge(..., all = TRUE), list(
  set1[ , c(1, 2)], set2[ , c(1, 3)], set3[ , c(1, 4)], set4[ , c(1, 5)], set5[ , c(1, 6)], set6[ , c(1, 7)], set7[ , c(1, 8)], set8[ , c(1, 9)]
))
top_genes <- merged_top$`rownames(x)`
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_custom(merged_top) %>%
  formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate `NA` values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 10, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 4
)

# Generate heatmap without `NA` values.
merged_top[merged_top == 0] <- NA
merged_top <- merged_top[complete.cases(merged_top), ]
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 9, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 9
)
```

```{r}
# TODO: Reduce repetition.
# ------------------------

pval <- 1e-25
sets <- list(
  topTable(comb4, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb5, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb6, number = Inf, coef = coef, adjust.method = "holm", p.value = pval)
)
sets <- lapply(sets, function(x) cbind(x , rownames(x)))
sets <- lapply(sets, function(x) x[ , c(dim(x)[2], 1)])
colnames(sets[[1]])[2] <- names[4]
colnames(sets[[2]])[2] <- names[5]
colnames(sets[[3]])[2] <- names[6]
merged_set <- Reduce(function(...) merge(..., all = TRUE), list(
  sets[[1]][ , c(1, 2)], sets[[2]][ , c(1, 2)], sets[[3]][ , c(1, 2)]
))

set4 <- merged_set[order(-abs(merged_set[[names[4]]])), ]
set5 <- merged_set[order(-abs(merged_set[[names[5]]])), ]
set6 <- merged_set[order(-abs(merged_set[[names[6]]])), ]

merged_top <- Reduce(function(...) merge(..., all = TRUE), list(
  set4[ , c(1, 2)], set5[ , c(1, 3)], set6[ , c(1, 4)]
))
top_genes <- merged_top$`rownames(x)`
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_custom(merged_top) %>%
  formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate `NA` values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 10, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 4
)

# Generate heatmap without `NA` values.
merged_top[merged_top == 0] <- NA
merged_top <- merged_top[complete.cases(merged_top), ]
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 9, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 9
)
```

```{r}
# TODO: Reduce repetition.
# ------------------------

pval <- 1e-5
sets <- list(
  topTable(comb3, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb4, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb5, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb6, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb7, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb8, number = Inf, coef = coef, adjust.method = "holm", p.value = pval)
)
sets <- lapply(sets, function(x) cbind(x , rownames(x)))
sets <- lapply(sets, function(x) x[ , c(dim(x)[2], 1)])
colnames(sets[[1]])[2] <- names[3]
colnames(sets[[2]])[2] <- names[4]
colnames(sets[[3]])[2] <- names[5]
colnames(sets[[4]])[2] <- names[6]
colnames(sets[[5]])[2] <- names[7]
colnames(sets[[6]])[2] <- names[8]
merged_set <- Reduce(function(...) merge(..., all = TRUE), list(
  sets[[1]][ , c(1, 2)], sets[[2]][ , c(1, 2)], sets[[3]][ , c(1, 2)], sets[[4]][ , c(1, 2)], sets[[5]][ , c(1, 2)], sets[[6]][ , c(1, 2)]
))

set3 <- merged_set[order(-abs(merged_set[[names[3]]])), ]
set4 <- merged_set[order(-abs(merged_set[[names[4]]])), ]
set5 <- merged_set[order(-abs(merged_set[[names[5]]])), ]
set6 <- merged_set[order(-abs(merged_set[[names[6]]])), ]
set7 <- merged_set[order(-abs(merged_set[[names[7]]])), ]
set8 <- merged_set[order(-abs(merged_set[[names[8]]])), ]

merged_top <- Reduce(function(...) merge(..., all = TRUE), list(
  set3[ , c(1, 2)], set4[ , c(1, 3)], set5[ , c(1, 4)], set6[ , c(1, 5)], set7[ , c(1, 6)], set8[ , c(1, 7)]
))
top_genes <- merged_top$`rownames(x)`
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_custom(merged_top) %>%
  formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate `NA` values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 10, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 4
)

# Generate heatmap without `NA` values.
merged_top[merged_top == 0] <- NA
merged_top <- merged_top[complete.cases(merged_top), ]
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 9, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 9
)
```

```{r}
# TODO: Reduce repetition.
# ------------------------

pval <- 1e-7
sets <- list(
  topTable(comb3, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb4, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb5, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb6, number = Inf, coef = coef, adjust.method = "holm", p.value = pval)
)
sets <- lapply(sets, function(x) cbind(x , rownames(x)))
sets <- lapply(sets, function(x) x[ , c(dim(x)[2], 1)])
colnames(sets[[1]])[2] <- names[3]
colnames(sets[[2]])[2] <- names[4]
colnames(sets[[3]])[2] <- names[5]
colnames(sets[[4]])[2] <- names[6]
merged_set <- Reduce(function(...) merge(..., all = TRUE), list(
  sets[[1]][ , c(1, 2)], sets[[2]][ , c(1, 2)], sets[[3]][ , c(1, 2)], sets[[4]][ , c(1, 2)]
))

set3 <- merged_set[order(-abs(merged_set[[names[3]]])), ]
set4 <- merged_set[order(-abs(merged_set[[names[4]]])), ]
set5 <- merged_set[order(-abs(merged_set[[names[5]]])), ]
set6 <- merged_set[order(-abs(merged_set[[names[6]]])), ]

merged_top <- Reduce(function(...) merge(..., all = TRUE), list(
  set3[ , c(1, 2)], set4[ , c(1, 3)], set5[ , c(1, 4)], set6[ , c(1, 5)]
))
top_genes <- merged_top$`rownames(x)`
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_custom(merged_top) %>%
  formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate `NA` values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 10, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 4
)

# Generate heatmap without `NA` values.
merged_top[merged_top == 0] <- NA
merged_top <- merged_top[complete.cases(merged_top), ]
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 9, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 9
)
```

```{r}
# TODO: Reduce repetition.
# ------------------------

pval <- 1e-2
sets <- list(
    topTable(comb2, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb3, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb4, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb5, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb6, number = Inf, coef = coef, adjust.method = "holm", p.value = pval)
)
sets <- lapply(sets, function(x) cbind(x , rownames(x)))
sets <- lapply(sets, function(x) x[ , c(dim(x)[2], 1)])
colnames(sets[[1]])[2] <- names[2]
colnames(sets[[2]])[2] <- names[3]
colnames(sets[[3]])[2] <- names[4]
colnames(sets[[4]])[2] <- names[5]
colnames(sets[[5]])[2] <- names[6]
merged_set <- Reduce(function(...) merge(..., all = TRUE), list(
  sets[[1]][ , c(1, 2)], sets[[2]][ , c(1, 2)], sets[[3]][ , c(1, 2)], sets[[4]][ , c(1, 2)], sets[[5]][ , c(1, 2)]
))

set2 <- merged_set[order(-abs(merged_set[[names[2]]])), ]
set3 <- merged_set[order(-abs(merged_set[[names[3]]])), ]
set4 <- merged_set[order(-abs(merged_set[[names[4]]])), ]
set5 <- merged_set[order(-abs(merged_set[[names[5]]])), ]
set6 <- merged_set[order(-abs(merged_set[[names[6]]])), ]

merged_top <- Reduce(function(...) merge(..., all = TRUE), list(
  set2[ , c(1, 2)], set3[ , c(1, 3)], set4[ , c(1, 4)], set5[ , c(1, 5)], set6[ , c(1, 6)]
))
top_genes <- merged_top$`rownames(x)`
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_custom(merged_top) %>%
  formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate `NA` values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 10, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 4
)

# Generate heatmap without `NA` values.
merged_top[merged_top == 0] <- NA
merged_top <- merged_top[complete.cases(merged_top), ]
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 9, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 9
)
```

```{r}
# TODO: Reduce repetition.
# ------------------------

pval <- 1e-2
sets <- list(
  topTable(comb1, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb2, number = Inf, coef = coef, adjust.method = "holm", p.value = pval),
  topTable(comb3, number = Inf, coef = coef, adjust.method = "holm", p.value = pval)
)
sets <- lapply(sets, function(x) cbind(x , rownames(x)))
sets <- lapply(sets, function(x) x[ , c(dim(x)[2], 1)])
colnames(sets[[1]])[2] <- names[1]
colnames(sets[[2]])[2] <- names[2]
colnames(sets[[3]])[2] <- names[3]
merged_set <- Reduce(function(...) merge(..., all = TRUE), list(
  sets[[1]][ , c(1, 2)], sets[[2]][ , c(1, 2)], sets[[3]][ , c(1, 2)]
))

set1 <- merged_set[order(-abs(merged_set[[names[1]]])), ]
set2 <- merged_set[order(-abs(merged_set[[names[2]]])), ]
set3 <- merged_set[order(-abs(merged_set[[names[3]]])), ]

merged_top <- Reduce(function(...) merge(..., all = TRUE), list(
  set1[ , c(1, 2)], set2[ , c(1, 3)], set3[ , c(1, 4)]))
top_genes <- merged_top$`rownames(x)`
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_custom(merged_top) %>%
  formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate `NA` values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 10, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 4
)

# Generate heatmap without `NA` values.
merged_top[merged_top == 0] <- NA
merged_top <- merged_top[complete.cases(merged_top), ]
breaks <- c(
  seq(min(merged_top), -0.001, by = abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), by = abs(max(merged_top)) / 50)
)
pheatmap(
  merged_top, angle_col = 0, fontsize = 9, color = color,
  cluster_cols = FALSE, breaks = breaks, fontsize_row = 9
)
```

# References

This is the concluding section of the document. Here we write relevant results to disk, output the `sessionInfo`, and create a bibliography for works cited.

```{r, references}
sessionInfo()
```
