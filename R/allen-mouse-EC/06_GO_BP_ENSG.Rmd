---
title: '06 GO BP ENSG - `r unlist(strsplit(getwd(), "/"))[6]`'
author:
  - name: "Emir Turkes [emir.turkes@eturkes.com]"
  - name: "UK Dementia Research Institute at UCL"
date: '`r strftime(Sys.time(), "%B %d, %Y")`'
bibliography: '../../`r unlist(strsplit(getwd(), "/"))[4]`.bib'
link-citations: true
output:
  html_document:
    code_folding: hide
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(
    "..", "..", "results", unlist(strsplit(getwd(), "/"))[6], "06-GO-BP-ENSG.html"
  ))})
---

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
.tocify-subheader .tocify-subheader .tocify-item {
  font-size: 0.95em; padding-left: 35px; text-indent: 0;
}
div.main-container {max-width: none; width: 100%;}
</style>

*This file is a part of the [Tau Vulnerability Project](https://github.com/eturkes/tau-vulnerability).*

In this document we perform GSVA analysis.
The data here is derived from @`r unlist(strsplit(getwd(), "/"))[6]` and will be referenced using the name `r unlist(strsplit(getwd(), "/"))[6]`.

```{r}
#    This file is part of tau-vulnerability.
#    Copyright (C) 2019-2020  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

# These should be checked per document.
# -------------------------------------
options(stringsAsFactors = FALSE)
packages <- c(
  "conflicted", "Seurat", "dplyr", "ggplot2", "ggrepel", "biomaRt", "Biostrings",
  "SCnorm", "SingleCellExperiment", "GSEABase", "limma", "viridis", "GSVA", "DT"
)
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))
conflict_prefer("strsplit", "Biostrings", quiet = TRUE)
conflict_prefer("intersect", "GSEABase", quiet = TRUE)
source(file.path(getwd(), "..", "utils.R"))

# Use UMI protocol due to poor performance of reads protocol.
# -----------------------------------------------------------
protocol <- c("mouse", "smart-seq", "single-cell", "umis") # See `cluster_pipeline` in `utils.R`.
# -----------------------------------------------------------

# Metadata to plot after dimensionality reduction and clustering.
# Values in list can include "no_legend and/or "no_label" to exclude those.
# -------------------------------------------------------------------------
metadata_to_plot <- vector("list", 4)
names(metadata_to_plot) <- c("idents", "sex_label", "age_label", "donor_id")
# -------------------------------------------------------------------------
# --------------------------------------------

subset_names <- "EC_HIP_neuronal"
downsample <- 194 # Downsample to the population with fewest cells.
gene_set_name <- "GO_BP_ENSG_mouse.gmt" # GMT filename of gene set for the analysis.
iss_codebook_name <- "codebook_comb.txt" # Filename of in-situ sequencing codebook to reference.

# Clusters of interest.
# ---------------------
idents <- vector("list", 3)
idents[[1]] <- 11
idents[[2]] <- 1
idents[[3]] <- 14
names(idents) <- c("EC_L2", "CA1", "CA3")
# ---------------------
# -------------------------------------

# Everything else in this chunk remains generally unchanged.
# ----------------------------------------------------------
analysis_no <- 6
data_name <- unlist(strsplit(getwd(), "/"))[6] # Name of dataset.
assets_dir <- file.path(getwd(), "..", "..", "assets") # Backed up caches and data.

# Unique cache directory for each analysis number.
# ------------------------------------------------
cache_dir <- file.path(assets_dir, "cache", data_name, paste0("0", analysis_no))
if (!dir.exists(cache_dir)) {
  dir.create(cache_dir, recursive = TRUE)
}
# ------------------------------------------------

knitr::opts_chunk$set(fig.width = 12, fig.height = 12)
# ----------------------------------------------------------
```

We use data saved from previous analyses.

```{r, fig.height = 5, fig.width = 7.5}
seurat <- readRDS(
  file.path(assets_dir, "cache", data_name, "02", paste0(subset_names[1], "_seurat.rds"))
)
seurat
red_dim_plot(seurat, "umap1", "umap2", "seurat_clusters", "cat")

gene_sets <- getGmt(file.path(assets_dir, "gene-sets", gene_set_name))
gene_sets <- filterGeneSets(gene_sets, 5, 500)
gene_sets

# # Filter to sets containing specific gene(s).
# # -------------------------------------------
# keep <- geneIds(gene_sets)
# keep <- keep[grep("ENSMUSG00000040249", keep)]
# gene_sets <- gene_sets[names(gene_sets) %in% names(keep)]
# gene_sets
# # -------------------------------------------

iss_codebook <- read.csv(file.path(assets_dir, "gene-sets", iss_codebook_name), sep = "\t")
print("In-situ sequencing (ISS) codebook")
head(iss_codebook)

# Create a Seurat object containing only clusters of interest with downsampling.
# Also convert gene symbols to ENSEMBL IDs.
# ------------------------------------------------------------------------------
rds <- file.path(cache_dir, "seurat_cleaned.rds")
rds2 <- file.path(cache_dir, "gene_anno.rds")
if (file.exists(rds)) {
  seurat <- readRDS(rds)
  gene_anno <- readRDS(rds2)
} else {

  # Remove obsolete data.
  # ---------------------
  DefaultAssay(seurat) <- "RNA"
  seurat[["SCT"]] <- NULL
  # ---------------------

  # Create subsets.
  # ---------------
  expr <- FetchData(seurat, "seurat_clusters")

  condition1_seurat <- seurat[ , which(expr == idents[1])]
  set.seed(1)
  condition1_seurat <- subset(
    condition1_seurat, cells = sample(Cells(condition1_seurat), downsample)
  )
  condition2_seurat <- seurat[ , which(expr == idents[2])]
  set.seed(1)
  condition2_seurat <- subset(
    condition2_seurat, cells = sample(Cells(condition2_seurat), downsample)
  )
  condition3_seurat <- seurat[ , which(expr == idents[3])]
  set.seed(1)
  condition3_seurat <- subset(
    condition3_seurat, cells = sample(Cells(condition3_seurat), downsample)
  )

  seurat <- merge(condition1_seurat, list(condition2_seurat, condition3_seurat))
  rm(condition1_seurat, condition2_seurat, condition3_seurat)
  seurat <- seurat[rowSums(as.matrix(GetAssayData(seurat, slot = "counts")) > 0) > 0, ]
  # ---------------

  # Get gene annotations.
  # ---------------------
  if (protocol[1] == "human") {
    dataset = "hsapiens_gene_ensembl"
  } else if (protocol[1] == "mouse") {
    dataset = "mmusculus_gene_ensembl"
  }
  mart <- useEnsembl("ensembl", dataset, "http://useast.ensembl.org/")
  attributes <- c("external_gene_name", "ensembl_gene_id")
  gene_anno <- getBM(attributes, "external_gene_name", rownames(seurat), mart)
  gene_anno <- gene_anno[gene_anno$ensembl_gene_id %in% unique(unlist(geneIds(gene_sets))), ]
  gene_anno <- gene_anno[gene_anno$external_gene_name %in% rownames(seurat), ]
  # ---------------------

  # For gene symbols with multiple ENSEMBL IDs, duplicate the gene symbol to have an identical row
  # for each ENSEMBL ID.
  # ----------------------------------------------------------------------------------------------
  dup <- gene_anno[duplicated(gene_anno$external_gene_name), ]
  for (i in 1:dim(dup)[1]) {
    for (j in 1:dim(gene_anno)[1]) {
      if (dup$ensembl_gene_id[i] == gene_anno$ensembl_gene_id[j]) {
        gene_anno$external_gene_name[j] <- paste0(gene_anno$external_gene_name[j], "-dup")
      }
    }
  }
  seurat <- seurat[rownames(seurat) %in% gene_anno$external_gene_name, ]
  new_mat <- GetAssayData(seurat, "counts")
  for (i in 1:dim(dup)[1]) {
    for (j in 1:dim(seurat)[1]) {
      if (dup$external_gene_name[i] == rownames(seurat)[j]) {
        new_row <- GetAssayData(seurat[j, ], "counts")
        rownames(new_row) <- paste0(rownames(new_row), "-dup")
        new_mat <- rbind(new_mat, new_row)
      }
    }
  }
  gene_anno <- gene_anno[gene_anno$external_gene_name %in% rownames(new_mat), ]
  gene_anno <- gene_anno[order(match(gene_anno$external_gene_name, rownames(new_mat))), ]
  rownames(new_mat) <- gene_anno$ensembl_gene_id
  seurat <- CreateSeuratObject(new_mat, meta.data = seurat[[]])
  Idents(seurat) <- "seurat_clusters"
  rm(new_mat)
  # ----------------------------------------------------------------------------------------------

  saveRDS(seurat, rds)
  saveRDS(gene_anno, rds2)
}
# ------------------------------------------------------------------------------

# Subset again in order to place conditions in correct order for SCnorm.
# ----------------------------------------------------------------------
condition1_seurat <- subset(seurat, idents = idents[1])
condition2_seurat <- subset(seurat, idents = idents[2])
condition3_seurat <- subset(seurat, idents = idents[3])
seurat <- merge(condition1_seurat, list(condition2_seurat, condition3_seurat))
# ----------------------------------------------------------------------

# Renormalize using SCnorm using sample-wise condition information and gene-wise gene length and GC
# content information.
# -------------------------------------------------------------------------------------------------
rds <- file.path(cache_dir, "scnorm.rds")
if (file.exists(rds)) {
  sce <- readRDS(rds)
} else {
  sce <- SingleCellExperiment(
    list(
      counts = cbind(
        as.matrix(GetAssayData(condition1_seurat)), as.matrix(GetAssayData(condition2_seurat)),
        as.matrix(GetAssayData(condition3_seurat))
      )
    )
  )
  groups <- factor(
    rep(
      c(0, 1, 2), c(dim(condition1_seurat)[2], dim(condition2_seurat)[2], dim(condition3_seurat)[2])
    )
  )
  row_data <- data.frame(
    getGeneLengthAndGCContent(rownames(sce), "mmusculus_gene_ensembl", "biomart")
  )
  sce <- SCnorm(
    sce, groups, withinSample = c(row_data$gc, row_data$length),
    useZerosToScale = TRUE, NCores = detectCores()
  )
  saveRDS(sce, rds)
}
# -------------------------------------------------------------------------------------------------

# Add normalized data to Seurat object.
# -------------------------------------
rm(condition1_seurat, condition2_seurat, condition3_seurat)
seurat <- seurat[rownames(seurat) %in% rownames(sce), ]
seurat <- SetAssayData(seurat, new.data = normcounts(sce))
seurat <- SetAssayData(seurat, "scale.data", log2(normcounts(sce) + 1))
rm(sce)
# -------------------------------------

# Rename Idents for more descriptive plots.
# -----------------------------------------
seurat <- RenameIdents(seurat, `11` = "EC_L2")
seurat <- RenameIdents(seurat, `1` = "CA1")
seurat <- RenameIdents(seurat, `14` = "CA3")
seurat$idents <- seurat@active.ident
# -----------------------------------------

seurat
red_dim_plot(seurat, "umap1", "umap2", "idents", "cat")
print("SCnorm normalized counts distribution")
hist(as.matrix(GetAssayData(seurat, "scale.data")))

# Create MDS plots to identify potential confounders and latent factors.
# ----------------------------------------------------------------------
rds <- file.path(cache_dir, "d.rds")
if (file.exists(rds)) {
  d <- readRDS(rds)
} else {
  d <- dist(t(scale(GetAssayData(seurat, "scale.data"))))
  saveRDS(d, rds)
}
mds <- cmdscale(d, 2)
colnames(mds) <- paste0("mds_", 1:2)
seurat[["mds"]] <- CreateDimReducObject(mds, key = "mds_", assay = DefaultAssay(seurat))
rm(mds)
add_df <- data.frame(Embeddings(seurat, "mds"))
names(add_df) <- paste0("mds", seq(ncol(add_df)))
seurat$mds1 <- add_df$mds1
seurat$mds2 <- add_df$mds2

for (i in 1:length(metadata_to_plot)) {
  print(names(metadata_to_plot)[i])
  print(red_dim_plot(seurat, "mds1", "mds2", names(metadata_to_plot)[i], "cat"))
}
print("nFeature_RNA")
red_dim_plot(seurat, "mds1", "mds2", "nFeature_RNA", "cont")
print("nCount_RNA")
red_dim_plot(seurat, "mds1", "mds2", "nCount_RNA", "cont")
# ----------------------------------------------------------------------
```

```{r}
# Run GSVA.
# ---------
rds <- file.path(cache_dir, "gsva.rds")
if (file.exists(rds)) {
  gsva <- readRDS(rds)
} else {
  gsva <- gsva(as.matrix(GetAssayData(seurat, "scale.data")), gene_sets)
  saveRDS(gsva, rds)
}
# ---------

# Add GSVA results to Seurat object.
# ----------------------------------
seurat[["GSVA"]] <- CreateAssayObject(gsva)
rm(gsva)
DefaultAssay(seurat) <- "GSVA"
print("GSVA distribution")
hist(as.matrix(GetAssayData(seurat, "counts")))
# ----------------------------------

# Add previous UMAP to Seurat object.
# -----------------------------------
umap <- as.matrix(data.frame(seurat$umap1, seurat$umap2))
colnames(umap) <- paste0("umap_", 1:2)
seurat[["umap"]] <- CreateDimReducObject(umap, key = "umap_", assay = DefaultAssay(seurat))
rm(umap)
# -----------------------------------
```

# EC-L2 -> CA1 -> CA3

We build a statistical model that finds gene sets that follow the above trajectory.
In short, we use `lmFit` from limma to fit the models to both GSVA results and the normalized count data, extract significant results, and then see look at results overlapping between the two in the following subsections.
Besides statistical thresholds, an important parameter is the number of significant results required in the `decideTests` output.

## All DE

The model parameters are set stringently such that each gene set must be differentially expressed between all possible comparisons.

```{r}
# Fit model on GSVA results.
# --------------------------
DefaultAssay(seurat) <- "GSVA"
design <- model.matrix(~ 0 + seurat$idents, as.data.frame(GetAssayData(seurat, "counts")))
colnames(design) <- rev(names(idents))
fit <- lmFit(as.data.frame(GetAssayData(seurat, "counts")), design)
contrast_mat <- makeContrasts(CA3-CA1, CA3-EC_L2, CA1-EC_L2, levels = design)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat))
table <- topTable(cont_fit, 1, Inf)
results <- decideTests(cont_fit, "global")

up <- table[rownames(table) %in% rownames(results[rowSums(results) == -ncol(results), ]), ]
up <- head(up, 50)
down <- table[rownames(table) %in% rownames(results[rowSums(results) == ncol(results), ]), ]
down <- head(down, nrow(up))
gsva_list <- list(up, down)
# --------------------------

datatable_custom(gsva_list[[1]])
datatable_custom(gsva_list[[2]])
DoHeatmap(seurat, rownames(up), slot = "counts", size = 3) +
  NoLegend() +
  scale_fill_gradient2(
    low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
    high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
    guide = "colourbar", aesthetics = "fill"
  )
DoHeatmap(seurat, rownames(down), slot = "counts", size = 3) +
  NoLegend() +
  scale_fill_gradient2(
    low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
    high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
    guide = "colourbar", aesthetics = "fill"
  )
FeaturePlot(
  seurat, rownames(up)[1:4], order = TRUE,
  cols = c("lawngreen", "firebrick1"), ncol = 2
)
FeaturePlot(
  seurat, rownames(down)[1:4], order = TRUE,
  cols = c("lawngreen", "firebrick1"), ncol = 2
)
VlnPlot(seurat, rownames(up)[1:6], ncol = 2)
VlnPlot(seurat, rownames(down)[1:6], ncol = 2)

# Fit model on normalized counts.
# -------------------------------
DefaultAssay(seurat) <- "RNA"
design <- model.matrix(~ 0 + seurat$idents, as.data.frame(GetAssayData(seurat, "scale.data")))
colnames(design) <- rev(names(idents))
fit <- lmFit(as.data.frame(GetAssayData(seurat, "scale.data")), design)
contrast_mat <- makeContrasts(CA3-CA1, CA3-EC_L2, CA1-EC_L2, levels = design)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat), trend = TRUE)
table <- topTable(cont_fit, coef = 1, number = Inf)
results <- decideTests(cont_fit, "global")

markers_up <- table[rownames(table) %in% rownames(results[rowSums(results) == -ncol(results), ]), ]
markers_down <- table[rownames(table) %in% rownames(results[rowSums(results) == ncol(results), ]), ]
markers_down <- head(markers_down, nrow(markers_up))
marker_list <- list(markers_up, markers_down)
# -------------------------------

# Convert ENSEMBL IDs back to gene symbols.
# -----------------------------------------
genes <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(markers_up), ]
genes <- genes[order(match(genes$ensembl_gene_id, rownames(markers_up))), ]
markers_up_symbols <- markers_up
rownames(markers_up_symbols) <- genes$external_gene_name

genes <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(markers_down), ]
genes <- genes[order(match(genes$ensembl_gene_id, rownames(markers_down))), ]
markers_down_symbols <- markers_down
rownames(markers_down_symbols) <- genes$external_gene_name
# -----------------------------------------

datatable_custom(markers_up_symbols)
datatable_custom(markers_down_symbols)

# Check if any markers are in ISS codebook.
# -----------------------------------------
for (i in 1:nrow(markers_up_symbols)) {
  if (rownames(markers_up_symbols)[i] %in% iss_codebook[ , 1]) {
    print(paste0(rownames(markers_up_symbols)[i], " in codebook."))
  }
}
for (i in 1:nrow(markers_down_symbols)) {
  if (rownames(markers_down_symbols)[i] %in% iss_codebook[ , 1]) {
    print(paste0(rownames(markers_down_symbols)[i], " in codebook."))
  }
}
# -----------------------------------------

# Create new Seurat object with gene symbols.
# -------------------------------------------
new_mat <- GetAssayData(seurat, "data")
rownames(new_mat) <- gene_anno$external_gene_name
seurat_symbols <- CreateSeuratObject(new_mat, meta.data = seurat[[]])
Idents(seurat_symbols) <- "idents"
seurat_symbols <- SetAssayData(
  seurat_symbols, new.data = log2(as.matrix(GetAssayData(seurat_symbols, "counts")) + 1)
)
seurat_symbols <- SetAssayData(seurat_symbols, "scale.data", scale(GetAssayData(seurat_symbols)))

genes <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(markers_up), ]
genes <- genes[order(match(genes$ensembl_gene_id, rownames(markers_up))), ]
genes <- genes$external_gene_name
DoHeatmap(seurat_symbols, genes, size = 3) +
  NoLegend() +
  scale_fill_gradient2(
    low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
    high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
    guide = "colourbar", aesthetics = "fill"
  )

genes <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(markers_down), ]
genes <- genes[order(match(genes$ensembl_gene_id, rownames(markers_down))), ]
genes <- genes$external_gene_name
DoHeatmap(seurat_symbols, genes, size = 3) +
  NoLegend() +
  scale_fill_gradient2(
    low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
    high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
    guide = "colourbar", aesthetics = "fill"
  )
# -------------------------------------------
```

### Upregulation

We display DE genes within gene sets that are both upregulated in the direction of the trajectory start point.

```{r}
# TODO: Fix problem of contents appearing out of order.
# -----------------------------------------------------
set <- 1 # Up or downregulation?
for (i in 1:nrow(gsva_list[[set]])) {
  genes <- which(
    gene_sets[[rownames(gsva_list[[set]])[i]]]@geneIds %in% rownames(marker_list[[set]])
  )

  genes <- gene_sets[[rownames(gsva_list[[set]])[i]]]@geneIds[genes]
  genes <- gene_anno[gene_anno$ensembl_gene_id %in% genes, ]
  genes <- genes$external_gene_name
  print(
    paste0(
      gene_sets[[rownames(gsva_list[[set]])[i]]]@shortDescription, ": ",
      gene_sets[[rownames(gsva_list[[set]])[i]]]@setName
    )
  )
  if (length(genes) > 0) {
    for (j in 1:length(genes)) {
      if (genes[j] %in% iss_codebook[ , 1]) {
        print(paste0(genes[j], " in codebook."))
      }
    }
  }
  print(paste0(gene_sets[[rownames(gsva_list[[set]])[i]]]@shortDescription, ": ", genes))

  if (length(genes) > 0) {
    print(
      DoHeatmap(seurat_symbols, genes, size = 3) +
        NoLegend() +
        scale_fill_gradient2(
          low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
          high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
          guide = "colourbar", aesthetics = "fill"
        ) +
        ggtitle(gene_sets[[rownames(gsva_list[[set]])[i]]]@setName)
    )
  }

  genes2 <- gene_sets[[rownames(gsva_list[[set]])[i]]]@geneIds
  genes2 <- gene_anno[gene_anno$ensembl_gene_id %in% genes2, ]
  genes2 <- genes2$external_gene_name
  if (length(genes) > 0) {
    print(
      DoHeatmap(seurat_symbols, genes2, size = 3) +
        NoLegend() +
        scale_fill_gradient2(
          low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
          high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
          guide = "colourbar", aesthetics = "fill"
        ) +
        ggtitle(gene_sets[[rownames(gsva_list[[set]])[i]]]@setName)
    )
  }
}
# -----------------------------------------------------
```

### Downregulation

We display DE genes within gene sets that are both downregulated in the direction of the trajectory start point.

```{r}
# TODO: Fix problem of contents appearing out of order.
# -----------------------------------------------------
set <- 2 # Up or downregulation?
for (i in 1:nrow(gsva_list[[set]])) {
  genes <- which(
    gene_sets[[rownames(gsva_list[[set]])[i]]]@geneIds %in% rownames(marker_list[[set]])
  )

  genes <- gene_sets[[rownames(gsva_list[[set]])[i]]]@geneIds[genes]
  genes <- gene_anno[gene_anno$ensembl_gene_id %in% genes, ]
  genes <- genes$external_gene_name
  print(
    paste0(
      gene_sets[[rownames(gsva_list[[set]])[i]]]@shortDescription, ": ",
      gene_sets[[rownames(gsva_list[[set]])[i]]]@setName
    )
  )
  if (length(genes) > 0) {
    for (j in 1:length(genes)) {
      if (genes[j] %in% iss_codebook[ , 1]) {
        print(paste0(genes[j], " in codebook."))
      }
    }
  }
  print(paste0(gene_sets[[rownames(gsva_list[[set]])[i]]]@shortDescription, ": ", genes))

  if (length(genes) > 0) {
    print(
      DoHeatmap(seurat_symbols, genes, size = 3) +
        NoLegend() +
        scale_fill_gradient2(
          low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
          high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
          guide = "colourbar", aesthetics = "fill"
        ) + ggtitle(gene_sets[[rownames(gsva_list[[set]])[i]]]@setName)
    )
  }

  genes2 <- gene_sets[[rownames(gsva_list[[set]])[i]]]@geneIds
  genes2 <- gene_anno[gene_anno$ensembl_gene_id %in% genes2, ]
  genes2 <- genes2$external_gene_name
  if (length(genes) > 0) {
    print(
      DoHeatmap(seurat_symbols, genes2, size = 3) +
        NoLegend() +
        scale_fill_gradient2(
          low = rev(c('#D1E5F0','#67A9CF','#2166AC')), mid = "white",
          high = rev(c('#B2182B','#EF8A62','#FDDBC7')), midpoint = 0,
          guide = "colourbar", aesthetics = "fill"
        ) +
        ggtitle(gene_sets[[rownames(gsva_list[[set]])[i]]]@setName)
    )
  }
}
# -----------------------------------------------------
```

# References

This is the concluding section of the document. Here we write relevant results to disk, output the `sessionInfo`, and create a bibliography for works cited.

```{r}
sessionInfo()
```
