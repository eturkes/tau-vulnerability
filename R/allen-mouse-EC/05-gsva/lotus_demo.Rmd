---
title: "Investigating Selective Vulnerability in Alzheimer's Disease"
subtitle: "Demonstration of the Lotus Gene Set Enrichment Tool"
author:
  - name: "Emir Turkes (emir.turkes.19@ucl.ac.uk) and Karen E. Duff PhD (k.duff@ucl.ac.uk)"
  - name: "UK Dementia Research Institute at UCL"
date: '`r strftime(Sys.time(), "%B %d, %Y")`'
bibliography: '../../../`r unlist(strsplit(getwd(), "/"))[4]`.bib'
link-citations: true
output:
  html_document:
    code_folding: hide
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(
    "..", "..", "..",
    "results", unlist(strsplit(getwd(), "/"))[6],
    unlist(strsplit(getwd(), "/"))[7], "lotus-demo.html"
  ))})
---

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
.tocify-subheader .tocify-subheader .tocify-item {
  font-size: 0.95em; padding-left: 35px; text-indent: 0;
}
div.main-container {max-width: none; width: 100%;}
</style>

*Source code and Docker/Singularity container for rerunning this analysis can be found at https://github.com/eturkes/tau-vulnerability (currently private).*

This document demonstrates an analysis using the *Lotus* gene set enrichment tool.
*Lotus* is an R package and R Markdown template providing a novel pipeline for integrated gene set enrichment, differential expression, and hub gene analysis in gene expression data.
Here we apply *Lotus* on wild-type mouse single-cell RNAseq (scRNAseq) data from the Allen Institute [@leinGenomewideAtlasGene2007] to investigate selective vulnerability in Alzheimer's Disease (AD), the phenomenon wherein which certain cell types are preferentially affected over others.
We hypothesize that physiological expression patterns that correlate with the pathological stage (i.e. Braak stage) of a cell type drive intrinsic factors associated with vulnerability.

```{r}
# Some standard boilerplate.
# --------------------------
#    This file is part of tau-vulnerability.
#    Copyright (C) 2019-2020  Emir Turkes, UK DRI at UCL, Columbia University Medical Center
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

# These should be checked per document.
# -------------------------------------
options(stringsAsFactors = FALSE)
packages <- c(
  "conflicted", "scales", "RColorBrewer", "Seurat", "dplyr", "ggplot2", "ggrepel", "GSEABase",
  "biomaRt", "Biostrings", "SingleCellExperiment", "SCnorm", "viridis", "scater", "GSVA", "limma",
  "DT", "dendextend", "ComplexHeatmap", "GO.db", "tm", "reshape2", "igraph", "qgraph", "pals",
  "cluster", "future", "edgeR", "circlize", "factoextra"
)
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))
conflict_prefer("strsplit", "Biostrings", quiet = TRUE)
conflict_prefer("intersect", "GSEABase", quiet = TRUE)
conflict_prefer("select", "AnnotationDbi", quiet = TRUE)
conflict_prefer("degree", "igraph", quiet = TRUE)
conflict_prefer("strsplit", "Biostrings", quiet = TRUE)
conflict_prefer("cpm", "edgeR", quiet = TRUE)
conflict_prefer("groups", "igraph", quiet = TRUE)

# Can be found at: https://github.com/eturkes/utils/blob/main/tau-vulnerability/utils.R
# -------------------------------------------------------------------------------------
source(file.path("..", "..", "utils.R"))
# -------------------------------------------------------------------------------------

analysis_no <- 4 # For determining caching directory.
protocol <- c("mouse", "smart-seq", "single-cell", "reads") # See `cluster_pipeline` in `utils.R`.
gene_set_name <- "GO" # What gene set are we using.
subset_names <- "EC_HIP_neuronal" # From what subset of the data are we looking at.
color <- colorRampPalette(rev(brewer.pal(9, "RdBu")))(100) # For main gene set heatmap.
color2 <- colorRampPalette(rev(brewer.pal(11, "RdYlBu")))(100) # For gene heatmaps.
`%notin%` <- Negate(`%in%`)

# Clustering function for gene sets.
# ----------------------------------
nbclust_fun <- function(x, k) {
  list(cluster = cutree(hclust(get_dist((x), "spearman"), "ward.D2"), k))
}
# ----------------------------------

# Clusters of interest.
# ---------------------
idents <- vector("list", 4)
idents[[1]] <- 23
idents[[2]] <- 3
idents[[3]] <- 29
idents[[4]] <- 18
names(idents) <- c("EC_Reln", "CA1_Wfs1", "CA3_Bok", "IN_Sst")
# ---------------------

# Metadata to plot after dimensionality reduction and clustering.
# Values in list can include "no_legend and/or "no_label" to exclude those.
# -------------------------------------------------------------------------
metadata_to_plot <- vector("list", 2)
names(metadata_to_plot) <- c("donor_sex_label", "external_donor_name_id")
metadata_to_plot$donor_sex_label <- "no_label"
# -------------------------------------------------------------------------
# -------------------------------------

# Everything else in this chunk remains generally unchanged.
# ----------------------------------------------------------
data_name <- unlist(strsplit(getwd(), "/"))[6] # Name of dataset.
assets_dir <- file.path(getwd(), "..", "..", "..", "assets") # Backed up data.
results_dir <- file.path(getwd(), "..", "..", "..", "results") # Where Rmd HTML is compiled.

# Unique cache directory for each analysis number.
# ------------------------------------------------
cache_dir <- file.path(
  getwd(), "..", "..", "..", "cache", data_name, "05-gsva", paste0("0", analysis_no)
)
if (!dir.exists(cache_dir)) {
  dir.create(cache_dir, recursive = TRUE)
}
# ------------------------------------------------

if (protocol[1] == "human") {
  organism <- "hsapiens"
} else if (protocol[1] == "mouse") {
  organism <- "mmusculus"
}

knitr::opts_chunk$set(fig.width = 10, fig.height = 7)
# ----------------------------------------------------------
# --------------------------
```

# Prep

To test our hypothesis, we first sought to identify cell types of interest in our scRNAseq data.
We started by applying the pipeline below for QC, normalization, dimensionality reduction, and clustering of the cells:

![](../../../assets/reference/cluster-pipeline.svg)

After subsetting to our regions of interest (hippocampus - HIP and entorhinal cortex - ENT/EC) we obtained the following UMAP projections:

```{r}
seurat <- readRDS(file.path(cache_dir, "..", "..", "02", paste0(subset_names[1], "_seurat.rds")))
seurat
```

**Cluster Labels from the Allen Institute**

```{r}
red_dim_plot(seurat, "umap1", "umap2", "subclass_label", "cat")
```

**Cluster Labels Generated from Pipeline**

```{r}
red_dim_plot(seurat, "umap1", "umap2", "seurat_clusters", "cat")
```

Using previously identified marker genes [@mrdjenBasisCellularRegional2019; @roussarieSelectiveNeuronalVulnerability2020], we highlighted four clusters corresponding to cell types of interest.

```{r}
FeaturePlot(seurat, c("Reln", "Wfs1", "Bok", "Sst"), order = TRUE, cols = c("lightgrey", "red"))
```

The highlighted clusters were used as input to the main *Lotus* pipeline, as shown below.
Note that gray boxes indicate optional input and green boxes indicate the main outputs.

![](../../../assets/reference/gene-set-enrichment.svg)

Applying the pipeline, after subsetting and downsampling we arrived at the following reduced dimensions:

```{r}
# Load and filter gene sets.
# --------------------------
gene_sets_orig <- getGmt(
  file.path(assets_dir, "gene-sets", paste0(organism, ".", gene_set_name, ".ENSG.gmt"))
)
rds <- file.path(cache_dir, paste0(gene_set_name, "_gene_sets.rds"))
if (file.exists(rds)) {
  gene_sets <- readRDS(rds)
} else {
  gene_sets <- gene_sets_orig
  gene_sets <- filterGeneSets(gene_sets, 3, 500)
  for (i in seq(length(gene_sets@.Data))) {
    go_id <- gene_sets[[i]]@setName
    suppressWarnings(gene_sets[[i]]@setName <- gene_sets[[i]]@shortDescription)
    suppressWarnings(gene_sets[[i]]@shortDescription <- go_id)
  }
  saveRDS(gene_sets, rds)
}
# --------------------------

# Create a Seurat object containing only clusters of interest with downsampling.
# Also convert gene symbols to ENSEMBL IDs.
# ------------------------------------------------------------------------------
rds <- file.path(cache_dir, paste0(gene_set_name, "_seurat_cleaned.rds"))
rds2 <- file.path(cache_dir, paste0(gene_set_name, "_gene_anno.rds"))
if (file.exists(rds) & file.exists(rds2)) {
  seurat <- readRDS(rds)
  gene_anno <- readRDS(rds2)
} else {

  # Remove obsolete data.
  # ---------------------
  DefaultAssay(seurat) <- "RNA"
  seurat[["SCT"]] <- NULL
  # ---------------------

  # Create subsets.
  # TODO: Remove hardcoding.
  # ------------------------
  sample1_seurat <- subset(seurat, subset = external_donor_name_id == 475)
  expr <- FetchData(sample1_seurat, "seurat_clusters")
  sample1_seurat <- sample1_seurat[ , which(expr == idents[[1]])]
  sample2_seurat <- subset(seurat, subset = external_donor_name_id == 476)
  expr <- FetchData(sample2_seurat, "seurat_clusters")
  sample2_seurat <- sample2_seurat[ , which(expr == idents[[1]])]
  sample3_seurat <- subset(seurat, subset = external_donor_name_id == 527)
  expr <- FetchData(sample3_seurat, "seurat_clusters")
  sample3_seurat <- sample3_seurat[ , which(expr == idents[[2]])]
  sample4_seurat <- subset(seurat, subset = external_donor_name_id == 528)
  expr <- FetchData(sample4_seurat, "seurat_clusters")
  sample4_seurat <- sample4_seurat[ , which(expr == idents[[2]])]
  sample5_seurat <- subset(seurat, subset = external_donor_name_id == 527)
  expr <- FetchData(sample5_seurat, "seurat_clusters")
  sample5_seurat <- sample5_seurat[ , which(expr == idents[[3]])]
  sample6_seurat <- subset(seurat, subset = external_donor_name_id == 528)
  expr <- FetchData(sample6_seurat, "seurat_clusters")
  sample6_seurat <- sample6_seurat[ , which(expr == idents[[3]])]
  sample7_seurat <- subset(seurat, subset = external_donor_name_id == 456)
  expr <- FetchData(sample7_seurat, "seurat_clusters")
  sample7_seurat <- sample7_seurat[ , which(expr == idents[[4]])]
  sample8_seurat <- subset(seurat, subset = external_donor_name_id == 471)
  expr <- FetchData(sample8_seurat, "seurat_clusters")
  sample8_seurat <- sample8_seurat[ , which(expr == idents[[4]])]

  # Find the minimum number of cells from each of the samples.
  # This will be used to downsample each sample.
  # ----------------------------------------------------------
  downsample <- min(
    dim(sample1_seurat)[2], dim(sample2_seurat)[2], dim(sample3_seurat)[2],
    dim(sample4_seurat)[2], dim(sample5_seurat)[2], dim(sample6_seurat)[2],
    dim(sample7_seurat)[2], dim(sample8_seurat)[2]
  )
  # ----------------------------------------------------------

  sample1_seurat <- subset(seurat, subset = external_donor_name_id == 475)
  expr <- FetchData(sample1_seurat, "seurat_clusters")
  sample1_seurat <- sample1_seurat[ , which(expr == idents[[1]])]
  sample2_seurat <- subset(seurat, subset = external_donor_name_id == 476)
  expr <- FetchData(sample2_seurat, "seurat_clusters")
  sample2_seurat <- sample2_seurat[ , which(expr == idents[[1]])]
  set.seed(1)
  sample1_seurat <- subset(sample1_seurat, cells = sample(Cells(sample1_seurat), downsample))
  set.seed(1)
  sample2_seurat <- subset(sample2_seurat, cells = sample(Cells(sample2_seurat), downsample))
  condition1_seurat <- merge(sample1_seurat, sample2_seurat)

  sample1_seurat <- subset(seurat, subset = external_donor_name_id == 527)
  expr <- FetchData(sample1_seurat, "seurat_clusters")
  sample1_seurat <- sample1_seurat[ , which(expr == idents[[2]])]
  sample2_seurat <- subset(seurat, subset = external_donor_name_id == 528)
  expr <- FetchData(sample2_seurat, "seurat_clusters")
  sample2_seurat <- sample2_seurat[ , which(expr == idents[[2]])]
  set.seed(1)
  sample1_seurat <- subset(sample1_seurat, cells = sample(Cells(sample1_seurat), downsample))
  set.seed(1)
  sample2_seurat <- subset(sample2_seurat, cells = sample(Cells(sample2_seurat), downsample))
  condition2_seurat <- merge(sample1_seurat, sample2_seurat)

  sample1_seurat <- subset(seurat, subset = external_donor_name_id == 527)
  expr <- FetchData(sample1_seurat, "seurat_clusters")
  sample1_seurat <- sample1_seurat[ , which(expr == idents[[3]])]
  sample2_seurat <- subset(seurat, subset = external_donor_name_id == 528)
  expr <- FetchData(sample2_seurat, "seurat_clusters")
  sample2_seurat <- sample2_seurat[ , which(expr == idents[[3]])]
  set.seed(1)
  sample1_seurat <- subset(sample1_seurat, cells = sample(Cells(sample1_seurat), downsample))
  set.seed(1)
  sample2_seurat <- subset(sample2_seurat, cells = sample(Cells(sample2_seurat), downsample))
  condition3_seurat <- merge(sample1_seurat, sample2_seurat)

  sample1_seurat <- subset(seurat, subset = external_donor_name_id == 456)
  expr <- FetchData(sample1_seurat, "seurat_clusters")
  sample1_seurat <- sample1_seurat[ , which(expr == idents[[4]])]
  sample2_seurat <- subset(seurat, subset = external_donor_name_id == 471)
  expr <- FetchData(sample2_seurat, "seurat_clusters")
  sample2_seurat <- sample2_seurat[ , which(expr == idents[[4]])]
  set.seed(1)
  sample1_seurat <- subset(sample1_seurat, cells = sample(Cells(sample1_seurat), downsample))
  set.seed(1)
  sample2_seurat <- subset(sample2_seurat, cells = sample(Cells(sample2_seurat), downsample))
  condition4_seurat <- merge(sample1_seurat, sample2_seurat)

  seurat <- merge(condition1_seurat, c(condition2_seurat, condition3_seurat, condition4_seurat))
  rm(
    sample1_seurat, sample2_seurat, sample3_seurat, sample4_seurat,
    sample5_seurat, sample6_seurat, sample7_seurat, sample8_seurat
  )

  # Required filtering criteria for SCnorm normalization.
  # -----------------------------------------------------
  seurat <- seurat[rowSums(as.matrix(GetAssayData(seurat, slot = "counts")) > 0) >= 10, ]
  # -----------------------------------------------------
  # ------------------------

  # Get gene annotations and filter genes and gene sets.
  # Note that we also remove pseudogenes and genes on sex chromosomes.
  # ------------------------------------------------------------------
  mart <- useEnsembl("ensembl", paste0(organism, "_gene_ensembl"))
  attributes <- c("external_gene_name", "ensembl_gene_id", "chromosome_name")
  gene_anno <- getBM(attributes, "external_gene_name", rownames(seurat), mart)
  gene_anno <- gene_anno[gene_anno$chromosome_name %in% c(1:22), ]
  gene_anno <- gene_anno[gene_anno$ensembl_gene_id %in% unique(unlist(geneIds(gene_sets))), ]

  keep <- lapply(
    geneIds(gene_sets), function(x, y) na.omit(fastmatch::fmatch(x, y)), gene_anno$ensembl_gene_id
  )
  keep <- filterGeneSets(keep, 3, 500)
  gene_sets <- gene_sets[names(gene_sets) %in% names(keep)]

  gene_anno <- gene_anno[gene_anno$ensembl_gene_id %in% unique(unlist(geneIds(gene_sets))), ]
  # ------------------------------------------------------------------

  # For gene symbols with multiple ENSEMBL IDs, duplicate the gene symbol to have an identical row
  # for each ENSEMBL ID.
  # It's possible for this section to actually require a third round of renaming, but it is rare.
  # ----------------------------------------------------------------------------------------------
  dup <- gene_anno[duplicated(gene_anno$external_gene_name), ]
  if (nrow(dup) > 0) {
    for (i in 1:dim(dup)[1]) {
      for (j in 1:dim(gene_anno)[1]) {
        if (dup$ensembl_gene_id[i] == gene_anno$ensembl_gene_id[j]) {
          gene_anno$external_gene_name[j] <- paste0(gene_anno$external_gene_name[j], "-alt")
        }
      }
    }
    if (any(duplicated(gene_anno$external_gene_name))) {
      stop("Duplicates in gene_anno.")
    }
    seurat <- seurat[rownames(seurat) %in% gene_anno$external_gene_name, ]
    new_mat <- GetAssayData(seurat, "counts")
    for (i in 1:dim(dup)[1]) {
      for (j in 1:dim(seurat)[1]) {
        if (dup$external_gene_name[i] == rownames(seurat)[j]) {
          new_row <- GetAssayData(seurat[j, ], "counts")
          rownames(new_row) <- paste0(rownames(new_row), "-alt")
          if (rownames(new_row) %in% rownames(new_mat)) {
            rownames(new_row) <- paste0(rownames(new_row), "2")
          }
          new_mat <- rbind(new_mat, new_row)
        }
      }
    }
  } else {
    seurat <- seurat[rownames(seurat) %in% gene_anno$external_gene_name, ]
    new_mat <- GetAssayData(seurat, "counts")
  }
  gene_anno <- gene_anno[gene_anno$external_gene_name %in% rownames(new_mat), ]
  gene_anno <- gene_anno[order(match(gene_anno$external_gene_name, rownames(new_mat))), ]
  rownames(new_mat) <- gene_anno$ensembl_gene_id

  seurat <- CreateSeuratObject(new_mat, meta.data = seurat[[]])
  rm(new_mat)

  # TODO: Remove hardcoding.
  # ------------------------
  seurat$idents <- factor(
    c(
      rep(names(idents)[1], dim(condition1_seurat)[2]),
      rep(names(idents)[2], dim(condition2_seurat)[2]),
      rep(names(idents)[3], dim(condition3_seurat)[2]),
      rep(names(idents)[4], dim(condition4_seurat)[2])
    ),
    levels = names(idents)
  )
  rm(condition1_seurat, condition2_seurat, condition3_seurat, condition4_seurat)
  seurat@active.ident <- seurat$idents
  seurat$groups <- paste0(seurat$idents, "_", seurat$external_donor_name_id)
  # ------------------------
  # ----------------------------------------------------------------------------------------------
  
  saveRDS(seurat, rds)
  saveRDS(gene_anno, rds2)
}
# ------------------------------------------------------------------------------

# Renormalize using SCnorm (ideal for full-length protocols) and regress out gene length and GC
# content.
# Note that both getGeneLengthAndGCContent() and SCnorm() take a long time.
# getGeneLengthAndGCContent() fails at times do to issues with the ENSEMBL server.
# SCnorm() can take upwards to for 40 GB RAM for this dataset.
# TODO: Make this a conditional based on protocol variable.
# ---------------------------------------------------------------------------------------------
rds <- file.path(cache_dir, paste0(gene_set_name, "_scnorm.rds"))
rds2 <- file.path(cache_dir, paste0(gene_set_name, "_row_data.rds"))
if (file.exists(rds)) {
  sce <- readRDS(rds)
} else {
  sce <- SingleCellExperiment(list(counts = as.matrix(GetAssayData(seurat))))
  row_data <- data.frame(
    getGeneLengthAndGCContent(rownames(sce), "mmusculus_gene_ensembl", "biomart")
  )
  saveRDS(row_data, rds2)
  sce <- SCnorm(
    sce, rep(1, dim(sce)[2]), withinSample = c(row_data$gc, row_data$length),
    useZerosToScale = TRUE, ditherCounts = TRUE, NCores = detectCores()
  )
  saveRDS(sce, rds)
}

seurat <- SetAssayData(seurat, new.data = normcounts(sce))
seurat <- SetAssayData(seurat, "scale.data", log2(normcounts(sce) + 1))
# -------------------------------------------------------------------------------------------------

# Create reduced dimension plots to identify potential confounders and latent factors.
# ------------------------------------------------------------------------------------
d <- dist(scale(t(GetAssayData(seurat, "scale.data"))))
mds <- cmdscale(d, 2)
colnames(mds) <- paste0("mds_", 1:2)
seurat[["mds"]] <- CreateDimReducObject(mds, key = "mds_", assay = DefaultAssay(seurat))
rm(mds)
add_df <- data.frame(Embeddings(seurat, "mds"))
names(add_df) <- paste0("mds", seq(ncol(add_df)))
seurat$mds1 <- add_df$mds1
seurat$mds2 <- add_df$mds2

umap <- as.matrix(data.frame(seurat$umap1, seurat$umap2))
colnames(umap) <- paste0("umap_", 1:2)
seurat[["umap"]] <- CreateDimReducObject(umap, key = "umap_", assay = DefaultAssay(seurat))
rm(umap)

red_dim_plot(seurat, "umap1", "umap2", "idents", "cat") + ggtitle("cell_type")
red_dim_plot(seurat, "mds1", "mds2", "idents", "cat") + ggtitle("cell_type")
for (i in 1:length(metadata_to_plot)) {
  if ("no_legend" %in% metadata_to_plot[[i]] && "no_label" %in% metadata_to_plot[[i]]) {
    print(red_dim_plot(seurat, "mds1", "mds2", names(metadata_to_plot)[i]) +
            NoLegend() + ggtitle(names(metadata_to_plot)[i]))
  } else if ("no_legend" %in% metadata_to_plot[[i]]) {
    print(red_dim_plot(seurat, "mds1", "mds2", names(metadata_to_plot)[i], "cat") +
            NoLegend() + ggtitle(names(metadata_to_plot)[i]))
  } else if ("no_label" %in% metadata_to_plot[[i]]) {
    print(red_dim_plot(seurat, "mds1", "mds2", names(metadata_to_plot)[i]) +
            ggtitle(names(metadata_to_plot)[i]))
  } else {
    print(red_dim_plot(seurat, "mds1", "mds2", names(metadata_to_plot)[i], "cat") +
            ggtitle(names(metadata_to_plot)[i]))
  }
}
# ------------------------------------------------------------------------------------
```

Additional normalization, pseudobulk aggregation, and QC produced the following logCPM counts:

```{r}
hist(as.matrix(GetAssayData(seurat, "scale.data")), main = "SCnorm normalized counts distribution")

# Aggregate features to into "pseudo-bulk" counts.
# Also perform independent filtering and transform to logCPM for limma-trend analysis.
# ------------------------------------------------------------------------------------
rds <- file.path(cache_dir, paste0(gene_set_name, "_pseudobulk.rds"))
if (file.exists(rds)) {
  sce <- readRDS(rds)
} else {
  sce <- as.SingleCellExperiment(seurat)
  counts(sce) <- logcounts(sce)
  sce <- suppressWarnings(
    aggregateAcrossCells(
      sce, colData(sce)[ , c("idents", "external_donor_name_id")],
      use_exprs_values = "counts", BPPARAM = MulticoreParam()
    )
  )
  keep <- filterByExpr(counts(sce), group = sce$idents, min.total.count = 10)
  sce <- sce[keep, ]
  dge <- DGEList(counts(sce))
  dge <- calcNormFactors(dge)
  logcounts(sce) <- cpm(dge, log = TRUE, prior.count = 3)
  rm(dge)
  saveRDS(sce, rds)
}

# Subset other objects to filtered SCE object.
# --------------------------------------------
seurat <- seurat[rownames(seurat) %in% rownames(sce), ]
gene_anno <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(sce), ]
keep <- lapply(
  geneIds(gene_sets), function(x, y) na.omit(fastmatch::fmatch(x, y)), gene_anno$ensembl_gene_id
)
keep <- filterGeneSets(keep, 3, 500)
gene_sets <- gene_sets[names(gene_sets) %in% names(keep)]
# --------------------------------------------
# ------------------------------------------------------------------------------------

hist(logcounts(sce), main = "Final pseudobulk logCPM distribution")
```

For this analysis we used GO terms from all ontologies (BP, MF, and CC).
Below are the initial and final set of terms used after filtering obsolete terms and those not within a set size of 3 and 500.

```{r}
# We use a modified overlap coefficient on the gene sets which divides the number of genes in the
# larger set by the number of shared genes with the smaller set.
# We perform this twice, once to sort the sets so that more general terms are towards the top, and
# again to remove sets with identical genes, keeping the more general term.
# ------------------------------------------------------------------------------------------------
rds <- file.path(cache_dir, paste0(gene_set_name, "_gene_set_overlap.rds"))
if (file.exists(rds)) {
  overlap <- readRDS(rds)
} else {
  overlap <- computeGeneSetsOverlapMax(gene_sets, unique(unlist(geneIds(gene_sets))))
  saveRDS(overlap, rds)
}
keep <- rowSums(overlap)
keep <- keep[order(keep, decreasing = TRUE)]
gene_sets_sorted <- gene_sets[match(names(keep), names(gene_sets))]
rds <- file.path(cache_dir, paste0(gene_set_name, "_gene_set_overlap_sorted.rds"))
if (file.exists(rds)) {
  overlap <- readRDS(rds)
} else {
  overlap <- computeGeneSetsOverlapMax(gene_sets_sorted, unique(unlist(geneIds(gene_sets_sorted))))
  saveRDS(overlap, rds)
}

overlap[upper.tri(overlap)] <- 0
diag(overlap) <- 0
keep <- apply(overlap, 1, max)
keep <- keep[keep < 1]
gene_sets <- gene_sets[names(gene_sets) %in% names(keep)]

sce <- sce[rownames(sce) %in% unique(unlist(geneIds(gene_sets))), ]
seurat <- seurat[rownames(seurat) %in% rownames(sce), ]
gene_anno <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(sce), ]
keep <- lapply(
  geneIds(gene_sets), function(x, y) na.omit(fastmatch::fmatch(x, y)), gene_anno$ensembl_gene_id
)
keep <- filterGeneSets(keep, 3, 500)
gene_sets <- gene_sets[names(gene_sets) %in% names(keep)]

print("Original gene sets")
gene_sets_orig
print("Filtered gene sets")
gene_sets
# ------------------------------------------------------------------------------------------------
```

# Differentially Enriched Gene Sets

ssGSEA from the GSVA package was used to compute a sample x gene set matrix.
We then fit four similar but distinct models using limma to find gene sets that vary with the Braak stage at which each cell type develops pathology.
Importantly, we vary the adjusted p-value cutoff for each model so that the number of DE terms obtained are roughly linear between models, as seen below.
Please collapse the code block for details.

```{r}
# Run GSVA on pseudo-bulk counts.
# -------------------------------
rds <- file.path(cache_dir, paste0(gene_set_name, "_gsva_pseudobulk.rds"))
if (file.exists(rds)) {
  gsva <- readRDS(rds)
} else {
  gsva <- gsva(logcounts(sce), gene_sets, method = "ssgsea", ssgsea.norm = FALSE)
  colnames(gsva) <- sce$groups
  saveRDS(gsva, rds)
}
# -------------------------------

# Fit model on pseudo-bulk GSVA results.
# --------------------------------------
design <- model.matrix(~ 0 + sce$idents)
colnames(design) <- names(idents)
fit <- lmFit(gsva, design)
contrast_mat <- makeContrasts(
  EC_Reln-IN_Sst, CA1_Wfs1-IN_Sst, CA3_Bok-IN_Sst,
  EC_Reln-CA1_Wfs1, CA1_Wfs1-CA3_Bok, levels = design
)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat))
tests <- decideTests(cont_fit, "nestedF", p.value = 0.001)
tests_up <- tests[tests[ , 1] == 1 & tests[ , 2] == 1 & tests[ , 3] == 1, ]
discard <- which(rownames(tests_up) %in% rownames(tests_up[rowSums(tests_up == -1) > 0, ]))
if (length(discard) > 0) {
  tests_up <- tests_up[-discard, ]
}
tests_down <- tests[tests[ , 1] == -1 & tests[ , 2] == -1 & tests[ , 3] == -1, ]
discard <- which(rownames(tests_down) %in% rownames(tests_down[rowSums(tests_down == 1) > 0, ]))
if (length(discard) > 0) {
  tests_down <- tests_down[-discard, ]
}
results <- topTable(cont_fit, number = Inf)

up <- results[rownames(results) %in% rownames(tests_up), ]
down <- results[rownames(results) %in% rownames(tests_down), ]
all <- rbind(up, down)
if (length(all) > 0) {
  all <- all[order(-all$F), ]
}
gsva_list_pseudobulk <- list(all, up, down)
names(gsva_list_pseudobulk) <- c(
  "All DE", paste0("Upregulated in ", names(idents)[1]),
  paste0("Downregulated in ", names(idents)[2])
)
# --------------------------------------

# Fit a strict model on pseudo-bulk GSVA results.
# -----------------------------------------------
design <- model.matrix(~ 0 + sce$idents)
colnames(design) <- names(idents)
fit <- lmFit(gsva, design)
contrast_mat <- makeContrasts(
  EC_Reln-IN_Sst, EC_Reln-CA3_Bok, EC_Reln-CA1_Wfs1,
  CA1_Wfs1-CA3_Bok, CA3_Bok-IN_Sst, levels = design
)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat))
tests <- decideTests(cont_fit, "nestedF", p.value = 0.005)
tests_up <- tests[tests[ , 1] == 1 & tests[ , 2] == 1 & tests[ , 3] == 1, ]
discard <- which(rownames(tests_up) %in% rownames(tests_up[rowSums(tests_up == -1) > 0, ]))
if (length(discard) > 0) {
  tests_up <- tests_up[-discard, ]
}
tests_down <- tests[tests[ , 1] == -1 & tests[ , 2] == -1 & tests[ , 3] == -1, ]
discard <- which(rownames(tests_down) %in% rownames(tests_down[rowSums(tests_down == 1) > 0, ]))
if (length(discard) > 0) {
  tests_down <- tests_down[-discard, ]
}
results <- topTable(cont_fit, number = Inf)

up <- results[rownames(results) %in% rownames(tests_up), ]
down <- results[rownames(results) %in% rownames(tests_down), ]
all <- rbind(up, down)
if (length(all) > 0) {
  all <- all[order(-all$F), ]
}
gsva_list_pseudobulk_strict <- list(all, up, down)
names(gsva_list_pseudobulk_strict) <- c(
  "All DE", paste0("Upregulated in ", names(idents)[1]),
  paste0("Downregulated in ", names(idents)[2])
)
# -----------------------------------------------

# Fit a stricter model on pseudo-bulk GSVA results.
# -------------------------------------------------
design <- model.matrix(~ 0 + sce$idents)
colnames(design) <- names(idents)
fit <- lmFit(gsva, design)
contrast_mat <- makeContrasts(
  EC_Reln-IN_Sst, EC_Reln-CA3_Bok, CA1_Wfs1-IN_Sst, CA1_Wfs1-CA3_Bok,
  EC_Reln-CA1_Wfs1, CA3_Bok-IN_Sst, levels = design
)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat))
tests <- decideTests(cont_fit, "nestedF", p.value = 0.01)
tests_up <- tests[tests[ , 1] == 1 & tests[ , 2] == 1 & tests[ , 3] == 1 & tests[ , 4] == 1, ]
discard <- which(rownames(tests_up) %in% rownames(tests_up[rowSums(tests_up == -1) > 0, ]))
if (length(discard) > 0) {
  tests_up <- tests_up[-discard, ]
}
tests_down <- tests[tests[ , 1] == -1 & tests[ , 2] == -1 & tests[ , 3] == -1 & tests[ , 4] == -1, ]
discard <- which(rownames(tests_down) %in% rownames(tests_down[rowSums(tests_down == 1) > 0, ]))
if (length(discard) > 0) {
  tests_down <- tests_down[-discard, ]
}
results <- topTable(cont_fit, number = Inf)

up <- results[rownames(results) %in% rownames(tests_up), ]
down <- results[rownames(results) %in% rownames(tests_down), ]
all <- rbind(up, down)
if (length(all) > 0) {
  all <- all[order(-all$F), ]
}
gsva_list_pseudobulk_stricter <- list(all, up, down)
names(gsva_list_pseudobulk_stricter) <- c(
  "All DE", paste0("Upregulated in ", names(idents)[1]),
  paste0("Downregulated in ", names(idents)[2])
)
# -------------------------------------------------

# Fit the strictest model on pseudo-bulk GSVA results.
# ----------------------------------------------------
design <- model.matrix(~ 0 + sce$idents)
colnames(design) <- names(idents)
fit <- lmFit(gsva, design)
contrast_mat <- makeContrasts(EC_Reln-CA1_Wfs1, CA1_Wfs1-CA3_Bok, CA3_Bok-IN_Sst, levels = design)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat))
tests <- decideTests(cont_fit, "nestedF", p.value = 0.05)
tests_up <- tests[tests[ , 1] == 1 & tests[ , 2] == 1 & tests[ , 3] == 1, ]
discard <- which(rownames(tests_up) %in% rownames(tests_up[rowSums(tests_up == -1) > 0, ]))
if (length(discard) > 0) {
  tests_up <- tests_up[-discard, ]
}
tests_down <- tests[tests[ , 1] == -1 & tests[ , 2] == -1 & tests[ , 3] == -1, ]
discard <- which(rownames(tests_down) %in% rownames(tests_down[rowSums(tests_down == 1) > 0, ]))
if (length(discard) > 0) {
  tests_down <- tests_down[-discard, ]
}
results <- topTable(cont_fit, number = Inf)

up <- results[rownames(results) %in% rownames(tests_up), ]
down <- results[rownames(results) %in% rownames(tests_down), ]
all <- rbind(up, down)
if (length(all) > 0) {
  all <- all[order(-all$F), ]
}
gsva_list_pseudobulk_strictest <- list(all, up, down)
names(gsva_list_pseudobulk_strictest) <- c(
  "All DE", paste0("Upregulated in ", names(idents)[1]),
  paste0("Downregulated in ", names(idents)[2])
)
# ----------------------------------------------------

data <- data.frame(
  x = c(
    dim(gsva_list_pseudobulk[[1]])[1], dim(gsva_list_pseudobulk_strict[[1]])[1],
    dim(gsva_list_pseudobulk_stricter[[1]])[1], dim(gsva_list_pseudobulk_strictest[[1]])[1]
  ),
  y = c(
    dim(gsva_list_pseudobulk[[1]])[1], dim(gsva_list_pseudobulk_strict[[1]])[1],
    dim(gsva_list_pseudobulk_stricter[[1]])[1], dim(gsva_list_pseudobulk_strictest[[1]])[1]
  )
)
ggplot(data, aes(data$x, data$y)) +
  geom_point() +
  geom_smooth(method = lm) +
  geom_label_repel(
    aes(label = c("initial_model", "strict_model", "stricter_model", "strictest_model"))
  )
```

**Upregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Initial Model**

```{r}
ncol <- ncol(gsva_list_pseudobulk[[2]])
datatable_download_exp(gsva_list_pseudobulk[[2]][(ncol-3):ncol])
```

**Upregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Strict Model**

```{r}
ncol <- ncol(gsva_list_pseudobulk_strict[[2]])
datatable_download_exp(gsva_list_pseudobulk_strict[[2]][(ncol-3):ncol])
```

**Upregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Stricter Model**

```{r}
ncol <- ncol(gsva_list_pseudobulk_stricter[[2]])
datatable_download_exp(gsva_list_pseudobulk_stricter[[2]][(ncol-3):ncol])
```

**Upregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Strictest Model**

```{r}
ncol <- ncol(gsva_list_pseudobulk_strictest[[2]])
datatable_download_exp(gsva_list_pseudobulk_strictest[[2]][(ncol-3):ncol])
```

**Downregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Initial Model**

```{r}
ncol <- ncol(gsva_list_pseudobulk[[3]])
datatable_download_exp(gsva_list_pseudobulk[[3]][(ncol-3):ncol])
```

**Downregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Strict Model**

```{r}
ncol <- ncol(gsva_list_pseudobulk_strict[[3]])
datatable_download_exp(gsva_list_pseudobulk_strict[[3]][(ncol-3):ncol])
```

**Downregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Stricter Model**

```{r}
ncol <- ncol(gsva_list_pseudobulk_stricter[[3]])
datatable_download_exp(gsva_list_pseudobulk_stricter[[3]][(ncol-3):ncol])
```

**Downregulated in direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Strictest Model**

```{r}
ncol <- ncol(gsva_list_pseudobulk_strictest[[3]])
datatable_download_exp(gsva_list_pseudobulk_strictest[[3]][(ncol-3):ncol])
```

# Differentially Expressed Genes

We fit the same models as before, this time on the genes themselves.
Please collapse the code block for details.

```{r}
# Fit model on pseudo-bulk counts.
# --------------------------------
design <- model.matrix(~ 0 + sce$idents)
colnames(design) <- names(idents)
fit <- lmFit(logcounts(sce), design)
contrast_mat <- makeContrasts(
  EC_Reln-IN_Sst, CA1_Wfs1-IN_Sst, CA3_Bok-IN_Sst,
  EC_Reln-CA1_Wfs1, CA1_Wfs1-CA3_Bok, levels = design
)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat), robust = TRUE, trend = TRUE)
tests <- decideTests(cont_fit, "nestedF", p.value = 0.001)
tests_up <- tests[tests[ , 1] == 1 & tests[ , 2] == 1 & tests[ , 3] == 1, ]
discard <- which(rownames(tests_up) %in% rownames(tests_up[rowSums(tests_up == -1) > 0, ]))
if (length(discard) > 0) {
  tests_up <- tests_up[-discard, ]
}
tests_down <- tests[tests[ , 1] == -1 & tests[ , 2] == -1 & tests[ , 3] == -1, ]
discard <- which(rownames(tests_down) %in% rownames(tests_down[rowSums(tests_down == 1) > 0, ]))
if (length(discard) > 0) {
  tests_down <- tests_down[-discard, ]
}
results <- topTable(cont_fit, number = Inf)
# --------------------------------------

up <- results[rownames(results) %in% rownames(tests_up), ]
down <- results[rownames(results) %in% rownames(tests_down), ]
all <- rbind(up, down)
if (length(all) > 0) {
  all <- all[order(-all$F), ]
}
markers_list_pseudobulk <- list(all, up, down)

# Fit a strict model on pseudo-bulk counts.
# -----------------------------------------
design <- model.matrix(~ 0 + sce$idents)
colnames(design) <- names(idents)
fit <- lmFit(logcounts(sce), design)
contrast_mat <- makeContrasts(
  EC_Reln-IN_Sst, EC_Reln-CA3_Bok, EC_Reln-CA1_Wfs1,
  CA1_Wfs1-CA3_Bok, CA3_Bok-IN_Sst, levels = design
)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat), robust = TRUE, trend = TRUE)
tests <- decideTests(cont_fit, "nestedF", p.value = 0.005)
tests_up <- tests[tests[ , 1] == 1 & tests[ , 2] == 1 & tests[ , 3] == 1, ]
discard <- which(rownames(tests_up) %in% rownames(tests_up[rowSums(tests_up == -1) > 0, ]))
if (length(discard) > 0) {
  tests_up <- tests_up[-discard, ]
}
tests_down <- tests[tests[ , 1] == -1 & tests[ , 2] == -1 & tests[ , 3] == -1, ]
discard <- which(rownames(tests_down) %in% rownames(tests_down[rowSums(tests_down == 1) > 0, ]))
if (length(discard) > 0) {
  tests_down <- tests_down[-discard, ]
}
results <- topTable(cont_fit, number = Inf)
# -----------------------------------------

up <- results[rownames(results) %in% rownames(tests_up), ]
down <- results[rownames(results) %in% rownames(tests_down), ]
all <- rbind(up, down)
if (length(all) > 0) {
  all <- all[order(-all$F), ]
}
markers_list_pseudobulk_strict <- list(all, up, down)

# Fit a stricter model on pseudo-bulk counts.
# -------------------------------------------
design <- model.matrix(~ 0 + sce$idents)
colnames(design) <- names(idents)
fit <- lmFit(logcounts(sce), design)
contrast_mat <- makeContrasts(
  EC_Reln-IN_Sst, EC_Reln-CA3_Bok, CA1_Wfs1-IN_Sst, CA1_Wfs1-CA3_Bok,
  EC_Reln-CA1_Wfs1, CA3_Bok-IN_Sst, levels = design
)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat), robust = TRUE, trend = TRUE)
tests <- decideTests(cont_fit, "nestedF", p.value = 0.01)
tests_up <- tests[tests[ , 1] == 1 & tests[ , 2] == 1 & tests[ , 3] == 1 & tests[ , 4] == 1, ]
discard <- which(rownames(tests_up) %in% rownames(tests_up[rowSums(tests_up == -1) > 0, ]))
if (length(discard) > 0) {
  tests_up <- tests_up[-discard, ]
}
tests_down <- tests[tests[ , 1] == -1 & tests[ , 2] == -1 & tests[ , 3] == -1 & tests[ , 4] == -1, ]
discard <- which(rownames(tests_down) %in% rownames(tests_down[rowSums(tests_down == 1) > 0, ]))
if (length(discard) > 0) {
  tests_down <- tests_down[-discard, ]
}
results <- topTable(cont_fit, number = Inf)
# -------------------------------------------

up <- results[rownames(results) %in% rownames(tests_up), ]
down <- results[rownames(results) %in% rownames(tests_down), ]
all <- rbind(up, down)
if (length(all) > 0) {
  all <- all[order(-all$F), ]
}
markers_list_pseudobulk_stricter <- list(all, up, down)

# Fit the strictest model on pseudo-bulk counts.
# ----------------------------------------------
design <- model.matrix(~ 0 + sce$idents)
colnames(design) <- names(idents)
fit <- lmFit(logcounts(sce), design)
contrast_mat <- makeContrasts(EC_Reln-CA1_Wfs1, CA1_Wfs1-CA3_Bok, CA3_Bok-IN_Sst, levels = design)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat), robust = TRUE, trend = TRUE)
tests <- decideTests(cont_fit, "nestedF", p.value = 0.05)
tests_up <- tests[tests[ , 1] == 1 & tests[ , 2] == 1 & tests[ , 3] == 1, ]
discard <- which(rownames(tests_up) %in% rownames(tests_up[rowSums(tests_up == -1) > 0, ]))
if (length(discard) > 0) {
  tests_up <- tests_up[-discard, ]
}
tests_down <- tests[tests[ , 1] == -1 & tests[ , 2] == -1 & tests[ , 3] == -1, ]
discard <- which(rownames(tests_down) %in% rownames(tests_down[rowSums(tests_down == 1) > 0, ]))
if (length(discard) > 0) {
  tests_down <- tests_down[-discard, ]
}
results <- topTable(cont_fit, number = Inf)
# ----------------------------------------------

up <- results[rownames(results) %in% rownames(tests_up), ]
down <- results[rownames(results) %in% rownames(tests_down), ]
all <- rbind(up, down)
if (length(all) > 0) {
  all <- all[order(-all$F), ]
}
markers_list_pseudobulk_strictest <- list(all, up, down)

# Convert ENSEMBL IDs back to gene symbols.
# -----------------------------------------
genes <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(markers_list_pseudobulk[[2]]), ]
genes <- genes[order(match(genes$ensembl_gene_id, rownames(markers_list_pseudobulk[[2]]))), ]
up <- markers_list_pseudobulk[[2]]
rownames(up) <- genes$external_gene_name

genes <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(markers_list_pseudobulk[[3]]), ]
genes <- genes[order(match(genes$ensembl_gene_id, rownames(markers_list_pseudobulk[[3]]))), ]
down <- markers_list_pseudobulk[[3]]
rownames(down) <- genes$external_gene_name

all <- rbind(up, down)
all <- all[order(-all$F), ]
markers_list_symbols_pseudobulk <- list(all, up, down)

genes <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(markers_list_pseudobulk_strict[[2]]), ]
genes <- genes[order(match(genes$ensembl_gene_id, rownames(markers_list_pseudobulk_strict[[2]]))), ]
up <- markers_list_pseudobulk_strict[[2]]
rownames(up) <- genes$external_gene_name

genes <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(markers_list_pseudobulk_strict[[3]]), ]
genes <- genes[order(match(genes$ensembl_gene_id, rownames(markers_list_pseudobulk_strict[[3]]))), ]
down <- markers_list_pseudobulk_strict[[3]]
rownames(down) <- genes$external_gene_name

all <- rbind(up, down)
all <- all[order(-all$F), ]
markers_list_symbols_pseudobulk_strict <- list(all, up, down)

genes <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(markers_list_pseudobulk_stricter[[2]]), ]
genes <- genes[
  order(match(genes$ensembl_gene_id, rownames(markers_list_pseudobulk_stricter[[2]]))),
]
up <- markers_list_pseudobulk_stricter[[2]]
rownames(up) <- genes$external_gene_name

genes <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(markers_list_pseudobulk_stricter[[3]]), ]
genes <- genes[
  order(match(genes$ensembl_gene_id, rownames(markers_list_pseudobulk_stricter[[3]]))),
]
down <- markers_list_pseudobulk_stricter[[3]]
rownames(down) <- genes$external_gene_name

all <- rbind(up, down)
all <- all[order(-all$F), ]
markers_list_symbols_pseudobulk_stricter <- list(all, up, down)

genes <- gene_anno[
  gene_anno$ensembl_gene_id %in% rownames(markers_list_pseudobulk_strictest[[2]]),
]
genes <- genes[
  order(match(genes$ensembl_gene_id, rownames(markers_list_pseudobulk_strictest[[2]]))),
]
up <- markers_list_pseudobulk_strictest[[2]]
rownames(up) <- genes$external_gene_name

genes <- gene_anno[
  gene_anno$ensembl_gene_id %in% rownames(markers_list_pseudobulk_strictest[[3]]),
]
genes <- genes[
  order(match(genes$ensembl_gene_id, rownames(markers_list_pseudobulk_strictest[[3]]))),
]
down <- markers_list_pseudobulk_strictest[[3]]
rownames(down) <- genes$external_gene_name

all <- rbind(up, down)
all <- all[order(-all$F), ]
markers_list_symbols_pseudobulk_strictest <- list(all, up, down)
# -----------------------------------------

# Create new Seurat object with gene symbols.
# -------------------------------------------
new_mat <- GetAssayData(seurat)
rownames(new_mat) <- gene_anno$external_gene_name
seurat_symbols <- CreateSeuratObject(new_mat, meta.data = seurat[[]])
Idents(seurat_symbols) <- "idents"
seurat_symbols <- SetAssayData(
  seurat_symbols, new.data = log2(as.matrix(GetAssayData(seurat_symbols, "counts")) + 1)
)
seurat_symbols <- SetAssayData(
  seurat_symbols, "scale.data", t(scale(t(GetAssayData(seurat_symbols)), FALSE))
)
# -------------------------------------------

data <- data.frame(
  x = c(
    dim(markers_list_pseudobulk[[1]])[1], dim(markers_list_pseudobulk_strict[[1]])[1],
    dim(markers_list_pseudobulk_stricter[[1]])[1], dim(markers_list_pseudobulk_strictest[[1]])[1]
  ),
  y = c(
    dim(markers_list_pseudobulk[[1]])[1], dim(markers_list_pseudobulk_strict[[1]])[1],
    dim(markers_list_pseudobulk_stricter[[1]])[1], dim(markers_list_pseudobulk_strictest[[1]])[1]
  )
)
ggplot(data, aes(data$x, data$y)) +
  geom_point() +
  geom_smooth(method = lm) +
  geom_label_repel(
    aes(label = c("initial_model", "strict_model", "stricter_model", "strictest_model"))
  )
```

**Upregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Initial Model**

```{r}
ncol <- ncol(markers_list_symbols_pseudobulk[[2]])
datatable_download_exp(markers_list_symbols_pseudobulk[[2]][(ncol-3):ncol])
```

**Upregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Strict Model**

```{r}
ncol <- ncol(markers_list_symbols_pseudobulk_strict[[2]])
datatable_download_exp(markers_list_symbols_pseudobulk_strict[[2]][(ncol-3):ncol])
```

**Upregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Stricter Model**

```{r}
ncol <- ncol(markers_list_symbols_pseudobulk_stricter[[2]])
datatable_download_exp(markers_list_symbols_pseudobulk_stricter[[2]][(ncol-3):ncol])
```

**Upregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Strictest Model**

```{r}
ncol <- ncol(markers_list_symbols_pseudobulk_strictest[[2]])
datatable_download_exp(markers_list_symbols_pseudobulk_strictest[[2]][(ncol-3):ncol])
```

**Downregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Initial Model**

```{r}
ncol <- ncol(markers_list_symbols_pseudobulk[[3]])
datatable_download_exp(markers_list_symbols_pseudobulk[[3]][(ncol-3):ncol])
```

**Downregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Strict Model**

```{r}
ncol <- ncol(markers_list_symbols_pseudobulk_strict[[3]])
datatable_download_exp(markers_list_symbols_pseudobulk_strict[[3]][(ncol-3):ncol])
```

**Downregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Stricter Model**

```{r}
ncol <- ncol(markers_list_symbols_pseudobulk_stricter[[3]])
datatable_download_exp(markers_list_symbols_pseudobulk_stricter[[3]][(ncol-3):ncol])
```

**Downregulated in Direction of `r names(idents)[1]` `r gene_set_name` Pseudobulk Strictest Model**

```{r}
ncol <- ncol(markers_list_symbols_pseudobulk_strictest[[3]])
datatable_download_exp(markers_list_symbols_pseudobulk_strictest[[3]][(ncol-3):ncol])
```

# Gene Set Heatmaps

In this section, DE gene sets and genes are aggregated, filtered, and optimally clustered following the guidelines in the flowchart.
The main output are heatmaps with word cloud summarizations of the cluster modules.
The label color indicates the most stringent model that was fit, where black is the most lenient and from yellow to orange to red is more stringent.

```{r, fig.width = 20, fig.height = 40}
# TODO: Comments and refactoring.
# -------------------------------

anno_color <- hue_pal()(length(unique(sce$external_donor_name_id)))
color3 <- colorRamp2(
  c(min(gsva), (max(gsva) + min(gsva)) / 2, max(gsva)),
  c(brewer.pal(3, "RdBu")[3], brewer.pal(3, "RdBu")[2], brewer.pal(3, "RdBu")[1])
)

gsva_list_pseudobulk_all <- list(
  c(
    rownames(gsva_list_pseudobulk[[1]]), rownames(gsva_list_pseudobulk_strict[[1]]),
    rownames(gsva_list_pseudobulk_stricter[[1]]), rownames(gsva_list_pseudobulk_strictest[[1]])
  ),
  c(
    rownames(gsva_list_pseudobulk[[2]]), rownames(gsva_list_pseudobulk_strict[[2]]),
    rownames(gsva_list_pseudobulk_stricter[[2]]), rownames(gsva_list_pseudobulk_strictest[[2]])
  ),
  c(
    rownames(gsva_list_pseudobulk[[3]]), rownames(gsva_list_pseudobulk_strict[[3]]),
    rownames(gsva_list_pseudobulk_stricter[[3]]), rownames(gsva_list_pseudobulk_strictest[[3]])
  )
)
markers_list_pseudobulk_all <- list(
  c(
    rownames(markers_list_pseudobulk[[1]]),
    rownames(markers_list_pseudobulk_strict[[1]]),
    rownames(markers_list_pseudobulk_stricter[[1]]),
    rownames(markers_list_pseudobulk_strictest[[1]])
  ),
  c(
    rownames(markers_list_pseudobulk[[2]]),
    rownames(markers_list_pseudobulk_strict[[2]]),
    rownames(markers_list_pseudobulk_stricter[[2]]),
    rownames(markers_list_pseudobulk_strictest[[2]])
  ),
  c(
    rownames(markers_list_pseudobulk[[3]]),
    rownames(markers_list_pseudobulk_strict[[3]]),
    rownames(markers_list_pseudobulk_stricter[[3]]),
    rownames(markers_list_pseudobulk_strictest[[3]])
  )
)
markers_list_symbols_pseudobulk_all <- list(
  c(
    rownames(markers_list_symbols_pseudobulk[[1]]),
    rownames(markers_list_symbols_pseudobulk_strict[[1]]),
    rownames(markers_list_symbols_pseudobulk_stricter[[1]]),
    rownames(markers_list_symbols_pseudobulk_strictest[[1]])
  ),
  c(
    rownames(markers_list_symbols_pseudobulk[[2]]),
    rownames(markers_list_symbols_pseudobulk_strict[[2]]),
    rownames(markers_list_symbols_pseudobulk_stricter[[2]]),
    rownames(markers_list_symbols_pseudobulk_strictest[[2]])
  ),
  c(
    rownames(markers_list_symbols_pseudobulk[[3]]),
    rownames(markers_list_symbols_pseudobulk_strict[[3]]),
    rownames(markers_list_symbols_pseudobulk_stricter[[3]]),
    rownames(markers_list_symbols_pseudobulk_strictest[[3]])
  )
)

mat <- gsva
mat <- mat[rownames(mat) %in% gsva_list_pseudobulk_all[[1]], ]
mat_up <- mat[rownames(mat) %in% gsva_list_pseudobulk_all[[2]], ]
mat_down <- mat[rownames(mat) %in% gsva_list_pseudobulk_all[[3]], ]
gene_sets_sub_up <- gene_sets[names(gene_sets) %in% rownames(mat_up)]
up_vector <- vector()
for (j in seq(length(gene_sets_sub_up@.Data))) {
  if (any(gene_sets_sub_up[[j]]@geneIds %in% markers_list_pseudobulk_all[[2]])) {
    up_vector <- append(up_vector, names(gene_sets_sub_up)[j])
  }
}
gene_sets_sub_down <- gene_sets[names(gene_sets) %in% rownames(mat_down)]
down_vector <- c()
for (j in seq(length(gene_sets_sub_down@.Data))) {
  if (any(gene_sets_sub_down[[j]]@geneIds %in% markers_list_pseudobulk_all[[3]])) {
    down_vector <- append(down_vector, names(gene_sets_sub_down)[j])
  }
}
all_vector <- append(up_vector, down_vector)
mat <- mat[rownames(mat) %in% all_vector, ]
gene_sets_sub <- gene_sets[names(gene_sets) %in% rownames(mat)]
gene_sets_sub_ids <- gene_sets_sub
for (j in seq(length(gene_sets_sub_ids@.Data))) {
  suppressWarnings(gene_sets_sub_ids[[j]]@setName <- gene_sets_sub_ids[[j]]@shortDescription)
}

discard <- computeGeneSetsOverlapMax(
  gene_sets_sub_ids, unique(unlist(geneIds(gene_sets_sub_ids)))
)
discard[!upper.tri(discard)] <- 0
discard <- colnames(discard)[colSums(discard) == 0]
discard <- which(names(gene_sets_sub_ids) %in% discard)
mat <- mat[-discard, ]
gene_sets_sub <- gene_sets_sub[-discard, ]
gene_sets_sub_ids <- gene_sets_sub_ids[-discard, ]

gene_set_overlap <- computeGeneSetsOverlapMax(
  gene_sets_sub_ids, unique(unlist(geneIds(gene_sets_sub_ids)))
)
clustering <- hclust(get_dist(gene_set_overlap, "spearman"), "ward.D2")

anno <- HeatmapAnnotation(
  donor = sce$external_donor_name_id,
  cell_type = anno_block(
    gp = gpar(fill = "lightgray", col = "lightgray"),
    labels = c(
      names(idents)[[1]], names(idents)[[2]], names(idents)[[3]], names(idents)[[4]]
    ),
    labels_gp = gpar(col = "black", fontsize = 20)
  ),
  col = list(
    donor = c(
      "475" = anno_color[1], "476" = anno_color[2],
      "527" = anno_color[3], "528" = anno_color[4],
      "456" = anno_color[5], "471" = anno_color[6]
    )
  )
)
modules_up <- rownames(mat)[rownames(mat) %in% gsva_list_pseudobulk_all[[2]]]
modules_down <- rownames(mat)[rownames(mat) %in% gsva_list_pseudobulk_all[[3]]]

module_gene_sets_sub <- gene_sets[names(gene_sets) %in% modules_up]
frequent_genes_tmp <- as.data.frame(table(unlist(geneIds(module_gene_sets_sub))))
frequent_genes_tmp <- frequent_genes_tmp[
  frequent_genes_tmp$Var1 %in% gene_anno$ensembl_gene_id,
]
rownames(frequent_genes_tmp) <- NULL
frequent_genes_up <- frequent_genes_tmp

module_gene_sets_sub <- gene_sets[names(gene_sets) %in% modules_down]
frequent_genes_tmp <- as.data.frame(table(unlist(geneIds(module_gene_sets_sub))))
frequent_genes_tmp <- frequent_genes_tmp[
  frequent_genes_tmp$Var1 %in% gene_anno$ensembl_gene_id,
]
rownames(frequent_genes_tmp) <- NULL
frequent_genes_down <- frequent_genes_tmp
frequent_genes <- rbind(frequent_genes_up, frequent_genes_down)

node_data <- melt(geneIds(gene_sets_sub))
node_data <- node_data[node_data$value %in% frequent_genes$Var1, ]
names(node_data)[1] <- "ensembl_gene_id"
names(node_data)[2] <- "gene_set"
node_data$direction <- ifelse(
  node_data$gene_set %in% gsva_list_pseudobulk_all[[2]], "up", "down"
)

unique_direction <- as.data.frame.matrix(table(node_data[ , c(1, 3)]), )
unique_direction$down <- unique_direction$down * -1
module_membership_norm <- unique_direction
module_membership_norm <- module_membership_norm[
  abs(rowSums(module_membership_norm)) >= 2,
]

hub_gene_all_GO <- table(unlist(geneIds(gene_sets)))
hub_gene_all_GO <- hub_gene_all_GO[
  names(hub_gene_all_GO) %in% rownames(module_membership_norm)
]

module_membership_upper_quart <- median(
  (abs(rowSums(module_membership_norm)) / hub_gene_all_GO) *
    abs(rowSums(module_membership_norm))
)

modules_with_hubs <- vector("list", 25)
modules_with_hubs[[1]] <- 0
hub_gene_list <- list(gene_anno)
for (l in 2:26) {
  set.seed(1)
  heatmap <- Heatmap(
    mat, cluster_rows = clustering, cluster_columns = FALSE, show_column_names = FALSE,
    show_row_names = FALSE, show_heatmap_legend = FALSE, row_split = l,
  )
  modules <- row_order(heatmap)
  hub_gene_list <- vector("list", length(modules))
  for (m in seq_along(modules)) {
    module_sets <- rownames(mat)[modules[[m]]]
    modules_up <- module_sets[module_sets %in% gsva_list_pseudobulk_all[[2]]]
    modules_down <- module_sets[module_sets %in% gsva_list_pseudobulk_all[[3]]]
    module_hub_genes <- vector()
    
    if (length(modules_up) == 0) {
    } else {
      module_gene_sets_sub <- gene_sets[names(gene_sets) %in% modules_up]
      frequent_genes <- as.data.frame(table(unlist(geneIds(module_gene_sets_sub))))
      hub_gene_all_GO_sub <- hub_gene_all_GO[
        names(hub_gene_all_GO) %in% frequent_genes$Var1
      ]
      frequent_genes <- frequent_genes[frequent_genes$Var1 %in% names(hub_gene_all_GO), ]
      frequent_genes$Freq <-
        (frequent_genes$Freq / hub_gene_all_GO_sub) * frequent_genes$Freq
      frequent_genes <- frequent_genes[
        frequent_genes$Freq >= module_membership_upper_quart,
      ]
      module_hub_genes_tmp <- gene_anno[
        gene_anno$ensembl_gene_id %in% frequent_genes$Var1,
      ]
      module_hub_genes_tmp <- module_hub_genes_tmp[
        module_hub_genes_tmp$ensembl_gene_id %in% markers_list_pseudobulk_all[[2]],
      ]
      module_hub_genes <- module_hub_genes_tmp$ensembl_gene_id
    }
    
    if (length(modules_down) == 0) {
    } else {
      module_gene_sets_sub <- gene_sets[names(gene_sets) %in% modules_down]
      frequent_genes <- as.data.frame(table(unlist(geneIds(module_gene_sets_sub))))
      hub_gene_all_GO_sub <- hub_gene_all_GO[
        names(hub_gene_all_GO) %in% frequent_genes$Var1
      ]
      frequent_genes <- frequent_genes[frequent_genes$Var1 %in% names(hub_gene_all_GO), ]
      frequent_genes$Freq <-
        (frequent_genes$Freq / hub_gene_all_GO_sub) * frequent_genes$Freq
      frequent_genes <- frequent_genes[
        frequent_genes$Freq >= module_membership_upper_quart,
      ]
      module_hub_genes_tmp <- gene_anno[
        gene_anno$ensembl_gene_id %in% frequent_genes$Var1,
      ]
      module_hub_genes_tmp <- module_hub_genes_tmp[
        module_hub_genes_tmp$ensembl_gene_id %in% markers_list_pseudobulk_all[[3]],
      ]
      module_hub_genes <- append(module_hub_genes, module_hub_genes_tmp$ensembl_gene_id)
    }
    
    hub_gene_list[[m]] <- module_hub_genes
  }
  modules_with_hubs[[l]] <- length(which(lengths(hub_gene_list) != 0)) / l
}
optimal_k <- 27 - which.max(rev(modules_with_hubs))
module_colors <- cols25(optimal_k)
clustering <- color_branches(clustering, optimal_k, col = module_colors)
set.seed(1)
heatmap <- Heatmap(
  mat, cluster_rows = clustering, cluster_columns = FALSE, show_column_names = FALSE,
  show_row_names = FALSE, show_heatmap_legend = FALSE, row_split = optimal_k
)

modules <- row_order(heatmap)
module_names <- modules
go_anno <- select(GO.db, names(gene_sets_sub_ids), c("GOID", "TERM", "DEFINITION"), "GOID")
for (l in seq_along(module_names)) {
  module_names[[l]] <- paste0(rownames(mat)[module_names[[l]]])
}
top_words_tmp <- data.frame(
  gene_sets = unlist(module_names),
  module = rep(seq_along(module_names), lapply(module_names, length))
)
top_words_all <- suppressWarnings(
  as.character(
    tapply(top_words_tmp$gene_sets, top_words_tmp$module, word_cloud)
  )
)
top_words <- suppressWarnings(
  as.character(
    tapply(top_words_tmp$gene_sets, top_words_tmp$module, word_cloud, width = 5)
  )
)
row_anno <-  HeatmapAnnotation(
  top_words = anno_block(
    gp = gpar(col = module_colors), labels = seq(optimal_k),
    labels_rot = 0, labels_gp = gpar(fontsize = 20)
  ),
  which = "row"
)

row_colors <- rownames(mat)
row_colors <- data.frame(
  row_colors = row_colors,
  DE_strict = row_colors %in% rownames(gsva_list_pseudobulk_strict[[1]]),
  DE_stricter = row_colors %in% rownames(gsva_list_pseudobulk_stricter[[1]]),
  DE_strictest = row_colors %in% rownames(gsva_list_pseudobulk_strictest[[1]])
) %>%
  mutate(
    type = case_when(
      DE_strictest == TRUE ~ "firebrick",
      DE_stricter == TRUE ~ "darkorange",
      DE_strict == TRUE ~ "darkgoldenrod",
      TRUE ~ "black"
    )
  )
row_colors <- row_colors$type

Heatmap(
  t(
    apply(
      mat, 1,
      function (x) (x - min(x)) / (max(x) - min(x))
    )
  ),
  color,
  cluster_rows = clustering,
  cluster_columns = FALSE,
  row_names_max_width = max_text_width(rownames(mat), gpar(fontsize = 8)),
  show_column_names = FALSE,
  column_split = sce$idents,
  top_annotation = anno,
  rect_gp = gpar(col = "lightgray"),
  column_title = " ",
  row_split = optimal_k,
  row_title = top_words,
  row_title_rot = 0,
  row_title_gp = gpar(fontsize = 10),
  row_names_gp = gpar(fontsize = 8, col = unlist(row_colors)),
  left_annotation = row_anno,
  row_gap = unit(2, "mm"),
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "scaled ssGSEA score")
)

for (l in 2:3) {
  exp_mat <- mat[rownames(mat) %in% gsva_list_pseudobulk_all[[l]], ]
  sort_mat <- mat[unlist(row_order(heatmap)), ]
  sort_mat <- sort_mat[rownames(sort_mat) %in% rownames(exp_mat), ]
  exp_mat <- exp_mat[match(rownames(sort_mat), rownames(exp_mat)), ]
  draw(
    Heatmap(
      exp_mat,
      color2,
      cluster_columns = FALSE,
      row_names_max_width = max_text_width(rownames(exp_mat),gpar(fontsize = 12)),
      show_column_names = FALSE,
      column_split = sce$idents,
      top_annotation = anno,
      row_names_gp = gpar(fontsize = 12),
      rect_gp = gpar(col = "lightgray"),
      column_title = " ",
      heatmap_legend_param = list(title = "ssGSEA score"),
      column_gap = unit(2, "mm")
    )
  )
}

hub_gene_data <- vector()
for (l in seq_along(modules)) {
  module_sets <- rownames(mat)[modules[[l]]]
  modules_up <- module_sets[module_sets %in% gsva_list_pseudobulk_all[[2]]]
  modules_down <- module_sets[module_sets %in% gsva_list_pseudobulk_all[[3]]]
  frequent_genes <- vector()
  frequent_genes_up <- vector()
  frequent_genes_down <- vector()
  
  if (length(modules_up) == 0) {
  } else {
    module_gene_sets_sub <- gene_sets[names(gene_sets) %in% modules_up]
    frequent_genes_tmp <- as.data.frame(table(unlist(geneIds(module_gene_sets_sub))))
    frequent_genes_tmp <- frequent_genes_tmp[
      frequent_genes_tmp$Var1 %in% gene_anno$ensembl_gene_id,
    ]
    rownames(frequent_genes_tmp) <- NULL
    if (any(frequent_genes_tmp$Var1 %in% markers_list_pseudobulk_all[[1]])) {
      discard <- which(
        frequent_genes_tmp$Var1 %in% markers_list_pseudobulk_all[[1]] &
          frequent_genes_tmp$Var1 %in% markers_list_pseudobulk_all[[3]]
      )
      if (length(discard) > 0) {
        frequent_genes_tmp <- frequent_genes_tmp[-discard, ]
      }
    }
    frequent_genes_up <- frequent_genes_tmp
  }
  
  if (length(modules_down) == 0) {
  } else {
    module_gene_sets_sub <- gene_sets[names(gene_sets) %in% modules_down]
    frequent_genes_tmp <- as.data.frame(table(unlist(geneIds(module_gene_sets_sub))))
    frequent_genes_tmp <- frequent_genes_tmp[
      frequent_genes_tmp$Var1 %in% gene_anno$ensembl_gene_id,
    ]
    rownames(frequent_genes_tmp) <- NULL
    if (any(frequent_genes_tmp$Var1 %in% markers_list_pseudobulk_all[[1]])) {
      discard <- which(
        frequent_genes_tmp$Var1 %in% markers_list_pseudobulk_all[[1]] &
          frequent_genes_tmp$Var1 %in% markers_list_pseudobulk_all[[2]]
      )
      if (length(discard) > 0) {
        frequent_genes_tmp <- frequent_genes_tmp[-discard, ]
      }
    }
    frequent_genes_down <- frequent_genes_tmp
  }
  
  frequent_genes <- rbind(frequent_genes_up, frequent_genes_down)
  if (dim(frequent_genes)[1] != 0) {
    module_gene_sets_sub <- gene_sets[names(gene_sets) %in% module_sets]
    node_data <- melt(geneIds(module_gene_sets_sub))
    node_data <- node_data[node_data$value %in% frequent_genes$Var1, ]
    names(node_data)[1] <- "ensembl_gene_id"
    names(node_data)[2] <- "gene_set"
    gene_anno_sub <- gene_anno[
      gene_anno$ensembl_gene_id %in% node_data$ensembl_gene_id, -3
    ]
    node_data <- node_data[node_data$ensembl_gene_id %in% gene_anno_sub$ensembl_gene_id, ]
    node_data <- left_join(node_data, gene_anno_sub, by = "ensembl_gene_id")
    node_data$direction <- ifelse(
      node_data$gene_set %in% gsva_list_pseudobulk_all[[2]], "up", "down"
    )
    node_data$DE <- ifelse(
      node_data$ensembl_gene_id %in% markers_list_pseudobulk_all[[1]], "yes", "no"
    )
    node_data$module <- l
    hub_gene_data <- rbind(hub_gene_data, node_data)
  }
}

unique_direction <- as.data.frame.matrix(table(hub_gene_data[ , c(3, 4)]), )
unique_direction$down <- unique_direction$down * -1
discard <- which(rowSums(unique_direction) == 0)
if (length(discard) > 0) {
  unique_direction <- unique_direction[-discard, ]
}
module_membership_norm <- unique_direction
unique_direction <- ifelse(rowSums(unique_direction) > 0, "up", "down")
hub_gene_data <- hub_gene_data[
  hub_gene_data$external_gene_name %in% names(unique_direction),
]

rownames(hub_gene_data) <- NULL
discard <- vector()
for (i_gene in seq_along(hub_gene_data$external_gene_name)) {
  sub_gene <- hub_gene_data$external_gene_name[i_gene]
  sub_unique_direction <- unique_direction[which(names(unique_direction) == sub_gene)]
  if (hub_gene_data$direction[i_gene] != sub_unique_direction[[1]]) {
    discard <- append(discard, i_gene)
  }
}
hub_gene_data <- hub_gene_data[-discard, ]

frequent_genes_tmp <- as.data.frame(table(hub_gene_data$external_gene_name))
frequent_genes <- frequent_genes_tmp
hub_gene_data <- hub_gene_data[
  hub_gene_data$external_gene_name %in% frequent_genes$Var1,
]

hub_gene_data_up <- hub_gene_data[which(hub_gene_data$direction == "up"), ]
hub_gene_data_down <- hub_gene_data[which(hub_gene_data$direction == "down"), ]

hub_mat <- as.data.frame.matrix(table(hub_gene_data_up[ , c(3, 2)]), )
hub_mat <- hub_mat == 1
co_mat <- hub_mat %*% t(hub_mat)
diag(co_mat) <- 0
graph_up <- graph_from_adjacency_matrix(co_mat, "upper", TRUE)

edges_up <- get.edgelist(graph_up, FALSE)
set.seed(1)
layout_up <- qgraph.layout.fruchtermanreingold(
  edges_up, vcount = vcount(graph_up), E(graph_up)$weight,
  area = vcount(graph_up) ^ 2, repulse.rad = vcount(graph_up) ^ 2
)

hub_gene_all_GO <- table(unlist(geneIds(gene_sets)))
hub_gene_all_GO <- hub_gene_all_GO[
  names(hub_gene_all_GO) %in% unique(hub_gene_data_up$ensembl_gene_id)
]
sub_gene_anno <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(hub_gene_all_GO), ]
rownames(sub_gene_anno) <- NULL
sub_gene_anno <- sub_gene_anno[
  match(rownames(hub_gene_all_GO), sub_gene_anno$ensembl_gene_id),
]
rownames(hub_gene_all_GO) <- sub_gene_anno$external_gene_name
hub_gene_all_GO_up <- hub_gene_all_GO[order(names(hub_gene_all_GO))]

module_membership_up <- as.data.frame.matrix(table(hub_gene_data_up[ , c(3, 6)]), )
module_membership_binary_up <- module_membership_up
module_membership_binary_up[module_membership_binary_up > 0] <- 1
module_membership_list_up <- lapply(
  split(module_membership_up, row.names(module_membership_up)), unlist
)
module_network_colors_up <- module_colors[unique(hub_gene_data_up$module)]
V(graph_up)$pie.color = list(module_network_colors_up)

module_membership_norm_up <- module_membership_norm[
  rownames(module_membership_norm) %in% rownames(module_membership_up),
]

V(graph_up)$vertex.pie = list(module_network_colors_up)
V(graph_up)$vertex.shape <- "pie"
V(graph_up)$vertex.color <- module_membership_list_up
V(graph_up)$vertex.label.family = "sans"

DE_up <- vector()
for (l in seq(length(V(graph_up)))) {
  if (V(graph_up)[l]$name %in% rownames(markers_list_symbols_pseudobulk[[2]])) {
    DE_up <- append(DE_up, "yes")
  } else {
    DE_up <- append(DE_up, "no")
  }
}

DE_opp_up <- vector()
for (l in seq(length(V(graph_up)))) {
  if (V(graph_up)[l]$name %in% markers_list_symbols_pseudobulk_all[[3]]) {
    DE_opp_up <- append(DE_opp_up, "yes")
  } else {
    DE_opp_up <- append(DE_opp_up, "no")
  }
}

DE_strict_up <- vector()
for (l in seq(length(V(graph_up)))) {
  if (V(graph_up)[l]$name %in% rownames(markers_list_symbols_pseudobulk_strict[[2]])) {
    DE_strict_up <- append(DE_strict_up, "yes")
  } else {
    DE_strict_up <- append(DE_strict_up, "no")
  }
}

DE_stricter_up <- vector()
for (l in seq(length(V(graph_up)))) {
  if (V(graph_up)[l]$name %in% rownames(markers_list_symbols_pseudobulk_stricter[[2]])) {
    DE_stricter_up <- append(DE_stricter_up, "yes")
  } else {
    DE_stricter_up <- append(DE_stricter_up, "no")
  }
}

DE_strictest_up <- vector()
for (l in seq(length(V(graph_up)))) {
  if (V(graph_up)[l]$name %in% rownames(markers_list_symbols_pseudobulk_strictest[[2]])) {
    DE_strictest_up <- append(DE_strictest_up, "yes")
  } else {
    DE_strictest_up <- append(DE_strictest_up, "no")
  }
}

direction_up <- vector()
for (l in seq(length(E(graph_up)))) {
  hub_gene_sub_up <- hub_gene_data_up[
    hub_gene_data_up$external_gene_name %in% head_of(graph_up, l)[[1]]$name,
    ]
  direction_up <- append(direction_up, unique(hub_gene_sub_up$direction))
}
E(graph_up)$edge.color <- ifelse(direction_up == "up", "firebrick1", "dodgerblue")

hub_mat <- as.data.frame.matrix(table(hub_gene_data_down[ , c(3, 2)]), )
hub_mat <- hub_mat == 1
co_mat <- hub_mat %*% t(hub_mat)
diag(co_mat) <- 0
graph_down <- graph_from_adjacency_matrix(co_mat, "upper", TRUE)

edges_down <- get.edgelist(graph_down, FALSE)
set.seed(1)
layout_down <- qgraph.layout.fruchtermanreingold(
  edges_down, vcount = vcount(graph_down), E(graph_down)$weight,
  area = vcount(graph_down) ^ 2, repulse.rad = vcount(graph_down) ^ 2
)

hub_gene_all_GO <- table(unlist(geneIds(gene_sets)))
hub_gene_all_GO <- hub_gene_all_GO[
  names(hub_gene_all_GO) %in% unique(hub_gene_data_down$ensembl_gene_id)
]
sub_gene_anno <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(hub_gene_all_GO), ]
rownames(sub_gene_anno) <- NULL
sub_gene_anno <- sub_gene_anno[
  match(rownames(hub_gene_all_GO), sub_gene_anno$ensembl_gene_id),
]
rownames(hub_gene_all_GO) <- sub_gene_anno$external_gene_name
hub_gene_all_GO_down <- hub_gene_all_GO[order(names(hub_gene_all_GO))]

module_membership_down <- as.data.frame.matrix(table(hub_gene_data_down[ , c(3, 6)]), )
module_membership_binary_down <- module_membership_down
module_membership_binary_down[module_membership_binary_down > 0] <- 1
module_membership_list_down <- lapply(
  split(module_membership_down, row.names(module_membership_down)), unlist
)
module_network_colors_down <- module_colors[unique(hub_gene_data_down$module)]
V(graph_down)$pie.color = list(module_network_colors_down)

module_membership_norm_down <- module_membership_norm[
  rownames(module_membership_norm) %in% rownames(module_membership_down),
]

V(graph_down)$pie.color = list(module_network_colors_down)
V(graph_down)$vertex.shape <- "pie"
V(graph_down)$vertex.color <- module_membership_list_down
V(graph_down)$vertex.label.family = "sans"

DE_down <- vector()
for (l in seq(length(V(graph_down)))) {
  if (V(graph_down)[l]$name %in% rownames(markers_list_symbols_pseudobulk[[3]])) {
    DE_down <- append(DE_down, "yes")
  } else {
    DE_down <- append(DE_down, "no")
  }
}

DE_opp_down <- vector()
for (l in seq(length(V(graph_down)))) {
  if (V(graph_down)[l]$name %in% markers_list_symbols_pseudobulk_all[[2]]) {
    DE_opp_down <- append(DE_opp_down, "yes")
  } else {
    DE_opp_down <- append(DE_opp_down, "no")
  }
}

DE_strict_down <- vector()
for (l in seq(length(V(graph_down)))) {
  if (V(graph_down)[l]$name %in% rownames(markers_list_symbols_pseudobulk_strict[[3]])) {
    DE_strict_down <- append(DE_strict_down, "yes")
  } else {
    DE_strict_down <- append(DE_strict_down, "no")
  }
}

DE_stricter_down <- vector()
for (l in seq(length(V(graph_down)))) {
  if (
    V(graph_down)[l]$name %in% rownames(markers_list_symbols_pseudobulk_stricter[[3]])
  ) {
    DE_stricter_down <- append(DE_stricter_down, "yes")
  } else {
    DE_stricter_down <- append(DE_stricter_down, "no")
  }
}

DE_strictest_down <- vector()
for (l in seq(length(V(graph_down)))) {
  if (
    V(graph_down)[l]$name %in% rownames(markers_list_symbols_pseudobulk_strictest[[3]])
  ) {
    DE_strictest_down <- append(DE_strictest_down, "yes")
  } else {
    DE_strictest_down <- append(DE_strictest_down, "no")
  }
}

direction_down <- vector()
for (l in seq(length(E(graph_down)))) {
  hub_gene_sub_down <- hub_gene_data_down[
    hub_gene_data_down$external_gene_name %in% head_of(graph_down, l)[[1]]$name,
    ]
  direction_down <- append(direction_down, unique(hub_gene_sub_down$direction))
}
E(graph_down)$edge.color <- ifelse(direction_down == "up", "firebrick1", "dodgerblue")

hub_mat <- as.data.frame.matrix(table(hub_gene_data[ , c(3, 2)]), )
hub_mat <- hub_mat == 1
co_mat <- hub_mat %*% t(hub_mat)
diag(co_mat) <- 0
graph <- graph_from_adjacency_matrix(co_mat, "upper", TRUE)

edges <- get.edgelist(graph, FALSE)
set.seed(1)
layout <- qgraph.layout.fruchtermanreingold(
  edges, vcount = vcount(graph), E(graph)$weight,
  area = vcount(graph) ^ 2, repulse.rad = vcount(graph) ^ 2
)

hub_gene_all_GO <- table(unlist(geneIds(gene_sets)))
hub_gene_all_GO <- hub_gene_all_GO[
  names(hub_gene_all_GO) %in% unique(hub_gene_data$ensembl_gene_id)
]
sub_gene_anno <- gene_anno[gene_anno$ensembl_gene_id %in% rownames(hub_gene_all_GO), ]
rownames(sub_gene_anno) <- NULL
sub_gene_anno <- sub_gene_anno[
  match(rownames(hub_gene_all_GO), sub_gene_anno$ensembl_gene_id),
]
rownames(hub_gene_all_GO) <- sub_gene_anno$external_gene_name
hub_gene_all_GO <- hub_gene_all_GO[order(names(hub_gene_all_GO))]

module_membership <- as.data.frame.matrix(table(hub_gene_data[ , c(3, 6)]), )
module_membership_binary <- module_membership
module_membership_binary[module_membership_binary > 0] <- 1
module_membership_list <- lapply(
  split(module_membership, row.names(module_membership)), unlist
)
module_network_colors <- module_colors
module_membership_norm <- module_membership_norm[
  rownames(module_membership_norm) %in% rownames(module_membership),
]

V(graph)$pie.color = list(module_network_colors)
V(graph)$vertex.shape <- "pie"
V(graph)$vertex.color <- module_membership_list
V(graph)$vertex.label.family = "sans"

module_max_genes <- apply(module_membership_norm, 2, function (x) which(x == max(x)))
module_max_genes <- rownames(module_membership_norm)[unlist(module_max_genes)]
module_max <- vector()
for (l in seq(length(V(graph)))) {
  if (V(graph)[l]$name %in% module_max_genes) {
    module_max <- append(module_max, "yes")
  } else {
    module_max <- append(module_max, "no")
  }
}

unique_markers <- markers_list_symbols_pseudobulk_all[[2]][
  markers_list_symbols_pseudobulk_all[[2]] %notin%
    hub_gene_data_down$external_gene_name
]
unique_markers <- append(
  unique_markers,
  markers_list_symbols_pseudobulk_all[[3]][
    markers_list_symbols_pseudobulk_all[[3]] %notin%
      hub_gene_data_up$external_gene_name
  ]
)
DE <- vector()
for (l in seq(length(V(graph)))) {
  if (V(graph)[l]$name %in% unique_markers) {
    DE <- append(DE, "yes")
  } else {
    DE <- append(DE, "no")
  }
}

direction <- vector()
for (l in seq(length(E(graph)))) {
  hub_gene_sub <- hub_gene_data[
    hub_gene_data$external_gene_name %in% head_of(graph, l)[[1]]$name,
  ]
  direction <- append(direction, unique(hub_gene_sub$direction))
}
E(graph)$edge.color <- ifelse(direction == "up", "firebrick1", "dodgerblue")
# -------------------------------
```

```{r, fig.width = 20, fig.height = 20}
module_names <- modules
for (l in seq_along(module_names)) {
  module_names[[l]] <- paste0(rownames(mat)[module_names[[l]]])
}
row_colors <- module_names
for (l in seq_along(row_colors)) {
  tmp <- data.frame(
    row_colors = row_colors[[l]],
    DE_strict = row_colors[[l]] %in% rownames(gsva_list_pseudobulk_strict[[1]]),
    DE_stricter = row_colors[[l]] %in% rownames(gsva_list_pseudobulk_stricter[[1]]),
    DE_strictest = row_colors[[l]] %in% rownames(gsva_list_pseudobulk_strictest[[1]])
  ) %>%
    mutate(
      type = case_when(
        DE_strictest == TRUE ~ "firebrick",
        DE_stricter == TRUE ~ "darkorange",
        DE_strict == TRUE ~ "darkgoldenrod",
        TRUE ~ "black"
      )
    )
  tmp <- tmp$type
  row_colors[[l]] <- tmp
}

for (l in seq_along(module_names)) {
  exp_mat <- mat[rownames(mat) %in% module_names[[l]], ]
  sort_mat <- mat[unlist(row_order(heatmap)), ]
  sort_mat <- sort_mat[rownames(sort_mat) %in% rownames(exp_mat), ]
  exp_mat <- exp_mat[match(rownames(sort_mat), rownames(exp_mat)), ]
  draw(
    Heatmap(
      t(
        apply(
          exp_mat, 1,
          function (x) (x - min(x)) / (max(x) - min(x))
        )
      ),
      color,
      cluster_columns = FALSE,
      cluster_rows = FALSE,
      row_names_max_width = max_text_width(rownames(exp_mat), gpar(fontsize = 20)),
      show_column_names = FALSE,
      column_split = sce$idents,
      top_annotation = anno,
      row_names_gp = gpar(fontsize = 20, col = row_colors[[l]]),
      rect_gp = gpar(col = "lightgray"),
      column_title = paste0("Module ", l, ":\n", top_words[l]),
      column_title_gp = gpar(fontsize = 20),
      heatmap_legend_param = list(title = "scaled ssGSEA score"),
      column_gap = unit(2, "mm")
    )
  )
}
```

# Hub Gene Network

In order to pinpoint genes that may have the most functional contribution to a model, we create a graph network following the criteria in the flowchart.
Note that due to plotting errors in R Markdown, we simply load pre-computed images in and leave the code commented out for now.

![](../../../results/allen-mouse-EC/05-gsva/network.png)

![](../../../results/allen-mouse-EC/05-gsva/network-up.png)

![](../../../results/allen-mouse-EC/05-gsva/network-down.png)

```{r, fig.width = 20, fig.height = 40}
# TODO: Comments, refactoring, and fix R Markdown plots.
# ------------------------------------------------------
# DE_alt <- c(
#   rownames(markers_list_symbols_pseudobulk[[1]]),
#   rownames(markers_list_symbols_pseudobulk_strict[[1]]),
#   rownames(markers_list_symbols_pseudobulk_stricter[[1]]),
#   rownames(markers_list_symbols_pseudobulk_strictest[[1]])
# )
# 
# all_DE_match <- as.data.frame(
#   table(V(graph)$name[match(DE_alt, V(graph)$name)]), stringsAsFactors = FALSE
# )
# all_DE_match_tmp <- data.frame(Var1 = V(graph)$name[V(graph)$name %notin% DE_alt], Freq = 0)
# all_DE_match <- rbind(all_DE_match, all_DE_match_tmp)
# all_DE_match <- all_DE_match[order(all_DE_match$Var1), ]
# 
# module_membership_median <- median(
#   (abs(rowSums(module_membership_norm)) / hub_gene_all_GO) *
#   abs(rowSums(module_membership_norm))
# )
# 
# vertex_frame_color <- data.frame(DE = DE) %>%
#   mutate(
#     type = case_when(
#       DE == "yes" ~ "white",
#       TRUE ~ "darkgray"
#     )
#   )
# vertex_frame_color <- vertex_frame_color$type
# 
# vertex_label_color <- data.frame(DE = DE) %>%
#   mutate(
#     type = case_when(
#       DE == "yes" ~ "white",
#       TRUE ~ "darkgray"
#     )
#   )
# vertex_label_color <- vertex_label_color$type
# 
# vertex_label_font <- data.frame(DE = DE) %>%
#   mutate(
#     type = case_when(
#       TRUE ~ 2
#     )
#   )
# vertex_label_font <- vertex_label_font$type
# 
# vertex_label <- data.frame(DE = DE) %>%
#   mutate(
#     type = case_when(
#       TRUE ~ V(graph)$name
#     )
#   )
# vertex_label <- vertex_label$type
# vertex_label[vertex_label == "NA"] <- NA
# 
# par(bg = "black", mar = c(5.1, 4.1, 4.1, 250.1), xpd = TRUE)
# plot(
#     graph,
#     rescale = FALSE,
#     xlim = c(-1, 1),
#     ylim = c(-1, 1),
#     layout = norm_coords(layout),
#     vertex.size = sqrt(
#       (abs(rowSums(module_membership_norm)) / hub_gene_all_GO) *
#       abs(rowSums(module_membership_norm))
#     ) * 5,
#     vertex.label.color = vertex_label_color,
#     edge.width = E(graph)$weight ^ 2 / 2,
#     vertex.shape = "pie",
#     vertex.pie = module_membership_list,
#     edge.color = ifelse(direction == "up", "firebrick1", "dodgerblue"),
#     vertex.label.family = "sans",
#     vertex.label.font = vertex_label_font,
#     vertex.label.cex = (all_DE_match$Freq + 1) * 3, 1,
#     vertex.frame.color = vertex_frame_color,
#     vertex.label = vertex_label
# )
# legend(
#     "right",
#     legend = paste0(
#       "Module ", unique(hub_gene_data$module),
#       ": ", gsub("\n", " ", top_words[unique(hub_gene_data$module)])
#     ),
#     pch = 20,
#     col = module_network_colors,
#     pt.cex = 12,
#     cex = 8,
#     bty = "n",
#     text.col = "white",
#     inset = c(-0.5, 0)
# )
# 
# all_DE_match <- as.data.frame(
#   table(V(graph_up)$name[match(DE_alt, V(graph_up)$name)]), stringsAsFactors = FALSE
# )
# all_DE_match_tmp <- data.frame(Var1 = V(graph_up)$name[V(graph_up)$name %notin% DE_alt], Freq = 0)
# all_DE_match <- rbind(all_DE_match, all_DE_match_tmp)
# all_DE_match <- all_DE_match[order(all_DE_match$Var1), ]
# 
# module_membership_median_up <- median(
#   (abs(rowSums(module_membership_norm_up)) / hub_gene_all_GO_up) *
#   abs(rowSums(module_membership_norm_up))
# )
# 
# vertex_frame_color <- data.frame(DE_up = DE_up) %>%
#   mutate(
#     type = case_when(
#       (
#         DE_up == "yes" | DE_strict_up == "yes" | DE_stricter_up == "yes" | DE_strictest_up == "yes"
#       ) & DE_opp_up == "no" ~ "white",
#       TRUE ~ "darkgray"
#     )
#   )
# vertex_frame_color <- vertex_frame_color$type
# 
# vertex_label_color <- data.frame(DE_up = DE_up) %>%
#   mutate(
#     type = case_when(
#       (
#         DE_up == "yes" | DE_strict_up == "yes" | DE_stricter_up == "yes" | DE_strictest_up == "yes"
#       ) & DE_opp_up == "no" ~ "white",
#       TRUE ~ "darkgray"
#     )
#   )
# vertex_label_color <- vertex_label_color$type
# 
# vertex_label_font <- data.frame(DE_up = DE_up) %>%
#   mutate(
#     type = case_when(
#       TRUE ~ 2
#     )
#   )
# vertex_label_font <- vertex_label_font$type
# 
# vertex_label <- data.frame(DE_up = DE_up) %>%
#   mutate(
#     type = case_when(
#       TRUE ~ V(graph_up)$name
#     )
#   )
# vertex_label <- vertex_label$type
# vertex_label[vertex_label == "NA"] <- NA
# 
# par(bg = "black", mar = c(5.1, 4.1, 4.1, 250.1), xpd = TRUE)
# plot(
#     graph_up,
#     rescale = FALSE,
#     xlim = c(-1, 1),
#     ylim = c(-1, 1),
#     layout = norm_coords(layout_up),
#     vertex.size = sqrt(
#       (abs(rowSums(module_membership_norm_up)) / hub_gene_all_GO_up) *
#       abs(rowSums(module_membership_norm_up))
#     ) * 5,
#     vertex.label.color = vertex_label_color,
#     edge.width = E(graph_up)$weight ^ 2 / 4,
#     vertex.shape = "pie",
#     vertex.pie = module_membership_list_up,
#     edge.color = ifelse(direction_up == "up", "firebrick1", "dodgerblue"),
#     vertex.label.family = "sans",
#     vertex.label.font = vertex_label_font,
#     vertex.label.cex = ifelse(
#       (
#         DE_up == "yes" | DE_strict_up == "yes" | DE_stricter_up == "yes" | DE_strictest_up == "yes"
#       ) &
#         DE_opp_up == "no",
#       (all_DE_match$Freq + 3) * 2, 3
#     ),
#     vertex.frame.color = vertex_frame_color,
#     vertex.label = vertex_label
# )
# legend(
#     "right",
#     legend = paste0(
#       "Module ", unique(hub_gene_data_up$module),
#       ": ", gsub("\n", " ", top_words[unique(hub_gene_data_up$module)])
#     ),
#     pch = 20,
#     col = module_network_colors_up,
#     pt.cex = 12,
#     cex = 8,
#     bty = "n",
#     text.col = "white",
#     inset = c(-0.5, 0)
# )
# 
# all_DE_match <- as.data.frame(
#   table(V(graph_down)$name[match(DE_alt, V(graph_down)$name)]), stringsAsFactors = FALSE
# )
# all_DE_match_tmp <- data.frame(
#   Var1 = V(graph_down)$name[V(graph_down)$name %notin% DE_alt], Freq = 0
# )
# all_DE_match <- rbind(all_DE_match, all_DE_match_tmp)
# all_DE_match <- all_DE_match[order(all_DE_match$Var1), ]
# 
# module_membership_median_down <- median(
#   (abs(rowSums(module_membership_norm_down)) / hub_gene_all_GO_down) *
#   abs(rowSums(module_membership_norm_down))
# )
# 
# vertex_frame_color <- data.frame(DE_down = DE_down) %>%
#   mutate(
#     type = case_when(
#       (
#         DE_down == "yes" | DE_strict_down == "yes" |
#           DE_stricter_down == "yes" | DE_strictest_down == "yes"
#       ) &
#         DE_opp_down == "no" ~ "white",
#       TRUE ~ "darkgray"
#     )
#   )
# vertex_frame_color <- vertex_frame_color$type
# 
# vertex_label_color <- data.frame(DE_down = DE_down) %>%
#   mutate(
#     type = case_when(
#       (
#         DE_down == "yes" | DE_strict_down == "yes" |
#           DE_stricter_down == "yes" | DE_strictest_down == "yes"
#       ) &
#         DE_opp_down == "no" ~ "white",
#       TRUE ~ "darkgray"
#     )
#   )
# vertex_label_color <- vertex_label_color$type
# 
# vertex_label_font <- data.frame(DE_down = DE_down) %>%
#   mutate(
#     type = case_when(
#       TRUE ~ 2
#     )
#   )
# vertex_label_font <- vertex_label_font$type
# 
# vertex_label <- data.frame(DE_down = DE_down) %>%
#   mutate(
#     type = case_when(
#       TRUE ~ V(graph_down)$name
#     )
#   )
# vertex_label <- vertex_label$type
# vertex_label[vertex_label == "NA"] <- NA
# 
# par(bg = "black", mar = c(5.1, 4.1, 4.1, 250.1), xpd = TRUE)
# plot(
#     graph_down,
#     rescale = FALSE,
#     xlim = c(-1, 1),
#     ylim = c(-1, 1),
#     layout = norm_coords(layout_down),
#     vertex.size = sqrt(
#       (abs(rowSums(module_membership_norm_down)) / hub_gene_all_GO_down) *
#       abs(rowSums(module_membership_norm_down))
#     ) * 7,
#     vertex.label.color = vertex_label_color,
#     edge.width = E(graph_down)$weight ^ 2 / 2,
#     vertex.shape = "pie",
#     vertex.pie = module_membership_list_down,
#     edge.color = ifelse(direction_down == "up", "firebrick1", "dodgerblue"),
#     vertex.label.family = "sans",
#     vertex.label.font = vertex_label_font,
#     vertex.label.cex = ifelse(
#       (
#         DE_down == "yes" | DE_strict_down == "yes" |
#           DE_stricter_down == "yes" | DE_strictest_down == "yes"
#       ) &
#         DE_opp_down == "no",
#       (all_DE_match$Freq + 3) * 2, 3
#     ),
#     vertex.frame.color = vertex_frame_color,
#     vertex.label = vertex_label
# )
# legend(
#     "right",
#     legend = paste0(
#       "Module ", unique(hub_gene_data_down$module),
#       ": ", gsub("\n", " ", top_words[unique(hub_gene_data_down$module)])
#     ),
#     pch = 20,
#     col = module_network_colors_down,
#     pt.cex = 12,
#     cex = 8,
#     bty = "n",
#     text.col = "white",
#     inset = c(-0.5, 0)
# )
# ------------------------------------------------------
```

# Misc Metadata

Here some useful metadata can be found for further exploration of the data.

```{r}
datatable_download(data.frame(Module_Word_Cloud = top_words_all))
datatable_download(data.frame(GO_ID = go_anno$GOID, Gene_Set = go_anno$TERM, Definition = go_anno$DEFINITION))
datatable_download(
  data.frame(
    ENSEMBL_Gene_ID = hub_gene_data$ensembl_gene_id, Gene_Name = hub_gene_data$external_gene_name,
    Gene_Set = hub_gene_data$gene_set, Direction = hub_gene_data$direction,
    DE = hub_gene_data$DE, Module = hub_gene_data$module
  )
)
data <- as.data.frame(hub_gene_all_GO, row.names = NULL)
datatable_download(data_frame(Gene_Name = data$Var1, Frequency_Among_Gene_Sets = data$Freq))
```

# Gene Expression Per Gene Set

Finally, we display the per-cell expression of each gene within every DE gene set.
For DE genes, the label color indicates the most stringent model that was fit, where black is the most lenient and from yellow to orange to red is more stringent.

```{r}
anno <- HeatmapAnnotation(
  donor = seurat_symbols$external_donor_name_id,
  cell_type = anno_block(
    gp = gpar(fill = "lightgray", col = "lightgray"),
    labels = c(names(idents)[[1]], names(idents)[[2]], names(idents)[[3]], names(idents)[[4]]),
    labels_gp = gpar(col = "black", fontsize = 20)
  ),
  col = list(
    donor = c(
      "475" = anno_color[1], "476" = anno_color[2],
      "527" = anno_color[3], "528" = anno_color[4],
      "456" = anno_color[5], "471" = anno_color[6]
    )
  )
)
```

## Upregulated in the Direction of `r names(idents)[1]`

```{r, fig.height = 5, fig.width = 20}
set <- 2 # Up or downregulation?
if (length(gsva_list_pseudobulk_all[[set]]) > 0) {
  exp_mat <- mat
  exp_mat <- exp_mat[rownames(exp_mat) %in% gsva_list_pseudobulk_all[[set]], ]
  sort_mat <- mat[unlist(row_order(heatmap)), ]
  sort_mat <- sort_mat[rownames(sort_mat) %in% rownames(exp_mat), ]
  exp_mat <- exp_mat[match(rownames(sort_mat), rownames(exp_mat)), ]
  for (i in 1:nrow(exp_mat)) {
    genes <- which(
      gene_sets[[rownames(exp_mat)[i]]]@geneIds %in% markers_list_pseudobulk_all[[set]]
    )
    genes <- gene_sets[[rownames(exp_mat)[i]]]@geneIds[genes]
    genes <- gene_anno[gene_anno$ensembl_gene_id %in% genes, ]
    genes <- genes$external_gene_name
    title <- paste0(
      gene_sets[[rownames(exp_mat)[i]]]@shortDescription, ": ",
      gene_sets[[rownames(exp_mat)[i]]]@setName
    )
    print(title)

    if (length(genes) > 0) {
      print(
        paste0(
          gene_sets[[rownames(exp_mat)[i]]]@shortDescription, " DE genes: ",
          paste(genes, collapse = ", ")
        )
      )
      strict_genes <- genes[genes %in% rownames(markers_list_symbols_pseudobulk_strict[[1]])]
      print(
        paste0(
          gene_sets[[rownames(exp_mat)[i]]]@shortDescription, " DE genes in strict model: ",
          paste(strict_genes, collapse = ", ")
        )
      )
      stricter_genes <- genes[genes %in% rownames(markers_list_symbols_pseudobulk_stricter[[1]])]
      print(
        paste0(
          gene_sets[[rownames(exp_mat)[i]]]@shortDescription, " DE genes in stricter model: ",
          paste(stricter_genes, collapse = ", ")
        )
      )
      strictest_genes <- genes[genes %in% rownames(markers_list_symbols_pseudobulk_strictest[[1]])]
      print(
        paste0(
          gene_sets[[rownames(exp_mat)[i]]]@shortDescription, " DE genes in strictest model: ",
          paste(strictest_genes, collapse = ", ")
        )
      )
      row_colors <- rownames(as.matrix(GetAssayData(seurat_symbols)[genes, , drop = FALSE]))
      row_colors <- data.frame(
        row_colors = row_colors,
        DE_strict = row_colors %in% rownames(markers_list_symbols_pseudobulk_strict[[1]]),
        DE_stricter = row_colors %in% rownames(markers_list_symbols_pseudobulk_stricter[[1]]),
        DE_strictest = row_colors %in% rownames(markers_list_symbols_pseudobulk_strictest[[1]])
      ) %>%
        mutate(
          type = case_when(
            DE_strictest == TRUE ~ "firebrick",
            DE_stricter == TRUE ~ "darkorange",
            DE_strict == TRUE ~ "darkgoldenrod",
            TRUE ~ "black"
          )
        )
      row_colors <- row_colors$type
      draw(
        Heatmap(
          t(
            apply(
              as.matrix(GetAssayData(seurat_symbols)[genes, , drop = FALSE]), 1,
              function (x) (x - min(x)) / (max(x) - min(x))
            )
          ),
          color2,
          cluster_columns = FALSE,
          show_column_names = FALSE,
          column_split = seurat_symbols$idents,
          show_heatmap_legend = FALSE,
          top_annotation = anno,
          column_title = title,
          column_title_gp = gpar(fontsize = 20),
          row_names_gp = gpar(fontsize = 18, col = unlist(row_colors)),
          column_gap = unit(2, "mm")
        )
      )
    }

    genes <- gene_sets[[rownames(exp_mat)[i]]]@geneIds
    genes <- gene_anno[gene_anno$ensembl_gene_id %in% genes, ]
    genes <- genes$external_gene_name
    if (length(genes) > 0) {
      print(
        paste0(
          gene_sets[[rownames(exp_mat)[i]]]@shortDescription,
          " all genes: ",
          paste(genes, collapse = ", ")
        )
      )
      draw(
        Heatmap(
          t(
            apply(
              as.matrix(GetAssayData(seurat_symbols)[genes, , drop = FALSE]), 1,
              function (x) (x - min(x)) / (max(x) - min(x))
            )
          ),
          color2,
          cluster_columns = FALSE,
          show_column_names = FALSE,
          column_split = seurat_symbols$idents,
          show_heatmap_legend = FALSE,
          top_annotation = anno,
          column_title = title,
          column_title_gp = gpar(fontsize = 20),
          column_gap = unit(2, "mm")
        )
      )
    }
  }
}
```

## Downregulated in the Direction of `r names(idents)[1]`

```{r, fig.height = 5, fig.width = 20}
set <- 3 # Up or downregulation?
if (length(gsva_list_pseudobulk_all[[set]]) > 0) {
  exp_mat <- mat
  exp_mat <- exp_mat[rownames(exp_mat) %in% gsva_list_pseudobulk_all[[set]], ]
  exp_mat <- exp_mat[rownames(exp_mat) %in% rownames(mat), ]
  sort_mat <- mat[unlist(row_order(heatmap)), ]
  sort_mat <- sort_mat[rownames(sort_mat) %in% rownames(exp_mat), ]
  exp_mat <- exp_mat[match(rownames(sort_mat), rownames(exp_mat)), ]
  for (i in 1:nrow(exp_mat)) {
    genes <- which(
      gene_sets[[rownames(exp_mat)[i]]]@geneIds %in% markers_list_pseudobulk_all[[set]]
    )
    genes <- gene_sets[[rownames(exp_mat)[i]]]@geneIds[genes]
    genes <- gene_anno[gene_anno$ensembl_gene_id %in% genes, ]
    genes <- genes$external_gene_name
    title <- paste0(
      gene_sets[[rownames(exp_mat)[i]]]@shortDescription, ": ",
      gene_sets[[rownames(exp_mat)[i]]]@setName
    )
    print(title)

    if (length(genes) > 0) {
      print(
        paste0(
          gene_sets[[rownames(exp_mat)[i]]]@shortDescription, " DE genes: ",
          paste(genes, collapse = ", ")
        )
      )
      strict_genes <- genes[genes %in% rownames(markers_list_symbols_pseudobulk_strict[[1]])]
      print(
        paste0(
          gene_sets[[rownames(exp_mat)[i]]]@shortDescription, " DE genes in strict model: ",
          paste(strict_genes, collapse = ", ")
        )
      )
      stricter_genes <- genes[genes %in% rownames(markers_list_symbols_pseudobulk_stricter[[1]])]
      print(
        paste0(
          gene_sets[[rownames(exp_mat)[i]]]@shortDescription, " DE genes in stricter model: ",
          paste(stricter_genes, collapse = ", ")
        )
      )
      strictest_genes <- genes[genes %in% rownames(markers_list_symbols_pseudobulk_strictest[[1]])]
      print(
        paste0(
          gene_sets[[rownames(exp_mat)[i]]]@shortDescription, " DE genes in strictest model: ",
          paste(strictest_genes, collapse = ", ")
        )
      )
      row_colors <- rownames(as.matrix(GetAssayData(seurat_symbols)[genes, , drop = FALSE]))
      row_colors <- data.frame(
        row_colors = row_colors,
        DE_strict = row_colors %in% rownames(markers_list_symbols_pseudobulk_strict[[1]]),
        DE_stricter = row_colors %in% rownames(markers_list_symbols_pseudobulk_stricter[[1]]),
        DE_strictest = row_colors %in% rownames(markers_list_symbols_pseudobulk_strictest[[1]])
      ) %>%
        mutate(
          type = case_when(
            DE_strictest == TRUE ~ "firebrick",
            DE_stricter == TRUE ~ "darkorange",
            DE_strict == TRUE ~ "darkgoldenrod",
            TRUE ~ "black"
          )
        )
      row_colors <- row_colors$type
      draw(
        Heatmap(
          t(
            apply(
              as.matrix(GetAssayData(seurat_symbols)[genes, , drop = FALSE]), 1,
              function (x) (x - min(x)) / (max(x) - min(x))
            )
          ),
          color2,
          cluster_columns = FALSE,
          show_column_names = FALSE,
          column_split = seurat_symbols$idents,
          show_heatmap_legend = FALSE,
          top_annotation = anno,
          column_title = title,
          column_title_gp = gpar(fontsize = 20),
          row_names_gp = gpar(fontsize = 18, col = unlist(row_colors)),
          column_gap = unit(2, "mm")
        )
      )
    }

    genes <- gene_sets[[rownames(exp_mat)[i]]]@geneIds
    genes <- gene_anno[gene_anno$ensembl_gene_id %in% genes, ]
    genes <- genes$external_gene_name
    if (length(genes) > 0) {
      print(
        paste0(
          gene_sets[[rownames(exp_mat)[i]]]@shortDescription, " all genes: ",
          paste(genes, collapse = ", ")
        )
      )
      draw(
        Heatmap(
          t(
            apply(
              as.matrix(GetAssayData(seurat_symbols)[genes, , drop = FALSE]), 1,
              function (x) (x - min(x)) / (max(x) - min(x))
            )
          ),
          color2,
          cluster_columns = FALSE,
          show_column_names = FALSE,
          column_split = seurat_symbols$idents,
          show_heatmap_legend = FALSE,
          top_annotation = anno,
          column_title = title,
          column_title_gp = gpar(fontsize = 20),
          column_gap = unit(2, "mm")
        )
      )
    }
  }
}
```

# References

This is the concluding section of the document, where we output the `sessionInfo`, and create a bibliography for works cited.

```{r}
sessionInfo()
```
